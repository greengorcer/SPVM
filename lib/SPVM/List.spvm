class List {
  use Fn;
  use Array;
  
  has values   : object[];
  has capacity : int;
  has length   : ro int;

  private enum {
    DEFAULT_CAPACITY = 16,
  }
  static method new : List ($objects : object[]...) {
    my $self = new List;
    
    my $length : int;
    if ($objects) {
      $length = @$objects;
    }
    else {
      $length = 0;
    }
    
    my $capacity = 0;
    if ($length < List->DEFAULT_CAPACITY()) {
      $capacity = List->DEFAULT_CAPACITY();
    }
    else {
      $capacity = $length;
    }
    $self->{capacity} = $capacity;
    
    if ($objects) {
      $self->{values} = Array->new_proto($objects, $capacity);
    }
    else {
      $self->{values} = Array->new_proto(new object[0], $capacity);
    }
    
    Array->memcpy_object($self->{values}, 0, $objects, 0, scalar @$objects);

    $self->{length} = @$objects;

    return $self;
  }

  static method new_len : List ($proto_array : object[], $length : int) {
    unless ($proto_array) {
      die "First argument must not be undef";
    }
    
    my $self = new List;
    unless ($length >= 0) {
      die "length must be more than or equals to zero";
    }
    my $capacity = 0;
    if ($length < List->DEFAULT_CAPACITY()) {
      $capacity = List->DEFAULT_CAPACITY();
    }
    else {
      $capacity = $length;
    }
    $self->{capacity} = $capacity;
    $self->{length} = $length;
    $self->{values} = Array->new_proto($proto_array, $capacity);
    return $self;
  }
  
  method insert : void ($index : int, $value : object) {
    my $length = $self->{length};
    my $capacity = $self->{capacity};
    
    unless ($index >= 0 && $index <= $length) {
      die "Out of range";
    }
    
    if ($length >= $capacity) {
      $self->_extend;
    }
    
    my $values = $self->{values};
    if ($index != $length) {
      Array->memmove_object($values, $index + 1, $values, $index, $length - $index);
    }
    $values->[$index] = $value;
    
    $self->{length}++;
  }

  method remove : object ($index : int) {
    my $length = $self->{length};
    my $capacity = $self->{capacity};
    
    unless ($index >= 0 && $index < $length) {
      die "Out of range";
    }
    
    my $values = $self->{values};
    my $remove_value = $values->[$index];

    Array->memmove_object($values, $index, $values, $index + 1, $length - 1 - $index);
    $values->[$length - 1] = undef;
    
    $self->{length}--;
    
    return $remove_value;
  }

  method push : void ($value : object) {
    my $length = $self->{length};
    my $capacity = $self->{capacity};

    if ($length >= $capacity) {
      $self->_extend;
    }
    my $index = $self->{length};
    $self->{values}[$index] = $value;
    ++$self->{length};
  }
  
  method pop : object () {
    if ($self->{length} <= 0) {
      die "Length must be more than 0 for pop";
    }
    
    my $index = $self->{length};
    
    my $ret = $self->{values}[$index - 1];
    
    $self->{values}[$index - 1] = undef;
    
    --$self->{length};
    
    return $ret;
  }

  method unshift : void ($value : object) {
    my $length = $self->{length};
    my $capacity = $self->{capacity};
    
    if ($length >= $capacity) {
      $self->_extend;
    }
    
    my $values = $self->{values};
    
    Array->memmove_object($values, 1, $values, 0, $length);
    
    $values->[0] = $value;
    $self->{length}++;
  }

  method shift : object () {
    my $length = $self->{length};
    my $capacity = $self->{capacity};
    
    if ($length == 0) {
      die "Length must be more than 0 for shift";
    }
    
    my $values = $self->{values};
    
    my $value = $values->[0];
    
    Array->memmove_object($values, 0, $values, 1, $length - 1);
    $values->[$length - 1] = undef;
    
    $self->{length}--;
    
    return $value;
  }

  method set : void ($index : int, $value : object) {
    my $length = $self->length;

    if ($index < 0 || $index > $length - 1) {
      die "Out of range";
    }
    
    $self->{values}[$index] = $value;
  }

  method set_array : void ($array : object[]) {
    unless ($array) {
      die "Array must be defined";
    }
    
    my $cur_length = $self->length;
    
    my $set_length = @$array;
    
    unless ($set_length == $cur_length) {
      die "The length of argument array must be same as the length of current list array";
    }
    
    my $values = $self->{values};
    Array->memcpy_object($values, 0, $array, 0, $cur_length);
  }

  method get : object ($index : int) {
    my $length = $self->length;

    if ($index < 0 || $index > $length - 1) {
      die "Out of range";
    }
    
    return $self->{values}[$index];
  }

  precompile private method _extend_with_capacity : void ($new_capacity : int) {
    my $new_values = Array->new_proto($self->{values}, $new_capacity);
    for (my $i = 0; $i < $self->{length}; ++$i) {
      my $target = $i;
      if ($target < 0) { $target += $self->{capacity}; };
      $new_values->[$i] = $self->{values}[$target];
    }
    $self->{capacity} = $new_capacity;
    $self->{values} = $new_values;
  }

  private method _extend : void () {
    my $capacity = $self->{capacity};
    my $length = $self->{length};
    my $values = $self->{values};
    
    my $new_capacity = $capacity * 2;
    
    my $new_values = Array->new_proto($self->{values}, $new_capacity);
    
    Array->memcpy_object($new_values, 0, $values, 0, $length);
    
    $self->{values} = $new_values;
    $self->{capacity} = $new_capacity;
  }
  
  method resize : void ($new_length : int) {
    if ($new_length < 0) {
      die "New length must be more than or equals to 0";
    }
    
    my $length = $self->{length};
    my $capacity = $self->{capacity};
    
    if ($new_length > $length) {
      if ($new_length > $capacity) {
        $self->_extend_with_capacity($new_length);
      }
    }
    elsif ($new_length < $length) {
      Array->memset_object($self->{values}, $new_length, undef, $length - $new_length);
    }
    $self->{length} = $new_length;
  }
  
  method to_array : object[] () {
    my $length = $self->{length};
    my $objects = Array->new_proto($self->{values}, $length);
    Array->memcpy_object($objects, 0, $self->{values}, 0, $length);
    return $objects;
  }
}
