package SPVM::ArrayUtil : precompile {
  use SPVM::Cloner;
  use SPVM::EqualityChecker;
  use SPVM::StringUtil;
  
  sub copy_object_array : object[] ($objects : object[], $cloner : SPVM::Cloner) {
    my $length = @$objects;

    my $new_objects = new object[$length];

    for (my $i = 0; $i < $length; $i++) {
      $new_objects->[$i] = $cloner->($objects->[$i]);
    }

    return $new_objects;
  }

  sub equals_object_array : int ($objs1 : oarray, $objs2 : oarray, $equality_checker : SPVM::EqualityChecker) {
    my $is_equals = 1;
    if (@$objs1 == @$objs2) {
      for (my $i = 0; $i < @$objs1; $i++) {
        if (!$equality_checker->($objs1->[$i], $objs2->[$i])) {
          $is_equals = 0;
          last;
        }
      }
    }
    else {
      $is_equals = 0;
    }

    return $is_equals;
  }

  sub copy_byte_array : byte[] ($nums : byte[]) {
    my $length = @$nums;

    my $new_nums = new byte[$length];

    for (my $i = 0; $i < $length; $i++) {
      $new_nums->[$i] = $nums->[$i];
    }

    return $new_nums;
  }

  sub copy_short_array : short[] ($nums : short[]) {
    my $length = @$nums;

    my $new_nums = new short[$length];

    for (my $i = 0; $i < $length; $i++) {
      $new_nums->[$i] = $nums->[$i];
    }

    return $new_nums;
  }

  sub copy_int_array : int[] ($nums : int[]) {
    my $length = @$nums;

    my $new_nums = new int[$length];

    for (my $i = 0; $i < $length; $i++) {
      $new_nums->[$i] = $nums->[$i];
    }

    return $new_nums;
  }

  sub copy_long_array : long[] ($nums : long[]) {
    my $length = @$nums;

    my $new_nums = new long[$length];

    for (my $i = 0; $i < $length; $i++) {
      $new_nums->[$i] = $nums->[$i];
    }

    return $new_nums;
  }

  sub copy_float_array : float[] ($nums : float[]) {
    my $length = @$nums;

    my $new_nums = new float[$length];

    for (my $i = 0; $i < $length; $i++) {
      $new_nums->[$i] = $nums->[$i];
    }

    return $new_nums;
  }

  sub copy_double_array : double[] ($nums : double[]) {
    my $length = @$nums;

    my $new_nums = new double[$length];

    for (my $i = 0; $i < $length; $i++) {
      $new_nums->[$i] = $nums->[$i];
    }

    return $new_nums;
  }

  sub copy_string_array : string[] ($strings : string[]) {
    my $length = @$strings;

    my $new_strings = new string[$length];

    for (my $i = 0; $i < $length; $i++) {
      $new_strings->[$i] = SPVM::StringUtil->copy_str($strings->[$i]);
    }

    return $new_strings;
  }

  sub equals_byte_array : int ($nums1 : byte[], $nums2 : byte[]) {
    my $is_equals = 1;
    if (@$nums1 == @$nums2) {
      for (my $i = 0; $i < @$nums1; $i++) {
        if ($nums1->[$i] != $nums2->[$i]) {
          $is_equals = 0;
          last;
        }
      }
    }
    else {
      $is_equals = 0;
    }

    return $is_equals;
  }

  sub equals_short_array : int ($nums1 : short[], $nums2 : short[]) {
    my $is_equals = 1;
    if (@$nums1 == @$nums2) {
      for (my $i = 0; $i < @$nums1; $i++) {
        if ($nums1->[$i] != $nums2->[$i]) {
          $is_equals = 0;
          last;
        }
      }
    }
    else {
      $is_equals = 0;
    }

    return $is_equals;
  }
  sub equals_int_array : int ($nums1 : int[], $nums2 : int[]) {
    my $is_equals = 1;
    if (@$nums1 == @$nums2) {
      for (my $i = 0; $i < @$nums1; $i++) {
        if ($nums1->[$i] != $nums2->[$i]) {
          $is_equals = 0;
          last;
        }
      }
    }
    else {
      $is_equals = 0;
    }

    return $is_equals;
  }
  sub equals_long_array : int ($nums1 : long[], $nums2 : long[]) {
    my $is_equals = 1;
    if (@$nums1 == @$nums2) {
      for (my $i = 0; $i < @$nums1; $i++) {
        if ($nums1->[$i] != $nums2->[$i]) {
          $is_equals = 0;
          last;
        }
      }
    }
    else {
      $is_equals = 0;
    }

    return $is_equals;
  }
  sub equals_float_array : int ($nums1 : float[], $nums2 : float[]) {
    my $is_equals = 1;
    if (@$nums1 == @$nums2) {
      for (my $i = 0; $i < @$nums1; $i++) {
        if ($nums1->[$i] != $nums2->[$i]) {
          $is_equals = 0;
          last;
        }
      }
    }
    else {
      $is_equals = 0;
    }

    return $is_equals;
  }
  sub equals_double_array : int ($nums1 : double[], $nums2 : double[]) {
    my $is_equals = 1;
    if (@$nums1 == @$nums2) {
      for (my $i = 0; $i < @$nums1; $i++) {
        if ($nums1->[$i] != $nums2->[$i]) {
          $is_equals = 0;
          last;
        }
      }
    }
    else {
      $is_equals = 0;
    }

    return $is_equals;
  }

  sub equals_string_array : int ($strings1 : string[], $strings2 : string[]) {
    my $is_equals = 1;
    if (@$strings1 == @$strings2) {
      for (my $i = 0; $i < @$strings1; $i++) {
        if ($strings1->[$i] ne $strings2->[$i]) {
          $is_equals = 0;
          last;
        }
      }
    }
    else {
      $is_equals = 0;
    }

    return $is_equals;
  }

  sub dump_byte_array : string ($nums : byte[]) {
    
    if ($nums == undef) {
      return undef;
    }
    
    my $dump = "[\n";

    for (my $i = 0; $i < @$nums; $i++) {
      my $string = (string)$nums->[$i];
      $dump .= "  $string";
      if ($i != @$nums - 1) {
        $dump .= ",\n";
      }
      else {
        $dump .= "\n";
      }
    }
    
    $dump .= "]";

    return $dump;
  }

  sub dump_short_array : string ($nums : short[]) {
    
    if ($nums == undef) {
      return undef;
    }
    
    my $dump = "[\n";

    for (my $i = 0; $i < @$nums; $i++) {
      my $string = (string)$nums->[$i];
      $dump .= "  $string";
      if ($i != @$nums - 1) {
        $dump .= ",\n";
      }
      else {
        $dump .= "\n";
      }
    }
    
    $dump .= "]";

    return $dump;
  }

  sub dump_int_array : string ($nums : int[]) {
    
    if ($nums == undef) {
      return undef;
    }
    
    my $dump = "[\n";

    for (my $i = 0; $i < @$nums; $i++) {
      my $string = (string)$nums->[$i];
      $dump .= "  $string";
      if ($i != @$nums - 1) {
        $dump .= ",\n";
      }
      else {
        $dump .= "\n";
      }
    }
    
    $dump .= "]";

    return $dump;
  }

  sub dump_long_array : string ($nums : long[]) {
    
    if ($nums == undef) {
      return undef;
    }
    
    my $dump = "[\n";

    for (my $i = 0; $i < @$nums; $i++) {
      my $string = (string)$nums->[$i];
      $dump .= "  $string";
      if ($i != @$nums - 1) {
        $dump .= ",\n";
      }
      else {
        $dump .= "\n";
      }
    }
    
    $dump .= "]";

    return $dump;
  }

  sub dump_unsigned_byte_array : string ($nums : byte[]) {
    
    if ($nums == undef) {
      return undef;
    }
    
    my $dump = "[\n";

    for (my $i = 0; $i < @$nums; $i++) {
      my $string = SPVM::StringUtil->sprintf("%u", (int)$nums->[$i] & 0xFF);
      $dump .= "  $string";
      if ($i != @$nums - 1) {
        $dump .= ",\n";
      }
      else {
        $dump .= "\n";
      }
    }
    
    $dump .= "]";

    return $dump;
  }

  sub dump_unsigned_short_array : string ($nums : short[]) {
    
    if ($nums == undef) {
      return undef;
    }
    
    my $dump = "[\n";

    for (my $i = 0; $i < @$nums; $i++) {
      my $string = SPVM::StringUtil->sprintf("%u", (int)$nums->[$i] & 0xFFFF);
      $dump .= "  $string";
      if ($i != @$nums - 1) {
        $dump .= ",\n";
      }
      else {
        $dump .= "\n";
      }
    }
    
    $dump .= "]";

    return $dump;
  }

  sub dump_unsigned_int_array : string ($nums : int[]) {
    
    if ($nums == undef) {
      return undef;
    }
    
    my $dump = "[\n";

    for (my $i = 0; $i < @$nums; $i++) {
      my $string = SPVM::StringUtil->sprintf("%u", $nums->[$i]);
      $dump .= "  $string";
      if ($i != @$nums - 1) {
        $dump .= ",\n";
      }
      else {
        $dump .= "\n";
      }
    }
    
    $dump .= "]";

    return $dump;
  }

  sub dump_unsigned_long_array : string ($nums : long[]) {
    
    if ($nums == undef) {
      return undef;
    }
    
    my $dump = "[\n";

    for (my $i = 0; $i < @$nums; $i++) {
      my $string = SPVM::StringUtil->sprintf("%lu", $nums->[$i]);
      $dump .= "  $string";
      if ($i != @$nums - 1) {
        $dump .= ",\n";
      }
      else {
        $dump .= "\n";
      }
    }
    
    $dump .= "]";

    return $dump;
  }

  sub dump_float_array : string ($nums : float[]) {
    
    if ($nums == undef) {
      return undef;
    }
    
    my $dump = "[\n";

    for (my $i = 0; $i < @$nums; $i++) {
      my $string = (string)$nums->[$i];
      $dump .= "  $string";
      if ($i != @$nums - 1) {
        $dump .= ",\n";
      }
      else {
        $dump .= "\n";
      }
    }
    
    $dump .= "]";

    return $dump;
  }

  sub dump_double_array : string ($nums : double[]) {
    
    if ($nums == undef) {
      return undef;
    }
    
    my $dump = "[\n";

    for (my $i = 0; $i < @$nums; $i++) {
      my $string = (string)$nums->[$i];
      $dump .= "  $string";
      if ($i != @$nums - 1) {
        $dump .= ",\n";
      }
      else {
        $dump .= "\n";
      }
    }
    
    $dump .= "]";

    return $dump;
  }

  sub dump_object_array : string ($objects : oarray, $stringer : SPVM::Stringer) {
    
    if ($objects == undef) {
      return undef;
    }
    
    my $dump = "[\n";

    for (my $i = 0; $i < @$objects; $i++) {
      my $string = $stringer->($objects->[$i]);
      $dump .= "  $string";
      if ($i != @$objects - 1) {
        $dump .= ",\n";
      }
      else {
        $dump .= "\n";
      }
    }
    
    $dump .= "]";

    return $dump;
  }

  native sub memcpy_byte : void ($dest_data : byte[], $dest_offset : int, $src_data : byte[], $src_offset : int, $length : int);
  native sub memcpy_short : void ($dest_data : short[], $dest_offset : int, $src_data : short[], $src_offset : int, $length : int);
  native sub memcpy_int : void ($dest_data : int[], $dest_offset : int, $src_data : int[], $src_offset : int, $length : int);
  native sub memcpy_long : void ($dest_data : long[], $dest_offset : int, $src_data : long[], $src_offset : int, $length : int);
  native sub memcpy_float : void ($dest_data : float[], $dest_offset : int, $src_data : float[], $src_offset : int, $length : int);
  native sub memcpy_double : void ($dest_data : double[], $dest_offset : int, $src_data : double[], $src_offset : int, $length : int);

  native sub memmove_byte : void ($dest_data : byte[], $dest_offset : int, $src_data : byte[], $src_offset : int, $length : int);
  native sub memmove_short : void ($dest_data : short[], $dest_offset : int, $src_data : short[], $src_offset : int, $length : int);
  native sub memmove_int : void ($dest_data : int[], $dest_offset : int, $src_data : int[], $src_offset : int, $length : int);
  native sub memmove_long : void ($dest_data : long[], $dest_offset : int, $src_data : long[], $src_offset : int, $length : int);
  native sub memmove_float : void ($dest_data : float[], $dest_offset : int, $src_data : float[], $src_offset : int, $length : int);
  native sub memmove_double : void ($dest_data : double[], $dest_offset : int, $src_data : double[], $src_offset : int, $length : int);

  native sub new_object_array_proto : oarray ($proto_array : oarray, $length : int);

  sub slice_byte : byte[] ($nums : byte[], $offset : int, $length : int) {

    if ($nums == undef) {
      die "Array must be defined";
    }

    my $array_length = @$nums;

    if ($offset < 0 || $offset > $array_length - 1) {
      die "Invalid offset $offset";
    }

    if ($length < 0) {
      die "Length must be non-zero value";
    }

    if ($offset + $length > $array_length) {
      die "Offset + length must not be over array length";
    }

    my $slice = new byte[$length];

    my $pos = 0;
    for (my $i = $offset; $i < $offset + $length; $i++) {
      $slice->[$pos] = $nums->[$i];
      $pos++;
    }

    return $slice;
  }

  sub slice_short : short[] ($nums : short[], $offset : int, $length : int) {

    if ($nums == undef) {
      die "Array must be defined";
    }

    my $array_length = @$nums;

    if ($offset < 0 || $offset > $array_length - 1) {
      die "Invalid offset $offset";
    }

    if ($length < 0) {
      die "Length must be non-zero value";
    }

    if ($offset + $length > $array_length) {
      die "Offset + length must not be over array length";
    }

    my $slice = new short[$length];

    my $pos = 0;
    for (my $i = $offset; $i < $offset + $length; $i++) {
      $slice->[$pos] = $nums->[$i];
      $pos++;
    }

    return $slice;
  }

  sub slice_int : int[] ($nums : int[], $offset : int, $length : int) {

    if ($nums == undef) {
      die "Array must be defined";
    }

    my $array_length = @$nums;

    if ($offset < 0 || $offset > $array_length - 1) {
      die "Invalid offset $offset";
    }

    if ($length < 0) {
      die "Length must be non-zero value";
    }

    if ($offset + $length > $array_length) {
      die "Offset + length must not be over array length";
    }

    my $slice = new int[$length];

    my $pos = 0;
    for (my $i = $offset; $i < $offset + $length; $i++) {
      $slice->[$pos] = $nums->[$i];
      $pos++;
    }

    return $slice;
  }

  sub slice_long : long[] ($nums : long[], $offset : int, $length : int) {

    if ($nums == undef) {
      die "Array must be defined";
    }

    my $array_length = @$nums;

    if ($offset < 0 || $offset > $array_length - 1) {
      die "Invalid offset $offset";
    }

    if ($length < 0) {
      die "Length must be non-zero value";
    }

    if ($offset + $length > $array_length) {
      die "Offset + length must not be over array length";
    }

    my $slice = new long[$length];

    my $pos = 0;
    for (my $i = $offset; $i < $offset + $length; $i++) {
      $slice->[$pos] = $nums->[$i];
      $pos++;
    }

    return $slice;
  }

  sub slice_float : float[] ($nums : float[], $offset : int, $length : int) {

    if ($nums == undef) {
      die "Array must be defined";
    }

    my $array_length = @$nums;

    if ($offset < 0 || $offset > $array_length - 1) {
      die "Invalid offset $offset";
    }

    if ($length < 0) {
      die "Length must be non-zero value";
    }

    if ($offset + $length > $array_length) {
      die "Offset + length must not be over array length";
    }

    my $slice = new float[$length];

    my $pos = 0;
    for (my $i = $offset; $i < $offset + $length; $i++) {
      $slice->[$pos] = $nums->[$i];
      $pos++;
    }

    return $slice;
  }

  sub slice_double : double[] ($nums : double[], $offset : int, $length : int) {

    if ($nums == undef) {
      die "Array must be defined";
    }

    my $array_length = @$nums;

    if ($offset < 0 || $offset > $array_length - 1) {
      die "Invalid offset $offset";
    }

    if ($length < 0) {
      die "Length must be non-zero value";
    }

    if ($offset + $length > $array_length) {
      die "Offset + length must not be over array length";
    }

    my $slice = new double[$length];

    my $pos = 0;
    for (my $i = $offset; $i < $offset + $length; $i++) {
      $slice->[$pos] = $nums->[$i];
      $pos++;
    }

    return $slice;
  }

  sub slice_object : oarray ($elems : oarray, $offset : int, $length : int) {

    if ($elems == undef) {
      die "Array must be defined";
    }

    my $array_length = @$elems;

    if ($offset < 0 || $offset > $array_length - 1) {
      die "Invalid offset $offset";
    }

    if ($length < 0) {
      die "Length must be non-zero value";
    }

    if ($offset + $length > $array_length) {
      die "Offset + length must not be over array length";
    }

    my $slice = new_object_array_proto($elems, $length);

    my $pos = 0;
    for (my $i = $offset; $i < $offset + $length; $i++) {
      $slice->[$pos] = $elems->[$i];
      $pos++;
    }

    return $slice;
  }

}
