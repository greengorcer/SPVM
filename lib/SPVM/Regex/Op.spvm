class Regex::Op {
  allow Regex::Parser;
  allow Regex::Tokenizer;
  
  enum {
    ID_PAREN_OPEN_BEGIN_CAPTURE,
    ID_PAREN_CLOSE_END_CAPTURE,
    ID_BRACKET_OPEN_BEGIN_CHAR_CLASS,
    ID_BRACKET_CLOSE_END_CHAR_CLASS,
    ID_VRITICAL_BAR_OR,
    ID_HYPHEN_CHAR_OR_RANGE,
    ID_CARRET_CHAR_CLASS_NEGATE,
    ID_CHAR,
    ID_CHAR_CLASS,
    ID_CONCAT,
    ID_ALTERNATE,
    ID_REPEAT,
    ID_CAPTURE,
  }
  
  enum {
    CHAR_CATEGORY_CHAR,
    CHAR_CATEGORY_CHAR_RANGES,
    CHAR_CATEGORY_EMPTY_CHAR,
    CHAR_CATEGORY_ASCII_NUMBER,
    CHAR_CATEGORY_ASCII_WORD,
    CHAR_CATEGORY_ASCII_SPACE,
    CHAR_CATEGORY_LINE_BEGIN,
    CHAR_CATEGORY_LINE_END,
    CHAR_CATEGORY_TEXT_BEGIN,
    CHAR_CATEGORY_TEXT_END,
    CHAR_CATEGORY_WORD_BOUNDARY,
  }
  
  has id : int;

  has char_category : int;
  has char_code_point_ranges : int[];
  has char_negate : int;
  
  has repeat_min : int;
  has repeat_max : int;

  has ops : List of Regex::Op;
  
  static method new : Regex::Op ($options : object[]...) {
    return new Regex::Op;
  }

  static method new_op_char_char_class : Regex::Op ($code_point_ranges : int[]) {
    my $op_char = Regex::Op->new;
    
    $op_char->{id} = Regex::Op->ID_CHAR;
    $op_char->{char_category} = Regex::Op->CHAR_CATEGORY_CHAR_RANGES;
    $op_char->{char_code_point_ranges} = $code_point_ranges;
    
    return $op_char;
  }

  static method new_op_char_char : Regex::Op ($code_point : int) {
    my $op_char = Regex::Op->new;
    
    $op_char->{id} = Regex::Op->ID_CHAR;
    $op_char->{char_category} = Regex::Op->CHAR_CATEGORY_CHAR_RANGES;
    $op_char->{char_code_point_ranges} = [$code_point, $code_point];
    
    return $op_char;
  }

  static method new_op_char_category : Regex::Op ($category : int) {
    my $op_char = Regex::Op->new;
    
    $op_char->{id} = Regex::Op->ID_CHAR;
    $op_char->{char_category} = $category;
    
    return $op_char;
  }
  
}
