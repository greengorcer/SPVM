class Regex::Parser {
  use Regex::Op;
  use Regex::Tokenizer;
  
  has op_stack : List of Regex::Op;
  
  static method new : Regex::Parser ($options : object[]...) {
    return new Regex::Parser;
  }
  
  private method new_op_char_char_class : Regex::Op ($code_point_ranges : int[]) {
    my $op_char = Regex::Op->new;
    
    $op_char->{id} = Regex::Op->ID_CHAR;
    $op_char->{char_category} = Regex::Op->CHAR_CATEGORY_CHAR_RANGES;
    $op_char->{char_code_point_ranges} = $code_point_ranges;
    
    return $op_char;
  }

  private method new_op_char_char : Regex::Op ($code_point : int) {
    my $op_char = Regex::Op->new;
    
    $op_char->{id} = Regex::Op->ID_CHAR;
    $op_char->{char_category} = Regex::Op->CHAR_CATEGORY_CHAR_RANGES;
    $op_char->{char_code_point_ranges} = [$code_point, $code_point];
    
    return $op_char;
  }

  private method new_op_char_category : Regex::Op ($category : int) {
    my $op_char = Regex::Op->new;
    
    $op_char->{id} = Regex::Op->ID_CHAR;
    $op_char->{char_category} = $category;
    
    return $op_char;
  }
  
  method parse : Regex::Op ($re_str : string) {
    
    my $tokenizer = Regex::Tokenizer->new;
    $tokenizer->{source} = "($re_str)";
    
    # Op stack
    my $op_stack = $self->{op_stack};
    
    my $char_class_parsing = 0;
    my $pos = 0;
    while (my $op_token = $tokenizer->get_next_token) {
      my $next_op_token = $tokenizer->look_next_token;
     
      my $op_stack_top = (Regex::Op)$op_stack->get($op_stack->length - 1);
      
      my $op_char = (Regex::Op)undef;
      switch ($op_token->{id}) {
        case Regex::Op->ID_PAREN_OPEN_BEGIN_CAPTURE: {
          $op_stack->push($op_token);
          break;
        }
        case Regex::Op->ID_PAREN_CLOSE_END_CAPTURE: {
          break;
        }
        case Regex::Op->ID_BRACKET_OPEN_BEGIN_CHAR_CLASS: {
          $char_class_parsing = 1;
          break;
        }
        case Regex::Op->ID_BRACKET_CLOSE_END_CHAR_CLASS: {
          $char_class_parsing = 0;
          break;
        }
        case Regex::Op->ID_VRITICAL_BAR_OR: {
          switch ($op_stack_top->{id}) {
            case Regex::Op->ID_VRITICAL_BAR_OR:
            {
              $op_char = $self->new_op_char_category(Regex::Op->CHAR_CATEGORY_EMPTY_CHAR);
              $op_stack->push($op_char);
              break;
            }
            case Regex::Op->ID_CHAR:
            case Regex::Op->ID_CONCAT:
            case Regex::Op->ID_REPEAT:
            case Regex::Op->ID_OR:
            case Regex::Op->ID_CAPTURE:
            {
              my $or_op = Regex::Op->new;
              $or_op->{id} = Regex::Op->ID_VRITICAL_BAR_OR;
              $or_op->{ops} = List->new([$op_stack_top]);
              $op_stack->set($op_stack->length - 1, $or_op);
              break;
            }
            default: {
              die;
              break;
            }
          }
          
          break;
        }
        case Regex::Op->ID_HYPHEN_CHAR_OR_RANGE: {
          
          break;
        }
        case Regex::Op->ID_CARRET_CHAR_CLASS_NEGATE: {
          
          break;
        }
        case Regex::Op->ID_CHAR: {
          $op_stack->push($op_token);
          break;
        }
        case Regex::Op->ID_CHAR_CLASS: {
          break;
        }
        case Regex::Op->ID_CONCAT: {
          break;
        }
        case Regex::Op->ID_OR: {
          break;
        }
        case Regex::Op->ID_REPEAT: {
          switch ($op_stack_top->{id}) {
            case Regex::Op->ID_CHAR:
            case Regex::Op->ID_CONCAT:
            case Regex::Op->ID_OR:
            case Regex::Op->ID_CAPTURE:
            {
              my $repeat_op = Regex::Op->new;
              $repeat_op->{id} = Regex::Op->ID_REPEAT;
              $repeat_op->{ops} = List->new([$op_stack_top]);
              $repeat_op->{repeat_min} = 1;
              $repeat_op->{repeat_max} = -1;
              $op_stack->set($op_stack->length - 1, $repeat_op);
              break;
            }
            case Regex::Op->ID_PAREN_OPEN_BEGIN_CAPTURE:
            case Regex::Op->ID_VRITICAL_BAR_OR:
            {
              die;
              break;
            }
          }
          
          break;
        }
        case Regex::Op->ID_CAPTURE: {
          break;
        }
        default: {
          die;
        }
      }
    }
    
    unless ($op_stack->length == 1) {
      die;
    }
    
    # Root op
    my $root_op = (Regex::Op)$op_stack->pop;
    
    return $root_op;
  }

  private method negate_code_point_ranges : int[] ($code_point_ranges : int[]) {
    
    if (@$code_point_ranges < 2) {
      die "The length of the code point rainges must be more than 2";
    }

    my $negate_code_point_rainges_raw_list = IntList->new;
    $negate_code_point_rainges_raw_list->push(0);
    for (my $i = 0; $i < @$code_point_ranges; $i += 2) {
      my $min = $code_point_ranges->[$i];
      my $max = $code_point_ranges->[$i + 1];
      $negate_code_point_rainges_raw_list->push($min - 1);
      $negate_code_point_rainges_raw_list->push($max + 1);
    }
    $negate_code_point_rainges_raw_list->push(0x10FFFF);

    my $cur_max = 0;
    my $negate_code_point_rainges_list = IntList->new;
    for (my $i = 0; $i < $negate_code_point_rainges_raw_list->length; $i += 2) {
      my $min = $negate_code_point_rainges_raw_list->get($i);
      my $max = $negate_code_point_rainges_raw_list->get($i + 1);
      unless ($min > $max) {
        $negate_code_point_rainges_list->push($min);
        $negate_code_point_rainges_list->push($max);
      }
    }
    
    my $negate_code_point_rainges = $negate_code_point_rainges_list->to_array;

    return $negate_code_point_rainges;
  }
}
