class StringBuffer {
  use Fn;
  use Array;

  has value : ro mutable string;
  has length : ro int;
  
  static method new : StringBuffer () {
    my $self = new StringBuffer;
    my $default_capacity = StringBuffer->DEFAULT_CAPACITY();
    $self->{value} = (mutable string)new_string_len($default_capacity);
    $self->{length} = 0;
    return $self;
  }
  
  method push : void ($string : string) {
    my $length = length($string);
    my $capacity = length $self->{value};
    if ($self->{length} + $length > $capacity) {
      my $new_capacity : int;
      if ($self->{length} + $length > $capacity * 2) {
        $new_capacity = $self->{length} + $length;
      } else {
        $new_capacity = $capacity * 2;
      }
      $self->_reallocate($new_capacity);
    }
    Fn->memcpy($self->{value}, $self->{length}, $string, 0, $length);
    $self->{length} += $length;
  }

  method push_char : void ($char : byte) {
    my $capacity = length $self->{value};
    if ($self->{length} + 1 > $capacity) {
      my $new_capacity = $capacity * 2;
      $self->_reallocate($new_capacity);
    }
    $self->{value}[$self->{length}++] = $char;
  }

  method replace : void ($offset : int, $length : int, $replace : string) {
    unless ($offset >= 0) {
      die("The offset must be greater than or equal to 0");
    }
    
    unless ($offset + $length <= $self->{length}) {
      die("The offset + the lenght must be less than or equal to the length of the string that the string buffer has");
    }

    if ($length > $self->{length} - $offset) {
      $length = $self->{length} - $offset;
    }

    my $replace_length = 0;
    if ($replace) {
      $replace_length = length($replace);
    }

    my $capacity = length $self->{value};
    if ($self->{length} - $length + $replace_length > $capacity) {
      # O($new_string_length)
      $self->_reallocate($self->{length} - $length + $replace_length);
    }

    my $last_sequence_length = $self->{length} - $offset - $length;
    if ($length > $replace_length) {
      # move last sequence to forward
      for (my $i = 0; $i < $last_sequence_length; ++$i) {
        my $origin = $offset + $length + $i;
        my $target = $offset + $replace_length + $i;
        $self->{value}[$target] = $self->{value}[$origin];
      }
    }
    else {
      # move last sequence to backward
      for (my $i = 0; $i < $last_sequence_length; ++$i) {
        my $origin = $self->{length} - 1 - $i;
        my $target = $offset + $replace_length + $last_sequence_length - 1 - $i;
        $self->{value}[$target] = $self->{value}[$origin];
      }
    }

    # replace with new array
    for (my $i = 0; $i < $replace_length; ++$i) {
      my $target = $offset + $i;
      $self->{value}[$target] = $replace->[$i];
    }

    $self->{length} += $replace_length - $length;
  }

  method to_string : string () {
    return (Fn->substr($self->{value}, 0, $self->{length}));
  }

  private enum {
    DEFAULT_CAPACITY = 16,
  }
  
  # O($new_capacity)
  private method _reallocate : void ($new_capacity : int) {
    my $new_string = (mutable string)new_string_len($new_capacity);
    Fn->memcpy($new_string, 0, $self->{value}, 0, $self->{length});
    $self->{value} = $new_string;
  }
}
