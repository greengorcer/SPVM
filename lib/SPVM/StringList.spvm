class StringList {
  use Fn;
  use Array;
  
  # Fields
  has values : ro string[];
  has length : ro int;
  
  # Private fields
  has capacity : int;
  
  # Class methods
  static method new : StringList ($array : string[]...) {
    my $self = new StringList;
    my $length : int;
    if ($array) {
      $length = @$array;
    }
    else {
      $length = 0;
    }
    
    my $capacity = $length;
    $self->{capacity} = $capacity;
    my $values = new string[$capacity];
    
    $self->{length} = $length;
    
    Array->memcpy_object($values, 0, $array, 0, $length);
    
    $self->{values} = $values;
    
    return $self;
  }
  
  static method new_len : StringList ($length : int) {
    my $self = new StringList;
    unless ($length >= 0) {
      die "The length must be greater than or equal to 0";
    }
    my $capacity = $length;
    $self->{capacity} = $capacity;
    $self->{length} = $length;
    $self->{values} = new string[$capacity];
    return $self;
  }
  
  method get : string ($index : int) {
    my $length = $self->length;
    
    unless ($index >= 0) {
      die "The index must be greater than or equal to 0";
    }
    
    unless ($index < $length) {
      die "The index must be less than the length";
    }
    
    my $value = $self->{values}[$index];
    
    return $value;
  }
  
  precompile method grep : int ($search : string) {
    for (my $i = 0; $i < $self->length; ++$i) {
      if ($self->{values}->[$i] eq $search) {
        return 1;
      }
    }
    return 0;
  }
  
  method insert : void ($index : int, $value : string) {
    my $length = $self->{length};
    my $capacity = $self->{capacity};
    
    unless ($index >= 0) {
      die "The index must be greater than or equal to 0";
    }
    
    unless ($index <= $length) {
      die "The index must be less than or equal to the length of the array";
    }
    
    my $new_length = $length + 1;
    $self->_maybe_extend($new_length);
    
    my $values = $self->{values};
    if ($index != $length) {
      Array->memmove_object($values, $index + 1, $values, $index, $length - $index);
    }
    $values->[$index] = $value;
    
    $self->{length}++;
  }

  method pop : string () {
    my $length = $self->length;
    
    unless ($length > 0) {
      die "The length of the array must be greater than 0";
    }
    
    my $value = $self->{values}[$length - 1];
    
    $self->{length}--;
    
    return $value;
  }
  
  method push : void ($value : string) {
    my $length = $self->{length};
    my $capacity = $self->{capacity};
    
    my $new_length = $length + 1;
    $self->_maybe_extend($new_length);
    
    $self->{values}[$length] = $value;
    
    $self->{length}++;
  }
  
  method remove : string ($index : int) {
    my $length = $self->{length};
    my $capacity = $self->{capacity};
    
    unless ($index >= 0) {
      die "The index must be greater than or equal to 0";
    }
    
    unless ($index < $length) {
      die "The index must be less than the length of the array";
    }
    
    my $values = $self->{values};
    my $remove_value = $values->[$index];
    
    my $move_length = $length - $index - 1;
    Array->memmove_object($values, $index, $values, $index + 1, $move_length);
    
    $values->[$length - 1] = undef;
    
    $self->{length}--;
    
    return $remove_value;
  }
  
  method replace : void ($offset : int, $remove_length : int, $replace : string[]) {
    unless ($offset >= 0) {
      die("The offset must be greater than or equal to 0");
    }
    
    unless ($remove_length >= 0) {
      die("The removing length must be greater than or equal to 0");
    }
    unless ($offset + $remove_length <= $self->{length}) {
      die("The offset + the removing lenght must be less than or equal to the length of the values of the list");
    }
    
    unless ($replace) {
      die("The replacement array must be defined");
    }
    
    my $replace_length = @$replace;
    
    my $new_length = $self->{length} - $remove_length + $replace_length;
    $self->_maybe_extend($new_length);
    
    my $move_length = $self->{length} - $offset - $remove_length;
    Array->memmove_object($self->{values}, $offset + $replace_length, $self->{values}, $offset + $remove_length, $move_length);
    
    # replace with new array
    Array->memcpy_object($self->{values}, $offset, $replace, 0, $replace_length);
    
    $self->{length} = $new_length;
  }
  
  method resize : void ($new_length : int) {
    unless ($new_length >= 0) {
      die "The new length must be greater than or equal to 0";
    }
    
    my $length = $self->{length};
    my $capacity = $self->{capacity};
    
    if ($new_length > $length) {
      $self->_maybe_extend($new_length);
    }
    elsif ($new_length < $length) {
      Array->memset_object($self->{values}, $new_length, undef, $length);
    }
    $self->{length} = $new_length;
  }
  
  method set : void ($index : int, $value : string) {
    my $length = $self->length;
    
    unless ($index >= 0) {
      die "The index must be greater than or equal to 0";
    }
    
    unless ($index < $length) {
      die "The index must be less than the length";
    }
    
    $self->{values}[$index] = $value;
  }
  
  method set_array : void ($array : string[]) {
    unless ($array) {
      die "The array must be defined";
    }
    
    my $cur_length = $self->length;
    
    my $set_length = @$array;
    
    unless ($set_length == $cur_length) {
      die "The length of the array must be same as the length of the current array";
    }
    
    my $values = $self->{values};
    Array->memcpy_object($values, 0, $array, 0, $cur_length);
  }
  
  method shift : string () {
    my $length = $self->{length};
    my $capacity = $self->{capacity};
    
    unless ($length > 0) {
      die "The length of the array must be greater than 0";
    }
    
    my $values = $self->{values};
    
    my $value = $values->[0];
    
    Array->memmove_object($values, 0, $values, 1, $length - 1);
    
    $self->{length}--;
    
    return $value;
  }
  
  method to_array : string[] () {
    my $length = $self->length;
    
    my $array = new string[$length];
    
    my $values = $self->{values};
    
    Array->memcpy_object($array, 0, $values, 0, $length);
    
    return $array;
  }
  
  method unshift : void ($value : string) {
    my $length = $self->{length};
    my $capacity = $self->{capacity};
    
    my $new_length = $length + 1;
    $self->_maybe_extend($new_length);
    
    my $values = $self->{values};
    
    Array->memmove_object($values, 1, $values, 0, $length);
    
    $values->[0] = $value;
    $self->{length}++;
  }
  
  private method _maybe_extend : void ($min_capacity : int) {
    my $capacity = $self->{capacity};
    
    unless ($min_capacity > $capacity) {
      return;
    }
    
    if ($capacity < $min_capacity) {
      $capacity = $min_capacity;
    }
    
    my $new_capacity = $capacity * 2;
    my $new_values = new string[$new_capacity];
    
    my $length = $self->{length};
    my $values = $self->{values};
    Array->memcpy_object($new_values, 0, $values, 0, $length);
    
    $self->{values} = $new_values;
    $self->{capacity} = $new_capacity;
  }
}
