package SPVM::Sort : precompile {
  use SPVM::Comparator::Byte;
  use SPVM::Comparator::Short;
  use SPVM::Comparator::Int;
  use SPVM::Comparator::Long;
  use SPVM::Comparator::Float;
  use SPVM::Comparator::Double;
  use SPVM::Comparator::Object;
  use SPVM::ArrayUtil(new_object_array_proto);
  
  sub sortb : void ($nums : byte[], $offset : int, $length : int, $comparator : SPVM::Comparator::Byte) {
    if ($nums == undef) {
      die "Array must be not undef";
    }
    
    my $nums_length = @$nums;
    
    if ($offset < 0) {
      die "Offset must be more than or equals to 0";
    }
    
    if ($length < 0) {
      die "Length must be more than or equals to 0";
    }
    
    if ($offset + $length > $nums_length) {
      die "Offset + Length must be in the array range";
    }
    
    if ($length == 0) {
      return;
    }
    
    my $b = new byte[$length];
    _sortb_merge_sort($nums, $b, $offset, $offset + $length - 1, $length - 1, $comparator);
  }
  private sub _sortb_merge : void($a : byte[], $b : byte[], $left : int, $mid : int, $right : int, $n : int, $comparator : SPVM::Comparator::Byte) {
    my $i = $left;
    my $j = $mid + 1;
    my $k = 0;
    while ($i <= $mid && $j <= $right) {
      $i = $left;
      $j = $mid + 1;
      $k = 0;
      while ($i <= $mid && $j <= $right) {
        if ($comparator->($a->[$i], $a->[$j]) <= 0) {
          $b->[$k] = $a->[$i];
          $i++;
        } else {
          $b->[$k] = $a->[$j];
          $j++;
        }
        $k++;
      }
      if ($i == $mid + 1) {
        while ($j <= $right) {
          $b->[$k] = $a->[$j]; 
          $j++;
          $k++;
        }
      } else {
        while($i <= $mid) {
          $b->[$k] = $a->[$i];
          $i++;
          $k++;
        }
      }
    }
    for ($i = 0; $i < $k; $i++) {
      $a->[$i + $left] = $b->[$i];
    }
  }
  private sub _sortb_merge_sort : void($a : byte[], $b : byte[], $left : int, $right : int, $n : int, $comparator : SPVM::Comparator::Byte){
    if ($left >= $right) {
      return;
    }

    my $mid = ($left + $right) / 2;

    _sortb_merge_sort($a, $b, $left, $mid, $n, $comparator);
    _sortb_merge_sort($a, $b, $mid + 1, $right, $n, $comparator);
    _sortb_merge($a, $b, $left, $mid, $right, $n, $comparator);
  }
  
  sub sorts : void ($nums : short[], $offset : int, $length : int, $comparator : SPVM::Comparator::Short) {
    if ($nums == undef) {
      die "Array must be not undef";
    }
    
    my $nums_length = @$nums;
    
    if ($offset < 0) {
      die "Offset must be more than or equals to 0";
    }
    
    if ($length < 0) {
      die "Length must be more than or equals to 0";
    }
    
    if ($offset + $length > $nums_length) {
      die "Offset + Length must be in the array range";
    }
    
    if ($length == 0) {
      return;
    }
    
    my $b = new short[$length];
    _sorts_merge_sort($nums, $b, $offset, $offset + $length - 1, $length - 1, $comparator);
  }
  private sub _sorts_merge : void($a : short[], $b : short[], $left : int, $mid : int, $right : int, $n : int, $comparator : SPVM::Comparator::Short) {
    my $i = $left;
    my $j = $mid + 1;
    my $k = 0;
    while ($i <= $mid && $j <= $right) {
      $i = $left;
      $j = $mid + 1;
      $k = 0;
      while ($i <= $mid && $j <= $right) {
        if ($comparator->($a->[$i], $a->[$j]) <= 0) {
          $b->[$k] = $a->[$i];
          $i++;
        } else {
          $b->[$k] = $a->[$j];
          $j++;
        }
        $k++;
      }
      if ($i == $mid + 1) {
        while ($j <= $right) {
          $b->[$k] = $a->[$j]; 
          $j++;
          $k++;
        }
      } else {
        while($i <= $mid) {
          $b->[$k] = $a->[$i];
          $i++;
          $k++;
        }
      }
    }
    for ($i = 0; $i < $k; $i++) {
      $a->[$i + $left] = $b->[$i];
    }
  }
  private sub _sorts_merge_sort : void($a : short[], $b : short[], $left : int, $right : int, $n : int, $comparator : SPVM::Comparator::Short){
    if ($left >= $right) {
      return;
    }

    my $mid = ($left + $right) / 2;

    _sorts_merge_sort($a, $b, $left, $mid, $n, $comparator);
    _sorts_merge_sort($a, $b, $mid + 1, $right, $n, $comparator);
    _sorts_merge($a, $b, $left, $mid, $right, $n, $comparator);
  }
  
  sub sorti : void ($nums : int[], $offset : int, $length : int, $comparator : SPVM::Comparator::Int) {
    if ($nums == undef) {
      die "Array must be not undef";
    }
    
    my $nums_length = @$nums;
    
    if ($offset < 0) {
      die "Offset must be more than or equals to 0";
    }
    
    if ($length < 0) {
      die "Length must be more than or equals to 0";
    }
    
    if ($offset + $length > $nums_length) {
      die "Offset + Length must be in the array range";
    }
    
    if ($length == 0) {
      return;
    }
    
    my $b = new int[$length];
    _sorti_merge_sort($nums, $b, $offset, $offset + $length - 1, $length - 1, $comparator);
  }
  private sub _sorti_merge : void($a : int[], $b : int[], $left : int, $mid : int, $right : int, $n : int, $comparator : SPVM::Comparator::Int) {
    my $i = $left;
    my $j = $mid + 1;
    my $k = 0;
    while ($i <= $mid && $j <= $right) {
      $i = $left;
      $j = $mid + 1;
      $k = 0;
      while ($i <= $mid && $j <= $right) {
        if ($comparator->($a->[$i], $a->[$j]) <= 0) {
          $b->[$k] = $a->[$i];
          $i++;
        } else {
          $b->[$k] = $a->[$j];
          $j++;
        }
        $k++;
      }
      if ($i == $mid + 1) {
        while ($j <= $right) {
          $b->[$k] = $a->[$j]; 
          $j++;
          $k++;
        }
      } else {
        while($i <= $mid) {
          $b->[$k] = $a->[$i];
          $i++;
          $k++;
        }
      }
    }
    for ($i = 0; $i < $k; $i++) {
      $a->[$i + $left] = $b->[$i];
    }
  }
  private sub _sorti_merge_sort : void($a : int[], $b : int[], $left : int, $right : int, $n : int, $comparator : SPVM::Comparator::Int){
    if ($left >= $right) {
      return;
    }

    my $mid = ($left + $right) / 2;

    _sorti_merge_sort($a, $b, $left, $mid, $n, $comparator);
    _sorti_merge_sort($a, $b, $mid + 1, $right, $n, $comparator);
    _sorti_merge($a, $b, $left, $mid, $right, $n, $comparator);
  }
  
  sub sortl : void ($nums : long[], $offset : int, $length : int, $comparator : SPVM::Comparator::Long) {
    if ($nums == undef) {
      die "Array must be not undef";
    }
    
    my $nums_length = @$nums;
    
    if ($offset < 0) {
      die "Offset must be more than or equals to 0";
    }
    
    if ($length < 0) {
      die "Length must be more than or equals to 0";
    }
    
    if ($offset + $length > $nums_length) {
      die "Offset + Length must be in the array range";
    }
    
    if ($length == 0) {
      return;
    }
    
    my $b = new long[$length];
    _sortl_merge_sort($nums, $b, $offset, $offset + $length - 1, $length - 1, $comparator);
  }
  private sub _sortl_merge : void($a : long[], $b : long[], $left : int, $mid : int, $right : int, $n : int, $comparator : SPVM::Comparator::Long) {
    my $i = $left;
    my $j = $mid + 1;
    my $k = 0;
    while ($i <= $mid && $j <= $right) {
      $i = $left;
      $j = $mid + 1;
      $k = 0;
      while ($i <= $mid && $j <= $right) {
        if ($comparator->($a->[$i], $a->[$j]) <= 0) {
          $b->[$k] = $a->[$i];
          $i++;
        } else {
          $b->[$k] = $a->[$j];
          $j++;
        }
        $k++;
      }
      if ($i == $mid + 1) {
        while ($j <= $right) {
          $b->[$k] = $a->[$j]; 
          $j++;
          $k++;
        }
      } else {
        while($i <= $mid) {
          $b->[$k] = $a->[$i];
          $i++;
          $k++;
        }
      }
    }
    for ($i = 0; $i < $k; $i++) {
      $a->[$i + $left] = $b->[$i];
    }
  }
  private sub _sortl_merge_sort : void($a : long[], $b : long[], $left : int, $right : int, $n : int, $comparator : SPVM::Comparator::Long){
    if ($left >= $right) {
      return;
    }

    my $mid = ($left + $right) / 2;

    _sortl_merge_sort($a, $b, $left, $mid, $n, $comparator);
    _sortl_merge_sort($a, $b, $mid + 1, $right, $n, $comparator);
    _sortl_merge($a, $b, $left, $mid, $right, $n, $comparator);
  }
  
  sub sortf : void ($nums : float[], $offset : int, $length : int, $comparator : SPVM::Comparator::Float) {
    if ($nums == undef) {
      die "Array must be not undef";
    }
    
    my $nums_length = @$nums;
    
    if ($offset < 0) {
      die "Offset must be more than or equals to 0";
    }
    
    if ($length < 0) {
      die "Length must be more than or equals to 0";
    }
    
    if ($offset + $length > $nums_length) {
      die "Offset + Length must be in the array range";
    }
    
    if ($length == 0) {
      return;
    }
    
    my $b = new float[$length];
    _sortf_merge_sort($nums, $b, $offset, $offset + $length - 1, $length - 1, $comparator);
  }
  private sub _sortf_merge : void($a : float[], $b : float[], $left : int, $mid : int, $right : int, $n : int, $comparator : SPVM::Comparator::Float) {
    my $i = $left;
    my $j = $mid + 1;
    my $k = 0;
    while ($i <= $mid && $j <= $right) {
      $i = $left;
      $j = $mid + 1;
      $k = 0;
      while ($i <= $mid && $j <= $right) {
        if ($comparator->($a->[$i], $a->[$j]) <= 0) {
          $b->[$k] = $a->[$i];
          $i++;
        } else {
          $b->[$k] = $a->[$j];
          $j++;
        }
        $k++;
      }
      if ($i == $mid + 1) {
        while ($j <= $right) {
          $b->[$k] = $a->[$j]; 
          $j++;
          $k++;
        }
      } else {
        while($i <= $mid) {
          $b->[$k] = $a->[$i];
          $i++;
          $k++;
        }
      }
    }
    for ($i = 0; $i < $k; $i++) {
      $a->[$i + $left] = $b->[$i];
    }
  }
  private sub _sortf_merge_sort : void($a : float[], $b : float[], $left : int, $right : int, $n : int, $comparator : SPVM::Comparator::Float){
    if ($left >= $right) {
      return;
    }

    my $mid = ($left + $right) / 2;

    _sortf_merge_sort($a, $b, $left, $mid, $n, $comparator);
    _sortf_merge_sort($a, $b, $mid + 1, $right, $n, $comparator);
    _sortf_merge($a, $b, $left, $mid, $right, $n, $comparator);
  }
  
  sub sortd : void ($nums : double[], $offset : int, $length : int, $comparator : SPVM::Comparator::Double) {
    if ($nums == undef) {
      die "Array must be not undef";
    }
    
    my $nums_length = @$nums;
    
    if ($offset < 0) {
      die "Offset must be more than or equals to 0";
    }
    
    if ($length < 0) {
      die "Length must be more than or equals to 0";
    }
    
    if ($offset + $length > $nums_length) {
      die "Offset + Length must be in the array range";
    }
    
    if ($length == 0) {
      return;
    }
    
    my $b = new double[$length];
    _sortd_merge_sort($nums, $b, $offset, $offset + $length - 1, $length - 1, $comparator);
  }
  private sub _sortd_merge : void($a : double[], $b : double[], $left : int, $mid : int, $right : int, $n : int, $comparator : SPVM::Comparator::Double) {
    my $i = $left;
    my $j = $mid + 1;
    my $k = 0;
    while ($i <= $mid && $j <= $right) {
      $i = $left;
      $j = $mid + 1;
      $k = 0;
      while ($i <= $mid && $j <= $right) {
        if ($comparator->($a->[$i], $a->[$j]) <= 0) {
          $b->[$k] = $a->[$i];
          $i++;
        } else {
          $b->[$k] = $a->[$j];
          $j++;
        }
        $k++;
      }
      if ($i == $mid + 1) {
        while ($j <= $right) {
          $b->[$k] = $a->[$j]; 
          $j++;
          $k++;
        }
      } else {
        while($i <= $mid) {
          $b->[$k] = $a->[$i];
          $i++;
          $k++;
        }
      }
    }
    for ($i = 0; $i < $k; $i++) {
      $a->[$i + $left] = $b->[$i];
    }
  }
  private sub _sortd_merge_sort : void($a : double[], $b : double[], $left : int, $right : int, $n : int, $comparator : SPVM::Comparator::Double){
    if ($left >= $right) {
      return;
    }

    my $mid = ($left + $right) / 2;

    _sortd_merge_sort($a, $b, $left, $mid, $n, $comparator);
    _sortd_merge_sort($a, $b, $mid + 1, $right, $n, $comparator);
    _sortd_merge($a, $b, $left, $mid, $right, $n, $comparator);
  }
  
  sub sorto : void ($objs : oarray, $offset : int, $length : int, $comparator : SPVM::Comparator::Object) {
    if ($objs == undef) {
      die "Array must be not undef";
    }
    
    my $objs_length = @$objs;
    
    if ($offset < 0) {
      die "Offset must be more than or equals to 0";
    }
    
    if ($length < 0) {
      die "Length must be more than or equals to 0";
    }
    
    if ($offset + $length > $objs_length) {
      die "Offset + Length must be in the array range";
    }
    
    my $b = new_object_array_proto($objs, $length);
    _sorto_merge_sort($objs, $b, $offset, $offset + $length - 1, $length - 1, $comparator);
  }

  private sub _sorto_merge : void($a : oarray, $b : oarray, $left : int, $mid : int, $right : int, $n : int, $comparator : SPVM::Comparator::Object) {
      my $i = $left;
      my $j = $mid + 1;
      my $k = 0;
      while ($i <= $mid && $j <= $right) {
          $i = $left;
          $j = $mid + 1;
          $k = 0;
          while ($i <= $mid && $j <= $right) {
              if ($comparator->($a->[$i], $a->[$j]) <= 0) {
                  $b->[$k] = $a->[$i];
                  $i++;
              } else {
                  $b->[$k] = $a->[$j];
                  $j++;
              }
              $k++;
          }
          if ($i == $mid + 1) {
              while ($j <= $right) {
                  $b->[$k] = $a->[$j]; 
                  $j++;
                  $k++;
              }
          } else {
              while($i <= $mid) {
                  $b->[$k] = $a->[$i];
                  $i++;
                  $k++;
              }
          }
      }
      for ($i = 0; $i < $k; $i++) {
        $a->[$i + $left] = $b->[$i];
      }
  }

  private sub _sorto_merge_sort : void($a : oarray, $b : oarray, $left : int, $right : int, $n : int, $comparator : SPVM::Comparator::Object){
    if ($left >= $right) {
      return;
    }

    my $mid = ($left + $right) / 2;

    _sorto_merge_sort($a, $b, $left, $mid, $n, $comparator);
    _sorto_merge_sort($a, $b, $mid + 1, $right, $n, $comparator);
    _sorto_merge($a, $b, $left, $mid, $right, $n, $comparator);
  }
}
