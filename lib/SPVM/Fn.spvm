class Fn : precompile {
  use Cloner;
  use EqualityChecker;
  use Comparator::Byte;
  use Comparator::Short;
  use Comparator::Int;
  use Comparator::Long;
  use Comparator::Float;
  use Comparator::Double;
  use Comparator::String;
  use Comparator::Object;
  use Stringer;
  use Cloner;
  use EqualityChecker;
  use StringBuffer;
  use StringList;
  use Unicode;
  use Regex;
  
  native static method DBL_MAX : double ();
  native static method DBL_MIN : double ();
  native static method FLT_MAX : float ();
  native static method FLT_MIN : float();
  static method INT16_MAX : short () { return 32767; }
  static method INT16_MIN : short () { return -32768; }
  static method INT32_MAX : int () { return 2147483647; }
  static method INT32_MIN : int () { return -2147483648; }
  static method INT64_MAX : long () { return 9223372036854775807L; }
  static method INT64_MIN : long () { return -9223372036854775808L; }
  static method INT8_MAX : byte () { return 127; }
  static method INT8_MIN : byte () { return -128; }
  native static method RAND_MAX : int ();
  static method UINT16_MAX : short () { return (short)0xFFFF; }
  static method UINT32_MAX : int () { return 0xFFFFFFFF; }
  static method UINT64_MAX : long () { return 0xFFFFFFFFFFFFFFFFL; }
  static method UINT8_MAX : byte () { return (byte)0xFF; }

  static method abs : int ($x : int) {
    
    my $ret = 0;
    if ($x > 0) {
      $ret = $x;
    }
    else {
      $ret = -$x;
    }
    return $ret;
  }

  static method chompr : string ($string : string) {
    unless ($string) {
      return undef;
    }

    my $new_string : string;
    my $length = length $string;
    if ($length == 0) {
      $new_string = &copy_string($string);
    }
    else {
      if ($string->[$length - 1] == '\n') {
        $new_string = (string)&copy_array_range_byte((byte[])$string, 0, $length - 1);
      }
      else {
        $new_string = &copy_string($string);
      }
    }

    return $new_string;
  }

  static method copy_array_byte : byte[] ($nums : byte[]) {
    if ($nums == undef) {
      return undef;
    }
    
    my $length = @$nums;

    my $new_nums = new byte[$length];

    for (my $i = 0; $i < $length; $i++) {
      $new_nums->[$i] = $nums->[$i];
    }

    return $new_nums;
  }

  static method copy_array_double : double[] ($nums : double[]) {
    if ($nums == undef) {
      return undef;
    }
    
    my $length = @$nums;

    my $new_nums = new double[$length];

    for (my $i = 0; $i < $length; $i++) {
      $new_nums->[$i] = $nums->[$i];
    }

    return $new_nums;
  }

  static method copy_array_float : float[] ($nums : float[]) {
    if ($nums == undef) {
      return undef;
    }
    
    my $length = @$nums;

    my $new_nums = new float[$length];

    for (my $i = 0; $i < $length; $i++) {
      $new_nums->[$i] = $nums->[$i];
    }

    return $new_nums;
  }

  static method copy_array_int : int[] ($nums : int[]) {
    if ($nums == undef) {
      return undef;
    }
    
    my $length = @$nums;

    my $new_nums = new int[$length];

    for (my $i = 0; $i < $length; $i++) {
      $new_nums->[$i] = $nums->[$i];
    }

    return $new_nums;
  }

  static method copy_array_long : long[] ($nums : long[]) {
    if ($nums == undef) {
      return undef;
    }
    
    my $length = @$nums;

    my $new_nums = new long[$length];

    for (my $i = 0; $i < $length; $i++) {
      $new_nums->[$i] = $nums->[$i];
    }

    return $new_nums;
  }

  static method copy_array_object : object[] ($objects : object[], $cloner : Cloner) {
    if ($objects == undef) {
      return undef;
    }
    
    my $length = @$objects;

    my $new_objects = new object[$length];

    for (my $i = 0; $i < $length; $i++) {
      $new_objects->[$i] = $cloner->($objects->[$i]);
    }

    return $new_objects;
  }

  static method copy_array_range_byte : byte[] ($nums : byte[], $offset : int, $length : int) {

    if ($nums == undef) {
      die "The argument array must be defined";
    }

    my $array_length = @$nums;

    if ($offset < 0 || $offset > $array_length - 1) {
      die "Offset must be in the array range";
    }

    if ($length < 0) {
      die "Length must be more than or equals to 0";
    }

    if ($offset + $length > $array_length) {
      die "Offset + length must be in the array range";
    }

    my $range = new byte[$length];

    my $pos = 0;
    for (my $i = $offset; $i < $offset + $length; $i++) {
      $range->[$pos] = $nums->[$i];
      $pos++;
    }

    return $range;
  }

  static method copy_array_range_double : double[] ($nums : double[], $offset : int, $length : int) {

    if ($nums == undef) {
      die "The argument array must be defined";
    }

    my $array_length = @$nums;

    if ($offset < 0 || $offset > $array_length - 1) {
      die "Offset must be in the array range";
    }

    if ($length < 0) {
      die "Length must be more than or equals to 0";
    }

    if ($offset + $length > $array_length) {
      die "Offset + length must not be in the array range";
    }

    my $range = new double[$length];

    my $pos = 0;
    for (my $i = $offset; $i < $offset + $length; $i++) {
      $range->[$pos] = $nums->[$i];
      $pos++;
    }

    return $range;
  }

  static method copy_array_range_float : float[] ($nums : float[], $offset : int, $length : int) {

    if ($nums == undef) {
      die "The argument array must be defined";
    }

    my $array_length = @$nums;

    if ($offset < 0 || $offset > $array_length - 1) {
      die "Offset must be in the array range";
    }

    if ($length < 0) {
      die "Length must be more than or equals to 0";
    }

    if ($offset + $length > $array_length) {
      die "Offset + length must not be in the array range";
    }

    my $range = new float[$length];

    my $pos = 0;
    for (my $i = $offset; $i < $offset + $length; $i++) {
      $range->[$pos] = $nums->[$i];
      $pos++;
    }

    return $range;
  }

  static method copy_array_range_int : int[] ($nums : int[], $offset : int, $length : int) {

    if ($nums == undef) {
      die "The argument array must be defined";
    }

    my $array_length = @$nums;

    if ($offset < 0 || $offset > $array_length - 1) {
      die "Offset must be in the array range";
    }

    if ($length < 0) {
      die "Length must be more than or equals to 0";
    }

    if ($offset + $length > $array_length) {
      die "Offset + length must be in the array range";
    }

    my $range = new int[$length];

    my $pos = 0;
    for (my $i = $offset; $i < $offset + $length; $i++) {
      $range->[$pos] = $nums->[$i];
      $pos++;
    }

    return $range;
  }

  static method copy_array_range_long : long[] ($nums : long[], $offset : int, $length : int) {

    if ($nums == undef) {
      die "The argument array must be defined";
    }

    my $array_length = @$nums;

    if ($offset < 0 || $offset > $array_length - 1) {
      die "Offset must be in the array range";
    }

    if ($length < 0) {
      die "Length must be more than or equals to 0";
    }

    if ($offset + $length > $array_length) {
      die "Offset + length must not be in the array range";
    }

    my $range = new long[$length];

    my $pos = 0;
    for (my $i = $offset; $i < $offset + $length; $i++) {
      $range->[$pos] = $nums->[$i];
      $pos++;
    }

    return $range;
  }

  static method copy_array_range_object : oarray ($objects : oarray, $offset : int, $length : int) {

    if ($objects == undef) {
      die "The argument array must be defined";
    }

    my $array_length = @$objects;

    if ($offset < 0 || $offset > $array_length - 1) {
      die "Offset must be in the array range";
    }

    if ($length < 0) {
      die "Length must be more than or equals to 0";
    }

    if ($offset + $length > $array_length) {
      die "Offset + length must not be in the array range";
    }

    my $range = Fn->new_array_proto($objects, $length);

    my $pos = 0;
    for (my $i = $offset; $i < $offset + $length; $i++) {
      $range->[$pos] = $objects->[$i];
      $pos++;
    }

    return $range;
  }

  static method copy_array_range_short : short[] ($nums : short[], $offset : int, $length : int) {

    if ($nums == undef) {
      die "The argument array must be defined";
    }

    my $array_length = @$nums;

    if ($offset < 0 || $offset > $array_length - 1) {
      die "Offset must be in the array range";
    }

    if ($length < 0) {
      die "Length must be more than or equals to 0";
    }

    if ($offset + $length > $array_length) {
      die "Offset + length must be in the array range";
    }

    my $range = new short[$length];

    my $pos = 0;
    for (my $i = $offset; $i < $offset + $length; $i++) {
      $range->[$pos] = $nums->[$i];
      $pos++;
    }

    return $range;
  }


  static method copy_array_range_string : string[] ($strings : string[], $offset : int, $length : int) {

    if ($strings == undef) {
      die "The argument array must be defined";
    }

    my $array_length = @$strings;

    if ($offset < 0 || $offset > $array_length - 1) {
      die "Offset must be in the array range";
    }

    if ($length < 0) {
      die "Length must be more than or equals to 0";
    }

    if ($offset + $length > $array_length) {
      die "Offset + length must not be in the array range";
    }

    my $range = new string[$length];

    my $pos = 0;
    for (my $i = $offset; $i < $offset + $length; $i++) {
      $range->[$pos] = $strings->[$i];
      $pos++;
    }

    return $range;
  }

  static method copy_array_short : short[] ($nums : short[]) {
    if ($nums == undef) {
      return undef;
    }
    
    my $length = @$nums;

    my $new_nums = new short[$length];

    for (my $i = 0; $i < $length; $i++) {
      $new_nums->[$i] = $nums->[$i];
    }

    return $new_nums;
  }

  static method copy_array_string : string[] ($strings : string[]) {
    if ($strings == undef) {
      return undef;
    }
    
    my $length = @$strings;

    my $new_strings = new string[$length];

    for (my $i = 0; $i < $length; $i++) {
      $new_strings->[$i] = Fn->copy_string($strings->[$i]);
    }

    return $new_strings;
  }
  
  static method copy_string : string ($string : string) {
    unless ($string) {
      return undef;
    }
    
    my $string_length = length $string;
    
    my $bytes = (byte[])$string;

    return (string)$bytes;
  }

  native static method crand : int ();

  static method dump_array_byte : string ($nums : byte[]) {
    
    if ($nums == undef) {
      return undef;
    }
    
    my $dump = "[\n";

    for (my $i = 0; $i < @$nums; $i++) {
      my $string = (string)$nums->[$i];
      $dump .= "  $string";
      if ($i != @$nums - 1) {
        $dump .= ",\n";
      }
      else {
        $dump .= "\n";
      }
    }
    
    $dump .= "]";

    return $dump;
  }

  static method dump_array_double : string ($nums : double[]) {
    
    if ($nums == undef) {
      return undef;
    }
    
    my $dump = "[\n";

    for (my $i = 0; $i < @$nums; $i++) {
      my $string = (string)$nums->[$i];
      $dump .= "  $string";
      if ($i != @$nums - 1) {
        $dump .= ",\n";
      }
      else {
        $dump .= "\n";
      }
    }
    
    $dump .= "]";

    return $dump;
  }

  static method dump_array_float : string ($nums : float[]) {
    
    if ($nums == undef) {
      return undef;
    }
    
    my $dump = "[\n";

    for (my $i = 0; $i < @$nums; $i++) {
      my $string = (string)$nums->[$i];
      $dump .= "  $string";
      if ($i != @$nums - 1) {
        $dump .= ",\n";
      }
      else {
        $dump .= "\n";
      }
    }
    
    $dump .= "]";

    return $dump;
  }

  static method dump_array_int : string ($nums : int[]) {
    
    if ($nums == undef) {
      return undef;
    }
    
    my $dump = "[\n";

    for (my $i = 0; $i < @$nums; $i++) {
      my $string = (string)$nums->[$i];
      $dump .= "  $string";
      if ($i != @$nums - 1) {
        $dump .= ",\n";
      }
      else {
        $dump .= "\n";
      }
    }
    
    $dump .= "]";

    return $dump;
  }

  static method dump_array_long : string ($nums : long[]) {
    
    if ($nums == undef) {
      return undef;
    }
    
    my $dump = "[\n";

    for (my $i = 0; $i < @$nums; $i++) {
      my $string = (string)$nums->[$i];
      $dump .= "  $string";
      if ($i != @$nums - 1) {
        $dump .= ",\n";
      }
      else {
        $dump .= "\n";
      }
    }
    
    $dump .= "]";

    return $dump;
  }

  static method dump_array_object : string ($objects : oarray, $stringer : Stringer) {
    
    if ($objects == undef) {
      return undef;
    }
    
    my $dump = "[\n";

    for (my $i = 0; $i < @$objects; $i++) {
      my $string = $stringer->($objects->[$i]);
      $dump .= "  $string";
      if ($i != @$objects - 1) {
        $dump .= ",\n";
      }
      else {
        $dump .= "\n";
      }
    }
    
    $dump .= "]";

    return $dump;
  }

  static method dump_array_short : string ($nums : short[]) {
    
    if ($nums == undef) {
      return undef;
    }
    
    my $dump = "[\n";

    for (my $i = 0; $i < @$nums; $i++) {
      my $string = (string)$nums->[$i];
      $dump .= "  $string";
      if ($i != @$nums - 1) {
        $dump .= ",\n";
      }
      else {
        $dump .= "\n";
      }
    }
    
    $dump .= "]";

    return $dump;
  }

  static method dump_array_string : string ($strings : string[]) {
    
    if ($strings == undef) {
      return undef;
    }
    
    my $dump = "[\n";

    for (my $i = 0; $i < @$strings; $i++) {
      my $string = $strings->[$i];
      $dump .= "  $string";
      if ($i != @$strings - 1) {
        $dump .= ",\n";
      }
      else {
        $dump .= "\n";
      }
    }
    
    $dump .= "]";

    return $dump;
  }

  static method dump_array_unsigned_byte : string ($nums : byte[]) {
    
    if ($nums == undef) {
      return undef;
    }
    
    my $dump = "[\n";

    for (my $i = 0; $i < @$nums; $i++) {
      my $string = Fn->sprintf("%u", (int)$nums->[$i] & 0xFF);
      $dump .= "  $string";
      if ($i != @$nums - 1) {
        $dump .= ",\n";
      }
      else {
        $dump .= "\n";
      }
    }
    
    $dump .= "]";

    return $dump;
  }

  static method dump_array_unsigned_int : string ($nums : int[]) {
    
    if ($nums == undef) {
      return undef;
    }
    
    my $dump = "[\n";

    for (my $i = 0; $i < @$nums; $i++) {
      my $string = Fn->sprintf("%u", $nums->[$i]);
      $dump .= "  $string";
      if ($i != @$nums - 1) {
        $dump .= ",\n";
      }
      else {
        $dump .= "\n";
      }
    }
    
    $dump .= "]";

    return $dump;
  }

  static method dump_array_unsigned_long : string ($nums : long[]) {
    
    if ($nums == undef) {
      return undef;
    }
    
    my $dump = "[\n";

    for (my $i = 0; $i < @$nums; $i++) {
      my $string = Fn->sprintf("%lu", $nums->[$i]);
      $dump .= "  $string";
      if ($i != @$nums - 1) {
        $dump .= ",\n";
      }
      else {
        $dump .= "\n";
      }
    }
    
    $dump .= "]";

    return $dump;
  }

  static method dump_array_unsigned_short : string ($nums : short[]) {
    
    if ($nums == undef) {
      return undef;
    }
    
    my $dump = "[\n";

    for (my $i = 0; $i < @$nums; $i++) {
      my $string = Fn->sprintf("%u", (int)$nums->[$i] & 0xFFFF);
      $dump .= "  $string";
      if ($i != @$nums - 1) {
        $dump .= ",\n";
      }
      else {
        $dump .= "\n";
      }
    }
    
    $dump .= "]";

    return $dump;
  }

  static method equals_array_byte : int ($nums1 : byte[], $nums2 : byte[]) {
    
    if ($nums1 == undef && $nums2 == undef) {
      return 1;
    }
    elsif ($nums1 != undef && $nums2 == undef) {
      return 0;
    }
    elsif ($nums1 == undef && $nums2 != undef) {
      return 0;
    }
    
    my $is_equals = 1;
    if (@$nums1 == @$nums2) {
      for (my $i = 0; $i < @$nums1; $i++) {
        if ($nums1->[$i] != $nums2->[$i]) {
          $is_equals = 0;
          last;
        }
      }
    }
    else {
      $is_equals = 0;
    }

    return $is_equals;
  }

  static method equals_array_double : int ($nums1 : double[], $nums2 : double[]) {
    if ($nums1 == undef && $nums2 == undef) {
      return 1;
    }
    elsif ($nums1 != undef && $nums2 == undef) {
      return 0;
    }
    elsif ($nums1 == undef && $nums2 != undef) {
      return 0;
    }
    
    my $is_equals = 1;
    if (@$nums1 == @$nums2) {
      for (my $i = 0; $i < @$nums1; $i++) {
        if ($nums1->[$i] != $nums2->[$i]) {
          $is_equals = 0;
          last;
        }
      }
    }
    else {
      $is_equals = 0;
    }

    return $is_equals;
  }

  static method equals_array_float : int ($nums1 : float[], $nums2 : float[]) {
    if ($nums1 == undef && $nums2 == undef) {
      return 1;
    }
    elsif ($nums1 != undef && $nums2 == undef) {
      return 0;
    }
    elsif ($nums1 == undef && $nums2 != undef) {
      return 0;
    }
    
    my $is_equals = 1;
    if (@$nums1 == @$nums2) {
      for (my $i = 0; $i < @$nums1; $i++) {
        if ($nums1->[$i] != $nums2->[$i]) {
          $is_equals = 0;
          last;
        }
      }
    }
    else {
      $is_equals = 0;
    }

    return $is_equals;
  }

  static method equals_array_int : int ($nums1 : int[], $nums2 : int[]) {
    if ($nums1 == undef && $nums2 == undef) {
      return 1;
    }
    elsif ($nums1 != undef && $nums2 == undef) {
      return 0;
    }
    elsif ($nums1 == undef && $nums2 != undef) {
      return 0;
    }
    
    my $is_equals = 1;
    if (@$nums1 == @$nums2) {
      for (my $i = 0; $i < @$nums1; $i++) {
        if ($nums1->[$i] != $nums2->[$i]) {
          $is_equals = 0;
          last;
        }
      }
    }
    else {
      $is_equals = 0;
    }

    return $is_equals;
  }
  static method equals_array_long : int ($nums1 : long[], $nums2 : long[]) {
    if ($nums1 == undef && $nums2 == undef) {
      return 1;
    }
    elsif ($nums1 != undef && $nums2 == undef) {
      return 0;
    }
    elsif ($nums1 == undef && $nums2 != undef) {
      return 0;
    }
    
    my $is_equals = 1;
    if (@$nums1 == @$nums2) {
      for (my $i = 0; $i < @$nums1; $i++) {
        if ($nums1->[$i] != $nums2->[$i]) {
          $is_equals = 0;
          last;
        }
      }
    }
    else {
      $is_equals = 0;
    }

    return $is_equals;
  }

  static method equals_array_object : int ($objects1 : oarray, $objects2 : oarray, $equality_checker : EqualityChecker) {
    if ($objects1 == undef && $objects2 == undef) {
      return 1;
    }
    elsif ($objects1 != undef && $objects2 == undef) {
      return 0;
    }
    elsif ($objects1 == undef && $objects2 != undef) {
      return 0;
    }
    
    my $is_equals = 1;
    if (@$objects1 == @$objects2) {
      for (my $i = 0; $i < @$objects1; $i++) {
        if (!$equality_checker->($objects1->[$i], $objects2->[$i])) {
          $is_equals = 0;
          last;
        }
      }
    }
    else {
      $is_equals = 0;
    }

    return $is_equals;
  }

  static method equals_array_short : int ($nums1 : short[], $nums2 : short[]) {
    if ($nums1 == undef && $nums2 == undef) {
      return 1;
    }
    elsif ($nums1 != undef && $nums2 == undef) {
      return 0;
    }
    elsif ($nums1 == undef && $nums2 != undef) {
      return 0;
    }
    
    my $is_equals = 1;
    if (@$nums1 == @$nums2) {
      for (my $i = 0; $i < @$nums1; $i++) {
        if ($nums1->[$i] != $nums2->[$i]) {
          $is_equals = 0;
          last;
        }
      }
    }
    else {
      $is_equals = 0;
    }

    return $is_equals;
  }

  static method equals_array_string : int ($strings1 : string[], $strings2 : string[]) {
    if ($strings1 == undef && $strings2 == undef) {
      return 1;
    }
    elsif ($strings1 != undef && $strings2 == undef) {
      return 0;
    }
    elsif ($strings1 == undef && $strings2 != undef) {
      return 0;
    }
    
    my $is_equals = 1;
    if (@$strings1 == @$strings2) {
      for (my $i = 0; $i < @$strings1; $i++) {
        if ($strings1->[$i] ne $strings2->[$i]) {
          $is_equals = 0;
          last;
        }
      }
    }
    else {
      $is_equals = 0;
    }

    return $is_equals;
  }

  static method hex : int ($hex_string : string) {
    
    unless ($hex_string) {
      die "the hex string must be defined";
    }
    
    my $re = Regex->new("^([0-9a-fA-F]{1,8})$");
    
    my $hex_value = 0;
    my $digit = 0;
    my $value = 0;
    if ($re->match($hex_string, 0)) {
      my $length = length $hex_string;
      for (my $i = $length - 1; $i >= 0; $i--) {
        my $ascii_code = $hex_string->[$i];
        
        my $digit_value = 0;
        if ($ascii_code >= '0' && $ascii_code <= '9') {
          $digit_value = $ascii_code - 48;
        }
        elsif ($ascii_code >= 'a' && $ascii_code <= 'f') {
          $digit_value = $ascii_code - 87;
        }
        elsif ($ascii_code >= 'A' && $ascii_code <= 'F') {
          $digit_value = $ascii_code - 55;
        }
        $value += $digit_value * Fn->powi(16, $digit);
        
        $digit += 1;
      }
    }
    else {
      die "the hex string must be a valid expression";
    }
    
    return $value;
  }

  static method index : int ($string : string, $method_string : string, $position : int) {
    my $stringCount = length $string;
    my $method_stringCount = length $method_string;

    if ($position >= $stringCount) {
      my $ret : int;
      if ($method_stringCount == 0) {
        $ret = $stringCount;
      }
      else {
        $ret = -1;
      }
      return $ret;
    }
    if ($position < 0) {
      $position = 0;
    }
    if ($method_stringCount == 0) {
      return $position;
    }

    my $first : byte  = $method_string->[0];
    my $max : int = ($stringCount - $method_stringCount);

    for (my $i = $position; $i <= $max; $i++) {
      if ($string->[$i] != $first) {
        while (++$i <= $max && $string->[$i] != $first) {}
      }

      if ($i <= $max) {
        my $j = $i + 1;
        my $end = $j + $method_stringCount - 1;
        for (my $k = 01; $j < $end && $string->[$j] == $method_string->[$k]; ($j++, $k++)) {}

        if ($j == $end) {
          return $i;
        }
      }
    }
    return -1;
  }

  # The argument type of following charcter checking functions are int, not byte. This is intentinal.
  # ASCII code is represented by byte type.
  # On the other hand, Unicode Code Point can be represented by int tyep.
  # Unicode Code Point is upper compatibility of ASCII code.
  # So the following character check functions receive int type argument.
  static method is_alnum : int ($code_point : int) {

    if (($code_point >= 'A' && $code_point <= 'Z') || ($code_point >= 'a' && $code_point <= 'z') || ($code_point >= '0' && $code_point <= '9')) {
      return 1;
    }
    else {
      return 0;
    }
  }

  static method is_alpha : int ($code_point : int) {

    if (($code_point >= 'A' && $code_point <= 'Z') || ($code_point >= 'a' && $code_point <= 'z')) {
      return 1;
    }
    else {
      return 0;
    }
  }

  static method is_blank : int ($code_point : int) {

    if ($code_point >= ' ' ||  $code_point <= '\t') {
      return 1;
    }
    else {
      return 0;
    }
  }

  static method is_cntrl : int ($code_point : int) {

    if (($code_point >= 0x00 && $code_point <= 0x1f) || $code_point == 0x7f) {
      return 1;
    }
    else {
      return 0;
    }
  }

  static method is_digit : int ($code_point : int) {

    if ($code_point >= '0' && $code_point <= '9') {
      return 1;
    }
    else {
      return 0;
    }
  }

  static method is_graph : int ($code_point : int) {

    if ($code_point >= 0x21 && $code_point <= 0x7e) {
      return 1;
    }
    else {
      return 0;
    }
  }

  static method is_lower : int ($code_point : int) {

    if ($code_point >= 'a' && $code_point <= 'z') {
      return 1;
    }
    else {
      return 0;
    }
  }

  # This is same as Perl \s
  static method is_perl_space : int ($code_point : int) {
    my $ispspace = 0;
    switch ($code_point) {
      case ' ':
      case '\r':
      case '\n':
      case '\t':
      case '\f':
      {
        $ispspace = 1;
        break;
      }
    }
    return $ispspace;
  }

  static method is_perl_word : int ($code_point : int) {
    my $ispword = 0;

    if ($code_point >= 'a' && $code_point <= 'z') {
      $ispword = 1;
    }
    elsif ($code_point >= 'A' && $code_point <= 'Z') {
      $ispword = 1;
    }
    elsif ($code_point == '_') {
      $ispword = 1;
    }
    elsif ($code_point >= '0' && $code_point <= '9') {
      $ispword = 1;
    }
    return $ispword;
  }

  static method is_print : int ($code_point : int) {

    if ($code_point >= 0x20 && $code_point <= 0x7e) {
      return 1;
    }
    else {
      return 0;
    }
  }

  static method is_punct : int ($code_point : int) {

    if (($code_point >= 0x21 && $code_point <= 0x2f) || ($code_point >= 0x3a && $code_point <= 0x40) || ($code_point >= 0x5b && $code_point <= 0x60) || ($code_point >= 0x7b && $code_point <= 0x7e)) {
      return 1;
    }
    else {
      return 0;
    }
  }

  static method is_space : int ($code_point : int) {

    if (($code_point >= 0x09 && $code_point <= 0x0d) || $code_point == 0x20) {
      return 1;
    }
    else {
      return 0;
    }
  }

  static method is_upper : int ($code_point : int) {

    if ($code_point >= 'A' && $code_point <= 'Z') {
      return 1;
    }
    else {
      return 0;
    }
  }

  static method is_xdigit : int ($code_point : int) {

    if (($code_point >= 'A' && $code_point <= 'F') || ($code_point >= 'a' && $code_point <= 'f') || ($code_point >= '0' && $code_point <= '9')) {
      return 1;
    }
    else {
      return 0;
    }
  }

  static method join : string ($sep : string, $strings : string[]) {
    my $join = "";

    for (my $i = 0; $i < @$strings; $i++) {
      my $string = $strings->[$i];
      $join .= $string;
      if ($i != @$strings - 1) {
        $join .= $sep;
      }
    }

    return $join;
  }

  static method labs : long ($x : long) {
    
    my $ret = 0L;
    if ($x > 0) {
      $ret = $x;
    }
    else {
      $ret = -$x;
    }
    return $ret;
  }

  static method lc : string ($string : string) {

    unless ($string) { die "String must be defined"; }

    my $length = length $string;
    my $new_string = new byte [$length];
    for (my $i = 0; $i < $length; $i++) {
      my $char = $string->[$i];
      if ($char >= 'A' && $char <= 'Z') {
        $new_string->[$i] = (byte)($string->[$i] + 32);
      }
      else {
        $new_string->[$i] = $string->[$i];
      }
    }
    return (string)$new_string;
  }

  static method lcfirst : string ($string : string) {

    unless ($string) { die "String must be defined"; }

    my $length = length $string;
    my $new_string = new byte [$length];
    if ($length > 0) {
      my $char = $string->[0];
      if ($char >= 'A' && $char <= 'Z') {
        $new_string->[0] = (byte)($char + 32);
      }
      else {
        $new_string->[0] = $char;
      }
    }
    for (my $i = 1; $i < $length; ++$i) {
      $new_string->[$i] = $string->[$i];
    }
    return (string)$new_string;
  }

  native static method memcpy_byte : void ($dest : byte[], $dest_offset : int, $source : byte[], $source_offset : int, $length : int);
  native static method memcpy_double : void ($dest : double[], $dest_offset : int, $source : double[], $source_offset : int, $length : int);
  native static method memcpy_float : void ($dest : float[], $dest_offset : int, $source : float[], $source_offset : int, $length : int);
  native static method memcpy_int : void ($dest : int[], $dest_offset : int, $source : int[], $source_offset : int, $length : int);
  native static method memcpy_long : void ($dest : long[], $dest_offset : int, $source : long[], $source_offset : int, $length : int);
  native static method memcpy_short : void ($dest : short[], $dest_offset : int, $source : short[], $source_offset : int, $length : int);

  native static method memmove_byte : void ($dest : byte[], $dest_offset : int, $source : byte[], $source_offset : int, $length : int);
  native static method memmove_double : void ($dest : double[], $dest_offset : int, $source : double[], $source_offset : int, $length : int);
  native static method memmove_float : void ($dest : float[], $dest_offset : int, $source : float[], $source_offset : int, $length : int);
  native static method memmove_int : void ($dest : int[], $dest_offset : int, $source : int[], $source_offset : int, $length : int);
  native static method memmove_long : void ($dest : long[], $dest_offset : int, $source : long[], $source_offset : int, $length : int);
  native static method memmove_short : void ($dest : short[], $dest_offset : int, $source : short[], $source_offset : int, $length : int);

  native static method new_array_proto : oarray ($proto_array : oarray, $length : int);

  native static method new_string_len : string ($length : int);

  static method powi : int ($x : int, $y : int) {
    my $p = 1;
    
    for (my $i = 0; $i < $y; $i++) {
      $p = $p * $x;
    }
    
    return $p;
  }

  static method powl : long ($x : long, $y : long) {
    my $p = 1L;
    
    for (my $i = 0; $i < $y; $i++) {
      $p = $p * $x;
    }
    
    return $p;
  }

  static method rand : double () {
    
    # 0 <= random_number < 1
    my $random_number = (double)Fn->crand() / ((double)Fn->RAND_MAX() + 1);
    
    return $random_number;
  }

  static method rindex : int ($string : string, $method_string : string, $offset : int) {
    my $string_len = length $string;
    my $method_string_len = length $method_string;
    if ($offset > $string_len - $method_string_len) {
      $offset = $string_len - $method_string_len;
    }
    for (my $i = $offset; $i >= 0; --$i) {
      my $match = 1;
      for (my $j = 0; $j < $method_string_len; ++$j) {
        if ($string->[$i + $j] != $method_string->[$j]) {
          $match = 0;
          last;
        }
      }
      if ($match) {
        return $i;
      }
    }
    return -1;
  }

  static method sort_byte : void ($nums : byte[], $offset : int, $length : int, $comparator : Comparator::Byte) {
    if ($nums == undef) {
      die "Array must be not undef";
    }
    
    my $nums_length = @$nums;
    
    if ($offset < 0) {
      die "Offset must be more than or equals to 0";
    }
    
    if ($length < 0) {
      die "Length must be more than or equals to 0";
    }
    
    if ($offset + $length > $nums_length) {
      die "Offset + Length must be in the array range";
    }
    
    if ($length == 0) {
      return;
    }
    
    my $b = new byte[$length];
    Fn->_sort_byte_merge_sort($nums, $b, $offset, $offset + $length - 1, $length - 1, $comparator);
  }

  static method sort_double : void ($nums : double[], $offset : int, $length : int, $comparator : Comparator::Double) {
    if ($nums == undef) {
      die "Array must be not undef";
    }
    
    my $nums_length = @$nums;
    
    if ($offset < 0) {
      die "Offset must be more than or equals to 0";
    }
    
    if ($length < 0) {
      die "Length must be more than or equals to 0";
    }
    
    if ($offset + $length > $nums_length) {
      die "Offset + Length must be in the array range";
    }
    
    if ($length == 0) {
      return;
    }
    
    my $b = new double[$length];
    Fn->_sort_double_merge_sort($nums, $b, $offset, $offset + $length - 1, $length - 1, $comparator);
  }

  static method sort_float : void ($nums : float[], $offset : int, $length : int, $comparator : Comparator::Float) {
    if ($nums == undef) {
      die "Array must be not undef";
    }
    
    my $nums_length = @$nums;
    
    if ($offset < 0) {
      die "Offset must be more than or equals to 0";
    }
    
    if ($length < 0) {
      die "Length must be more than or equals to 0";
    }
    
    if ($offset + $length > $nums_length) {
      die "Offset + Length must be in the array range";
    }
    
    if ($length == 0) {
      return;
    }
    
    my $b = new float[$length];
    Fn->_sort_float_merge_sort($nums, $b, $offset, $offset + $length - 1, $length - 1, $comparator);
  }
  
  static method sort_int : void ($nums : int[], $offset : int, $length : int, $comparator : Comparator::Int) {
    if ($nums == undef) {
      die "Array must be not undef";
    }
    
    my $nums_length = @$nums;
    
    if ($offset < 0) {
      die "Offset must be more than or equals to 0";
    }
    
    if ($length < 0) {
      die "Length must be more than or equals to 0";
    }
    
    if ($offset + $length > $nums_length) {
      die "Offset + Length must be in the array range";
    }
    
    if ($length == 0) {
      return;
    }
    
    my $b = new int[$length];
    Fn->_sort_int_merge_sort($nums, $b, $offset, $offset + $length - 1, $length - 1, $comparator);
  }
  
  static method sort_long : void ($nums : long[], $offset : int, $length : int, $comparator : Comparator::Long) {
    if ($nums == undef) {
      die "Array must be not undef";
    }
    
    my $nums_length = @$nums;
    
    if ($offset < 0) {
      die "Offset must be more than or equals to 0";
    }
    
    if ($length < 0) {
      die "Length must be more than or equals to 0";
    }
    
    if ($offset + $length > $nums_length) {
      die "Offset + Length must be in the array range";
    }
    
    if ($length == 0) {
      return;
    }
    
    my $b = new long[$length];
    Fn->_sort_long_merge_sort($nums, $b, $offset, $offset + $length - 1, $length - 1, $comparator);
  }
  
  static method sort_object : void ($objects : oarray, $offset : int, $length : int, $comparator : Comparator::Object) {
    if ($objects == undef) {
      die "Array must be not undef";
    }
    
    my $objects_length = @$objects;
    
    if ($offset < 0) {
      die "Offset must be more than or equals to 0";
    }
    
    if ($length < 0) {
      die "Length must be more than or equals to 0";
    }
    
    if ($offset + $length > $objects_length) {
      die "Offset + Length must be in the array range";
    }
    
    my $b = Fn->new_array_proto($objects, $length);
    
    Fn->_sort_object_merge_sort($objects, $b, $offset, $offset + $length - 1, $length - 1, $comparator);
  }

  static method sort_short : void ($nums : short[], $offset : int, $length : int, $comparator : Comparator::Short) {
    if ($nums == undef) {
      die "Array must be not undef";
    }
    
    my $nums_length = @$nums;
    
    if ($offset < 0) {
      die "Offset must be more than or equals to 0";
    }
    
    if ($length < 0) {
      die "Length must be more than or equals to 0";
    }
    
    if ($offset + $length > $nums_length) {
      die "Offset + Length must be in the array range";
    }
    
    if ($length == 0) {
      return;
    }
    
    my $b = new short[$length];
    Fn->_sort_short_merge_sort($nums, $b, $offset, $offset + $length - 1, $length - 1, $comparator);
  }

  static method sort_string : void ($strings : string[], $offset : int, $length : int, $comparator : Comparator::String) {
    if ($strings == undef) {
      die "Array must be not undef";
    }
    
    my $strings_length = @$strings;
    
    if ($offset < 0) {
      die "Offset must be more than or equals to 0";
    }
    
    if ($length < 0) {
      die "Length must be more than or equals to 0";
    }
    
    if ($offset + $length > $strings_length) {
      die "Offset + Length must be in the array range";
    }
    
    my $b = new string[$length];
    Fn->_sort_string_merge_sort($strings, $b, $offset, $offset + $length - 1, $length - 1, $comparator);
  }

  static method split : string[] ($sep : string, $string : string) {
    my $string_length = length $string;
    my $sep_length = length $sep;


    if ($sep_length == 0) {
      die "Separator must not be empty string";
    }

    my $separated_strings_list = StringList->new_len(0);

    my $match_start = 0;
    my $string_base = 0;
    for (my $string_index = 0; $string_index < $string_length; $string_index++) {
      if ($string->[$string_index] == $sep->[0]) {
        $match_start = 1;
      }

      if ($match_start) {
        my $match = 1;
        for (my $sep_index = 0; $sep_index < $sep_length; $sep_index++) {
          if ($string_index + $sep_index > $string_length - 1) {
            $match = 0;
            last;
          }
          else {
            unless ($string->[$string_index + $sep_index] == $sep->[$sep_index]) {
              $match = 0;
              last;
            }
          }
        }
        if ($match) {
          my $separated_string = Fn->substr($string, $string_base, $string_index - $string_base);
          $separated_strings_list->push($separated_string);
          $string_base = $string_index + $sep_length;
          $string_index += $sep_length - 1;
        }
      }
    }
    if ($string_base == $string_length) {
      $separated_strings_list->push("");
    }
    else {
      my $separated_string = Fn->substr($string, $string_base, $string_length - $string_base);
      $separated_strings_list->push($separated_string);
    }

    my $separated_strings = $separated_strings_list->to_array;

    return $separated_strings;
  }

  static method sprintf : string ($format : string, $args : object[]...) {
    my $format_length = length $format;
    my $index = 0;

    my $buffer = StringBuffer->new;
    my $arg_count = 0;
    my $constant_string_length = 0;

    while ($index + $constant_string_length < $format_length) {

      if ($format->[$index + $constant_string_length] != '%') {
        # Read constant string
        ++$constant_string_length;
      }
      elsif ($index + $constant_string_length + 1 < $format_length &&
          $format->[$index + $constant_string_length + 1] == '%') {
        # Read %%
        ++$constant_string_length;

        # Add constant string
        if ($constant_string_length > 0) {
          my $format_part = Fn->substr($format, $index, $constant_string_length);
          
          $buffer->push($format_part);
          $index += $constant_string_length;
          $constant_string_length = 0;
        }

        # Skip second %
        ++$index;
      }
      elsif ($index + $constant_string_length + 1 >= $format_length) {
        die "Invalid conversion in sprintf: end of string";
      }
      else {
        # Add constant string
        if ($constant_string_length > 0) {
          my $format_part = Fn->substr($format, $index, $constant_string_length);
          $buffer->push($format_part);
          $index += $constant_string_length;
          $constant_string_length = 0;
        }

        # Read format string

        # Check the next element of @$args corresponding to the specifier
        unless ($arg_count < @$args) {
          die "Missing argument in sprintf";
        }

        # Read specifier %[flags][width][.precision][length]type

        my $specifier_base_index = $index;
        ++$index; # '%'

        # Read `flags`
        my $pad_char = ' ';
        my $plus_sign = 0;
        my $left_justified = 0;

        while ($index < $format_length) {
          my $flag = (int)($format->[$index]);
          switch($flag) {
            case '0': {
              ++$index;
              $pad_char = '0';
              break;
            }
            case '+': {
              ++$index;
              $plus_sign = 1;
              break;
            }
            case '-': {
              ++$index;
              $left_justified = 1;
              break;
            }
            default: {
              last;
              break;
            }
          }
        }

        # Read `width`
        my $width = 0;
        while ($index < $format_length) {
          my $c = $format->[$index];
          if ($c < '0' || '9' < $c) {
            last;
          }
          $width = $width * 10 + $c - '0';
          ++$index;
        }

        # Skip `precision` because of using native sprintf.
        if ($index < $format_length && $format->[$index] == '.') {
          ++$index;
          while ($index < $format_length) {
            my $c = $format->[$index];
            if ($c < '0' || '9' < $c) {
              last;
            }
            ++$index;
          }
        }

        unless ($index < $format_length) {
          die "Invalid conversion in sprintf: \""
              . Fn->substr($format, $specifier_base_index, $index - $specifier_base_index) . "\"";
        }

        my $specifier_char = $format->[$index];
        if ($specifier_char == 'c') {
          ++$index;
          my $arg = ((Byte)$args->[$arg_count])->value;

          if ($left_justified) {
            $buffer->push_char($arg);
            my $space_count = $width - 1;
            if ($space_count > 0) {
              for (; $space_count > 0; --$space_count) {
                $buffer->push_char($pad_char);
              }
            }
          }
          else {
            my $space_count = $width - 1;
            if ($space_count > 0) {
              for (; $space_count > 0; --$space_count) {
                $buffer->push_char($pad_char);
              }
            }
            $buffer->push_char($arg);
          }
        }
        elsif ($specifier_char == 's') {
          ++$index;
          my $arg = (string)$args->[$arg_count];

          my $space_count = $width - length $arg;;
          if ($left_justified) {
            $buffer->push($arg);
            for (my $i = 0; $i < $space_count; ++$i) {
              $buffer->push_char($pad_char);
            }
          }
          else {
            for (my $i = 0; $i < $space_count; ++$i) {
              $buffer->push_char($pad_char);
            }
            $buffer->push($arg);
          }
        }
        elsif ($specifier_char == 'd') {
          ++$index;
          my $arg = ((Int)$args->[$arg_count])->value;
          my $digits = new byte[11]; # -2147483648 has 11 digits
          my $digit_count = 0;
          while ($arg > 0) {
            $digits->[$digit_count++] = (byte)('0' + $arg % 10);
            $arg /= 10;
          }

          if ($left_justified) {
            my $space_count = $width - $digit_count;

            if ($arg < 0) {
              $buffer->push_char('-');
              --$space_count;
            }
            elsif ($plus_sign && $arg >= 0) {
              $buffer->push_char('+');
              --$space_count;
            }

            for (my $i = 0; $i < $digit_count; ++$i) {
              $buffer->push_char($digits->[$digit_count - $i - 1]);
            }

            if ($space_count > 0) {
              for (; $space_count > 0; --$space_count) {
                $buffer->push_char($pad_char);
              }
            }
          }
          else {
            my $space_count = $width - $digit_count;

            if ($arg < 0) {
              --$space_count;
            }
            elsif ($plus_sign && $arg >= 0) {
              --$space_count;
            }

            if ($space_count > 0) {
              for (; $space_count > 0; --$space_count) {
                $buffer->push_char($pad_char);
              }
            }

            if ($arg < 0) {
              $buffer->push_char('-');
            }
            elsif ($plus_sign && $arg >= 0) {
              $buffer->push_char('+');
            }

            for (my $i = 0; $i < $digit_count; ++$i) {
              $buffer->push_char($digits->[$digit_count - $i - 1]);
            }
          }
        }
        elsif ($specifier_char == 'u') {
          ++$index;
          my $arg = ((Int)$args->[$arg_count])->value & 0xFFFFFFFFL;
          my $digits = new byte[10]; # 4294967295 has 10 digits
          my $digit_count = 0;
          while ($arg > 0) {
            $digits->[$digit_count++] = (byte)('0' + $arg % 10);
            $arg /= 10;
          }

          if ($left_justified) {
            my $space_count = $width - $digit_count;

            if ($arg < 0) {
              $buffer->push_char('-');
              --$space_count;
            }
            elsif ($plus_sign && $arg >= 0) {
              $buffer->push_char('+');
              --$space_count;
            }

            for (my $i = 0; $i < $digit_count; ++$i) {
              $buffer->push_char($digits->[$digit_count - $i - 1]);
            }

            if ($space_count > 0) {
              for (; $space_count > 0; --$space_count) {
                $buffer->push_char($pad_char);
              }
            }
          }
          else {
            my $space_count = $width - $digit_count;

            if ($arg < 0) {
              --$space_count;
            }
            elsif ($plus_sign && $arg >= 0) {
              --$space_count;
            }

            if ($space_count > 0) {
              for (; $space_count > 0; --$space_count) {
                $buffer->push_char($pad_char);
              }
            }

            if ($arg < 0) {
              $buffer->push_char('-');
            }
            elsif ($plus_sign && $arg >= 0) {
              $buffer->push_char('+');
            }

            for (my $i = 0; $i < $digit_count; ++$i) {
              $buffer->push_char($digits->[$digit_count - $i - 1]);
            }
          }
        }
        elsif ($specifier_char == 'l') {
          unless ($index + 1 < $format_length && ($format->[$index + 1] == 'd' || $format->[$index + 1] == 'u')) {
            die "Invalid conversion in sprintf: \""
                . Fn->substr($format, $specifier_base_index, $index - $specifier_base_index + 1) . "\"";
          }

          my $is_signed_format = $format->[$index + 1] == 'd';
          $index += 2;

          my $arg = ((Long)$args->[$arg_count])->value;
          my $digits = new byte[20]; # -9223372036854775808[18446744073709551615] has 20 digits
          my $digit_count = 0;

          if ($is_signed_format) {
            while ($arg > 0) {
              $digits->[$digit_count++] = (byte)('0' + $arg % 10);
              $arg /= 10;
            }
          }
          else {
            Fn->_long_to_unsigned_digits($arg, $digits, \$digit_count);
          }

          if ($left_justified) {
            my $space_count = $width - $digit_count;

            if ($is_signed_format && $arg < 0) {
              $buffer->push_char('-');
              --$space_count;
            }
            elsif ($plus_sign && $arg >= 0) {
              $buffer->push_char('+');
              --$space_count;
            }

            for (my $i = 0; $i < $digit_count; ++$i) {
              $buffer->push_char($digits->[$digit_count - $i - 1]);
            }

            if ($space_count > 0) {
              for (; $space_count > 0; --$space_count) {
                $buffer->push_char($pad_char);
              }
            }
          }
          else {
            my $space_count = $width - $digit_count;

            if ($is_signed_format && $arg < 0) {
              --$space_count;
            }
            elsif ($plus_sign && $arg >= 0) {
              --$space_count;
            }

            if ($space_count > 0) {
              for (; $space_count > 0; --$space_count) {
                $buffer->push_char($pad_char);
              }
            }

            if ($is_signed_format && $arg < 0) {
              $buffer->push_char('-');
            }
            elsif ($plus_sign && $arg >= 0) {
              $buffer->push_char('+');
            }

            for (my $i = 0; $i < $digit_count; ++$i) {
              $buffer->push_char($digits->[$digit_count - $i - 1]);
            }
          }
        }
        elsif ($specifier_char == 'f' || $specifier_char == 'g') {
          ++$index;
          my $arg = (Double)$args->[$arg_count];
          my $specifier_str = Fn->substr($format, $specifier_base_index, $index - $specifier_base_index);
          my $string = Fn->_snsprintf_double($specifier_str, $arg->value);
          $buffer->push($string);
        }
        elsif ($specifier_char == 'U') {
          ++$index;
          my $arg = (Int)$args->[$arg_count];
          my $utf8 = Unicode->uchar_to_utf8($arg->value);
          $buffer->push($utf8);
        }
        else {
          die "Invalid conversion in sprintf: \""
              . Fn->substr($format, $specifier_base_index, $index - $specifier_base_index + 1) . "\"";
        }

        ++$arg_count;
      }
    }

    # Add constant string
    if ($constant_string_length > 0) {
      my $format_part = Fn->substr($format, $index, $constant_string_length);
      $buffer->push($format_part);
      $index += $constant_string_length;
      $constant_string_length = 0;
    }

    my $result = $buffer->to_string;
    return $result;
  }

  native static method srand : void ($seed : long);

  static method substr : string ($string : string, $offset : int, $length : int) {

    if ($string == undef) {
      die "String must be defined";
    }

    my $string_length = length $string;

    if ($offset < 0 || $offset > $string_length - 1) {
      die "Invalid offset $offset";
    }

    if ($length < 0) {
      die "Length must be non-zero value";
    }

    if ($offset + $length > $string_length) {
      die "Offset + length must not be over array length";
    }

    my $slice = new byte[$length];

    my $pos = 0;
    for (my $i = $offset; $i < $offset + $length; $i++) {
      $slice->[$pos] = $string->[$i];
      $pos++;
    }

    return (string)$slice;
  }

  native static method to_double : double ($string : string);

  native static method to_float : float ($string : string);

  static method to_int : int ($string : string) {
    return Fn->to_int_with_base($string, 10);
  }
  
  native static method to_int_with_base : int ($string : string, $digit : int);
  
  static method to_long : long ($string : string) {
    return Fn->to_long_with_base($string, 10);
  }
  native static method to_long_with_base : long ($string : string, $digit : int);

  static method to_lower : int ($code_point : int) {

    if ($code_point >= 'A' && $code_point <= 'Z') {
      $code_point = $code_point + 0x20;
    }
    return $code_point;
  }

  static method to_upper : int ($code_point : int) {

    if ($code_point >= 'a' && $code_point <= 'z') {
      $code_point = $code_point - 0x20;
    }
    return $code_point;
  }

  static method trim_ascii_space : string ($string : string) {
    
    unless ($string) {
      return undef;
    }
    
    my $length = length $string;
    my $start_string_index = -1;
    my $end_string_index = -1;
    
    for (my $i = 0; $i < $length; $i++) {
      if ($start_string_index == -1) {
        if (Fn->is_space($string->[$i])) {
          # Skip
        }
        else {
          $start_string_index = $i;
          last;
        }
      }
    }

    for (my $i = $length - 1; $i >= 0; $i--) {
      if ($end_string_index == -1) {
        if (Fn->is_space($string->[$i])) {
          # Skip
        }
        else {
          $end_string_index = $i;
          last;
        }
      }
    }
    
    my $trimed_string : string;
    if ($start_string_index == -1 && $end_string_index == -1) {
      return "";
    }
    elsif ($end_string_index == -1) {
      $trimed_string = Fn->substr($string, $start_string_index, $length - $start_string_index);
    }
    elsif ($end_string_index == -1) {
      $trimed_string = Fn->substr($string, 0, $end_string_index + 1);
    }
    else {
      $trimed_string = Fn->substr($string, $start_string_index, $end_string_index - $start_string_index + 1);
    }
    
    return $trimed_string;
  }


  static method uc : string ($string : string) {

    unless ($string) { die "String must be defined"; }

    my $length = length $string;
    my $new_string = new byte [$length];
    for (my $i = 0; $i < $length; $i++) {
      my $char = $string->[$i];
      if ($char >= 'a' && $char <= 'z') {
        $new_string->[$i] = (byte)($string->[$i] - 32);
      }
      else {
        $new_string->[$i] = $string->[$i];
      }
    }
    return (string)$new_string;
  }

  static method ucfirst : string ($string : string) {

    unless ($string) { die "String must be defined"; }

    my $length = length $string;
    my $new_string = new byte [$length];
    if ($length > 0) {
      my $char = $string->[0];
      if ($char >= 'a' && $char <= 'z') {
        $new_string->[0] = (byte)($char - 32);
      }
      else {
        $new_string->[0] = $char;
      }
    }
    for (my $i = 1; $i < $length; ++$i) {
      $new_string->[$i] = $string->[$i];
    }
    return (string)$new_string;
  }


  native static method _snsprintf_double : string ($format : string, $value : double);

  native static method _long_to_unsigned_digits : void ($value : long, $out_digits : byte[], $out_digit_count : int*);

  private static method _sort_byte_merge : void($a : byte[], $b : byte[], $left : int, $mid : int, $right : int, $n : int, $comparator : Comparator::Byte) {
    my $i = $left;
    my $j = $mid + 1;
    my $k = 0;
    while ($i <= $mid && $j <= $right) {
      $i = $left;
      $j = $mid + 1;
      $k = 0;
      while ($i <= $mid && $j <= $right) {
        if ($comparator->($a->[$i], $a->[$j]) <= 0) {
          $b->[$k] = $a->[$i];
          $i++;
        } else {
          $b->[$k] = $a->[$j];
          $j++;
        }
        $k++;
      }
      if ($i == $mid + 1) {
        while ($j <= $right) {
          $b->[$k] = $a->[$j]; 
          $j++;
          $k++;
        }
      } else {
        while($i <= $mid) {
          $b->[$k] = $a->[$i];
          $i++;
          $k++;
        }
      }
    }
    for ($i = 0; $i < $k; $i++) {
      $a->[$i + $left] = $b->[$i];
    }
  }
  private static method _sort_byte_merge_sort : void($a : byte[], $b : byte[], $left : int, $right : int, $n : int, $comparator : Comparator::Byte){
    if ($left >= $right) {
      return;
    }

    my $mid = ($left + $right) / 2;

    Fn->_sort_byte_merge_sort($a, $b, $left, $mid, $n, $comparator);
    Fn->_sort_byte_merge_sort($a, $b, $mid + 1, $right, $n, $comparator);
    Fn->_sort_byte_merge($a, $b, $left, $mid, $right, $n, $comparator);
  }

  private static method _sort_short_merge : void($a : short[], $b : short[], $left : int, $mid : int, $right : int, $n : int, $comparator : Comparator::Short) {
    my $i = $left;
    my $j = $mid + 1;
    my $k = 0;
    while ($i <= $mid && $j <= $right) {
      $i = $left;
      $j = $mid + 1;
      $k = 0;
      while ($i <= $mid && $j <= $right) {
        if ($comparator->($a->[$i], $a->[$j]) <= 0) {
          $b->[$k] = $a->[$i];
          $i++;
        } else {
          $b->[$k] = $a->[$j];
          $j++;
        }
        $k++;
      }
      if ($i == $mid + 1) {
        while ($j <= $right) {
          $b->[$k] = $a->[$j]; 
          $j++;
          $k++;
        }
      } else {
        while($i <= $mid) {
          $b->[$k] = $a->[$i];
          $i++;
          $k++;
        }
      }
    }
    for ($i = 0; $i < $k; $i++) {
      $a->[$i + $left] = $b->[$i];
    }
  }
  private static method _sort_short_merge_sort : void($a : short[], $b : short[], $left : int, $right : int, $n : int, $comparator : Comparator::Short){
    if ($left >= $right) {
      return;
    }

    my $mid = ($left + $right) / 2;

    Fn->_sort_short_merge_sort($a, $b, $left, $mid, $n, $comparator);
    Fn->_sort_short_merge_sort($a, $b, $mid + 1, $right, $n, $comparator);
    Fn->_sort_short_merge($a, $b, $left, $mid, $right, $n, $comparator);
  }


  private static method _sort_int_merge : void($a : int[], $b : int[], $left : int, $mid : int, $right : int, $n : int, $comparator : Comparator::Int) {
    my $i = $left;
    my $j = $mid + 1;
    my $k = 0;
    while ($i <= $mid && $j <= $right) {
      $i = $left;
      $j = $mid + 1;
      $k = 0;
      while ($i <= $mid && $j <= $right) {
        if ($comparator->($a->[$i], $a->[$j]) <= 0) {
          $b->[$k] = $a->[$i];
          $i++;
        } else {
          $b->[$k] = $a->[$j];
          $j++;
        }
        $k++;
      }
      if ($i == $mid + 1) {
        while ($j <= $right) {
          $b->[$k] = $a->[$j]; 
          $j++;
          $k++;
        }
      } else {
        while($i <= $mid) {
          $b->[$k] = $a->[$i];
          $i++;
          $k++;
        }
      }
    }
    for ($i = 0; $i < $k; $i++) {
      $a->[$i + $left] = $b->[$i];
    }
  }
  private static method _sort_int_merge_sort : void($a : int[], $b : int[], $left : int, $right : int, $n : int, $comparator : Comparator::Int){
    if ($left >= $right) {
      return;
    }

    my $mid = ($left + $right) / 2;

    Fn->_sort_int_merge_sort($a, $b, $left, $mid, $n, $comparator);
    Fn->_sort_int_merge_sort($a, $b, $mid + 1, $right, $n, $comparator);
    Fn->_sort_int_merge($a, $b, $left, $mid, $right, $n, $comparator);
  }

  private static method _sort_long_merge : void($a : long[], $b : long[], $left : int, $mid : int, $right : int, $n : int, $comparator : Comparator::Long) {
    my $i = $left;
    my $j = $mid + 1;
    my $k = 0;
    while ($i <= $mid && $j <= $right) {
      $i = $left;
      $j = $mid + 1;
      $k = 0;
      while ($i <= $mid && $j <= $right) {
        if ($comparator->($a->[$i], $a->[$j]) <= 0) {
          $b->[$k] = $a->[$i];
          $i++;
        } else {
          $b->[$k] = $a->[$j];
          $j++;
        }
        $k++;
      }
      if ($i == $mid + 1) {
        while ($j <= $right) {
          $b->[$k] = $a->[$j]; 
          $j++;
          $k++;
        }
      } else {
        while($i <= $mid) {
          $b->[$k] = $a->[$i];
          $i++;
          $k++;
        }
      }
    }
    for ($i = 0; $i < $k; $i++) {
      $a->[$i + $left] = $b->[$i];
    }
  }
  private static method _sort_long_merge_sort : void($a : long[], $b : long[], $left : int, $right : int, $n : int, $comparator : Comparator::Long){
    if ($left >= $right) {
      return;
    }

    my $mid = ($left + $right) / 2;

    Fn->_sort_long_merge_sort($a, $b, $left, $mid, $n, $comparator);
    Fn->_sort_long_merge_sort($a, $b, $mid + 1, $right, $n, $comparator);
    Fn->_sort_long_merge($a, $b, $left, $mid, $right, $n, $comparator);
  }

  private static method _sort_float_merge : void($a : float[], $b : float[], $left : int, $mid : int, $right : int, $n : int, $comparator : Comparator::Float) {
    my $i = $left;
    my $j = $mid + 1;
    my $k = 0;
    while ($i <= $mid && $j <= $right) {
      $i = $left;
      $j = $mid + 1;
      $k = 0;
      while ($i <= $mid && $j <= $right) {
        if ($comparator->($a->[$i], $a->[$j]) <= 0) {
          $b->[$k] = $a->[$i];
          $i++;
        } else {
          $b->[$k] = $a->[$j];
          $j++;
        }
        $k++;
      }
      if ($i == $mid + 1) {
        while ($j <= $right) {
          $b->[$k] = $a->[$j]; 
          $j++;
          $k++;
        }
      } else {
        while($i <= $mid) {
          $b->[$k] = $a->[$i];
          $i++;
          $k++;
        }
      }
    }
    for ($i = 0; $i < $k; $i++) {
      $a->[$i + $left] = $b->[$i];
    }
  }
  private static method _sort_float_merge_sort : void($a : float[], $b : float[], $left : int, $right : int, $n : int, $comparator : Comparator::Float){
    if ($left >= $right) {
      return;
    }

    my $mid = ($left + $right) / 2;

    Fn->_sort_float_merge_sort($a, $b, $left, $mid, $n, $comparator);
    Fn->_sort_float_merge_sort($a, $b, $mid + 1, $right, $n, $comparator);
    Fn->_sort_float_merge($a, $b, $left, $mid, $right, $n, $comparator);
  }

  private static method _sort_double_merge : void($a : double[], $b : double[], $left : int, $mid : int, $right : int, $n : int, $comparator : Comparator::Double) {
    my $i = $left;
    my $j = $mid + 1;
    my $k = 0;
    while ($i <= $mid && $j <= $right) {
      $i = $left;
      $j = $mid + 1;
      $k = 0;
      while ($i <= $mid && $j <= $right) {
        if ($comparator->($a->[$i], $a->[$j]) <= 0) {
          $b->[$k] = $a->[$i];
          $i++;
        } else {
          $b->[$k] = $a->[$j];
          $j++;
        }
        $k++;
      }
      if ($i == $mid + 1) {
        while ($j <= $right) {
          $b->[$k] = $a->[$j]; 
          $j++;
          $k++;
        }
      } else {
        while($i <= $mid) {
          $b->[$k] = $a->[$i];
          $i++;
          $k++;
        }
      }
    }
    for ($i = 0; $i < $k; $i++) {
      $a->[$i + $left] = $b->[$i];
    }
  }
  private static method _sort_double_merge_sort : void($a : double[], $b : double[], $left : int, $right : int, $n : int, $comparator : Comparator::Double){
    if ($left >= $right) {
      return;
    }

    my $mid = ($left + $right) / 2;

    Fn->_sort_double_merge_sort($a, $b, $left, $mid, $n, $comparator);
    Fn->_sort_double_merge_sort($a, $b, $mid + 1, $right, $n, $comparator);
    Fn->_sort_double_merge($a, $b, $left, $mid, $right, $n, $comparator);
  }

  private static method _sort_string_merge : void($a : string[], $b : string[], $left : int, $mid : int, $right : int, $n : int, $comparator : Comparator::String) {
    my $i = $left;
    my $j = $mid + 1;
    my $k = 0;
    while ($i <= $mid && $j <= $right) {
      $i = $left;
      $j = $mid + 1;
      $k = 0;
      while ($i <= $mid && $j <= $right) {
        if ($comparator->($a->[$i], $a->[$j]) <= 0) {
          $b->[$k] = $a->[$i];
          $i++;
        } else {
          $b->[$k] = $a->[$j];
          $j++;
        }
        $k++;
      }
      if ($i == $mid + 1) {
        while ($j <= $right) {
          $b->[$k] = $a->[$j]; 
          $j++;
          $k++;
        }
      } else {
        while($i <= $mid) {
          $b->[$k] = $a->[$i];
          $i++;
          $k++;
        }
      }
    }
    for ($i = 0; $i < $k; $i++) {
      $a->[$i + $left] = $b->[$i];
    }
  }

  private static method _sort_string_merge_sort : void($a : string[], $b : string[], $left : int, $right : int, $n : int, $comparator : Comparator::String){
    if ($left >= $right) {
      return;
    }

    my $mid = ($left + $right) / 2;

    Fn->_sort_string_merge_sort($a, $b, $left, $mid, $n, $comparator);
    Fn->_sort_string_merge_sort($a, $b, $mid + 1, $right, $n, $comparator);
    Fn->_sort_string_merge($a, $b, $left, $mid, $right, $n, $comparator);
  }

  private static method _sort_object_merge : void($a : oarray, $b : oarray, $left : int, $mid : int, $right : int, $n : int, $comparator : Comparator::Object) {
      my $i = $left;
      my $j = $mid + 1;
      my $k = 0;
      while ($i <= $mid && $j <= $right) {
        $i = $left;
        $j = $mid + 1;
        $k = 0;
        while ($i <= $mid && $j <= $right) {
          if ($comparator->($a->[$i], $a->[$j]) <= 0) {
            $b->[$k] = $a->[$i];
            $i++;
          } else {
            $b->[$k] = $a->[$j];
            $j++;
          }
          $k++;
        }
        if ($i == $mid + 1) {
          while ($j <= $right) {
            $b->[$k] = $a->[$j]; 
            $j++;
            $k++;
          }
        } else {
          while($i <= $mid) {
            $b->[$k] = $a->[$i];
            $i++;
            $k++;
          }
        }
      }
      for ($i = 0; $i < $k; $i++) {
        $a->[$i + $left] = $b->[$i];
      }
  }

  private static method _sort_object_merge_sort : void($a : oarray, $b : oarray, $left : int, $right : int, $n : int, $comparator : Comparator::Object){
    if ($left >= $right) {
      return;
    }

    my $mid = ($left + $right) / 2;

    Fn->_sort_object_merge_sort($a, $b, $left, $mid, $n, $comparator);
    Fn->_sort_object_merge_sort($a, $b, $mid + 1, $right, $n, $comparator);
    Fn->_sort_object_merge($a, $b, $left, $mid, $right, $n, $comparator);
  }
}

