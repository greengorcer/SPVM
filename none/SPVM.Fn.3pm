.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "SPVM::Fn 3"
.TH SPVM::Fn 3 "2022-01-28" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
SPVM::Fn \- SPVM Starndard Functions
.SH "SYNOPSYS"
.IX Header "SYNOPSYS"
.SS "\s-1SPVM\s0"
.IX Subsection "SPVM"
.Vb 1
\&  use Fn;
\&  
\&  my $int8_max = Fn\->INT8_MAX();
\&  my $int16_max = Fn\->INT16_MAX();
\&  my $int32_max = Fn\->INT32_MAX();
\&  my $int64_max = Fn\->INT64_MAX();
\&  
\&  my $rand = Fn\->rand();
\&
\&  # Cut a newline LF
\&  {
\&    my $ret = Fn\->chompr("abc\en");
\&  }
\&  
\&  # Copy a string
\&  {
\&    my $string = "abc";
\&    my $string_copy = Fn\->copy_string ($string);
\&  }
\&
\&  # Search substr
\&  {
\&    my $found_offset = Fn\->index("pppabcde", "bcd", 2);
\&  }
\&
\&  # split a string by the specific separator
\&  my $string = "foo,bar,baz";
\&  my $splited_strs = Fn\->split(",", $string);
\&
\&  # Copy a byte array
\&  {
\&    my $nums = [(byte)1, 2, 3];
\&    my $nums_copy = Fn\->copy_array_byte($nums);
\&  }
\&
\&  # Copy a short array
\&  {
\&    my $nums = [(short)1, 2, 3];
\&    my $nums_copy = Fn\->copy_array_short($nums);
\&  }
\&
\&  # Copy a int array
\&  {
\&    my $nums = [1, 2, 3];
\&    my $nums_copy = Fn\->copy_array_int($nums);
\&  }
\&
\&  # Copy a long array
\&  {
\&    my $nums = [(long)1, 2, 3];
\&    my $nums_copy = Fn\->copy_array_long($nums);
\&  }
\&
\&  # Copy a float array
\&  {
\&    my $nums = [1.5f, 2.5f, 3.5f];
\&    my $nums_copy = Fn\->copy_array_float($nums);
\&  }
\&
\&  # Copy a double array
\&  {
\&    my $nums = [1.5, 2.5, 3.5];
\&    my $nums_copy = Fn\->copy_array_double($nums);
\&  }
\&  
\&  # Copy a string array
\&  {
\&    my $strs = ["abc", "def", "ghi"]
\&    my $strs_copy = Fn\->copy_array_string($strs);
\&  }
\&  
\&  # Check if the two byte arrays equal
\&  {
\&    my $nums1 = [(byte)1, 2];
\&    my $nums2 = [(byte)1, 2];
\&    my $ret = Fn\->equals_array_byte($nums1, $nums2);
\&  }
\&
\&  # Check if the two short arrays equal
\&  {
\&    my $nums1 = [(short)1, 2];
\&    my $nums2 = [(short)1, 2];
\&    my $ret = Fn\->equals_array_short($nums1, $nums2);
\&  }
\&
\&  # Check if the two int arrays equal
\&  {
\&    my $nums1 = [(int)1, 2];
\&    my $nums2 = [(int)1, 2];
\&    my $ret = Fn\->equals_array_int($nums1, $nums2);
\&  }
\&
\&  # Check if the two long arrays equal
\&  {
\&    my $nums1 = [(long)1, 2];
\&    my $nums2 = [(long)1, 2];
\&    my $ret = Fn\->equals_array_long($nums1, $nums2);
\&  }
\&
\&  # Check if the two float arrays equal
\&  {
\&    my $nums1 = [(float)1, 2];
\&    my $nums2 = [(float)1, 2];
\&    my $ret = Fn\->equals_array_float($nums1, $nums2);
\&  }
\&
\&  # Check if the two double arrays equal
\&  {
\&    my $nums1 = [(double)1, 2];
\&    my $nums2 = [(double)1, 2];
\&    my $ret = Fn\->equals_array_double($nums1, $nums2);
\&  }
\&
\&  # Check if the two string arrays equal
\&  {
\&    my $strs1 = ["abc", "def"];
\&    my $strs2 = ["abc", "def"];
\&    my $ret = Fn\->equals_array_string($strs1, $strs2);
\&  }
\&  
\&  # Copy object array
\&  my $objects = [(object)Int\->new(1), Int\->new(2), Int\->new(3)];
\&  my $objects_copy = Fn\->copy_array_object($objects, method : object ($obj : object) {
\&    my $int_obj = (Int)$obj;
\&    my $new_int_obj = Int\->new($int_obj\->value);
\&    return $new_int_obj;
\&  });
\&
\&  # Sort byte array itself by asc order
\&  my $nums = [(byte)2, 3, 1];
\&  Fn\->sort_byte($nums, 0, scalar @$nums, method : int ($a : byte, $b : byte) {
\&    return $a <=> $b;
\&  });
\&
\&  # Sort short array itself by asc order
\&  my $nums = [(short)2, 3, 1];
\&  Fn\->sort_short($nums, 0, scalar @$nums, method : int ($a : short, $b : short) {
\&    return $a <=> $b;
\&  });
\&
\&  # Sort int array itself by asc order
\&  my $nums = [2, 3, 1];
\&  Fn\->sort_int($nums, 0, scalar @$nums, method : int ($a : int, $b : int) {
\&    return $a <=> $b;
\&  });
\&
\&  # Sort long array itself by asc order
\&  my $nums = [(long)2, 3, 1];
\&  Fn\->sort_long($nums, 0, scalar @$nums, method : int ($a : long, $b : long) {
\&    return $a <=> $b;
\&  });
\&
\&  # Sort float array itself by asc order
\&  my $nums = [(float)2, 3, 1];
\&  Fn\->sort_float($nums, 0, scalar @$nums, method : int ($a : float, $b : float) {
\&    return $a <=> $b;
\&  });
\&
\&  # Sort double array itself by asc order
\&  my $nums = [(double)2, 3, 1];
\&  Fn\->sort_double($nums, 0, scalar @$nums, method : int ($a : double, $b : double) {
\&    return $a <=> $b;
\&  });
\&
\&  # Sort string array itself by asc order
\&  my $nums = ["11", "1", "2", undef, ""];
\&  Fn\->sort_double($nums, 0, scalar @$nums, method : int ($a : double, $b : double) {
\&    return $a <=> $b;
\&  });
\&
\&  # Sort object array itself by asc order
\&  my $minimals = new TestCase::Minimal[3];
\&  $minimals\->[0] = TestCase::Minimal\->new;
\&  $minimals\->[0]{x} = 3;
\&  $minimals\->[0]{y} = 5;
\&  $minimals\->[1] = TestCase::Minimal\->new;
\&  $minimals\->[1]{x} = 3;
\&  $minimals\->[1]{y} = 7;
\&  $minimals\->[2] = TestCase::Minimal\->new;
\&  $minimals\->[2]{x} = 2;
\&  $minimals\->[2]{y} = 9;
\&  Fn\->sort_object$minimals, 0, scalar @$minimals, method : int ($object1 : object, $object2 : object) {
\&    my $minimal1 = (TestCase::Minimal)$object1;
\&    my $minimal2 = (TestCase::Minimal)$object2;
\&    
\&    return $minimal1\->{x} <=> $minimal2\->{x} || $minimal1\->{y} <=> $minimal2\->{y};
\&  };
.Ve
.SS "Perl"
.IX Subsection "Perl"
.Vb 1
\&  use SPVM \*(AqFn\*(Aq;
\&  
\&  my $int8_max = SPVM::Fn\->INT8_MAX();
\&  my $int16_max = SPVM::Fn\->INT16_MAX();
\&  my $int32_max = SPVM::Fn\->INT32_MAX();
\&  my $int64_max = SPVM::Fn\->INT64_MAX();
.Ve
.SH "CLASS METHODS"
.IX Header "CLASS METHODS"
.SS "\s-1DBL_MAX\s0"
.IX Subsection "DBL_MAX"
.Vb 1
\&  static method DBL_MAX : double ()
.Ve
.PP
Return the value of \s-1DBL_MAX\s0 macro defined in \f(CW\*(C`float.h\*(C'\fR header of C language.
.SS "\s-1DBL_MIN\s0"
.IX Subsection "DBL_MIN"
.Vb 1
\&  static method DBL_MIN : double ()
.Ve
.PP
Return the value of \s-1DBL_MIN\s0 macro defined in \f(CW\*(C`float.h\*(C'\fR header of C language.
.SS "\s-1FLT_MAX\s0"
.IX Subsection "FLT_MAX"
.Vb 1
\&  static method FLT_MAX : float ()
.Ve
.PP
Return the value of \s-1FLT_MAX\s0 macro defined in \f(CW\*(C`float.h\*(C'\fR header of C language.
.SS "\s-1FLT_MIN\s0"
.IX Subsection "FLT_MIN"
.Vb 1
\&  static method FLT_MIN : float ()
.Ve
.PP
Return the value of \s-1FLT_MIN\s0 macro defined in \f(CW\*(C`float.h\*(C'\fR header of C language.
.SS "\s-1INT16_MAX\s0"
.IX Subsection "INT16_MAX"
.Vb 1
\&  static method INT16_MAX : short ()
.Ve
.PP
Return 32767. The maximum value of the signed 16bit integer.
.SS "\s-1INT16_MIN\s0"
.IX Subsection "INT16_MIN"
.Vb 1
\&  static method INT16_MIN : short ()
.Ve
.PP
Return \-32768. The minimal value of the signed 16bit integer.
.SS "\s-1INT32_MAX\s0"
.IX Subsection "INT32_MAX"
.Vb 1
\&  static method INT32_MAX : int ()
.Ve
.PP
Return 2147483647. The maximum value of the signed 32bit integer.
.SS "\s-1INT32_MIN\s0"
.IX Subsection "INT32_MIN"
.Vb 1
\&  static method INT32_MIN : int ()
.Ve
.PP
Return \-2147483648. The minimal value of the signed 32bit integer.
.SS "\s-1INT64_MAX\s0"
.IX Subsection "INT64_MAX"
.Vb 1
\&  static method INT64_MAX : long ()
.Ve
.PP
Return 9223372036854775807. The maximum value of the signed 64bit integer.
.SS "\s-1INT64_MIN\s0"
.IX Subsection "INT64_MIN"
.Vb 1
\&  static method INT64_MIN : long ()
.Ve
.PP
Return \-9223372036854775808. The minimal value of signed 64bit integer.
.SS "\s-1INT8_MAX\s0"
.IX Subsection "INT8_MAX"
.Vb 1
\&  INT8_MAX : byte ()
.Ve
.PP
Return 127. The maximum value of the signed 8bit integer.
.SS "\s-1INT8_MIN\s0"
.IX Subsection "INT8_MIN"
.Vb 1
\&  static method INT8_MIN : byte ()
.Ve
.PP
Return \-128. The minimal value of the signed 8bit integer.
.SS "\s-1UINT16_MAX\s0"
.IX Subsection "UINT16_MAX"
.Vb 1
\&  static method UINT16_MAX : short ()
.Ve
.PP
Return \-1. The same bit expression of 0xFFFF in the unsigned 16bit integer in 2's complement.
.SS "\s-1UINT32_MAX\s0"
.IX Subsection "UINT32_MAX"
.Vb 1
\&  static method UINT32_MAX : int ()
.Ve
.PP
Return \-1. The same bit expression of 0xFFFFFFFF in the unsigned 32bit integer in 2's complement.
.SS "\s-1UINT64_MAX\s0"
.IX Subsection "UINT64_MAX"
.Vb 1
\&  static method UINT64_MAX : long ()
.Ve
.PP
Return \-1. The same bit expression of 0xFFFFFFFFFFFFFFFF in the unsigned 64bit integer in 2's complement.
.SS "\s-1UINT8_MAX\s0"
.IX Subsection "UINT8_MAX"
.Vb 1
\&  static method UINT8_MAX : byte ()
.Ve
.PP
Return \-1. The same bit expression of 0xFF in the unsigned 8bit integer in 2's complement.
.SS "abs"
.IX Subsection "abs"
.Vb 1
\&  static method abs : int ($x : int)
.Ve
.PP
Return the absolute value.
.SS "chompr"
.IX Subsection "chompr"
.Vb 1
\&  static method chompr : string ($string : string)
.Ve
.PP
Copy the string and remove \*(L"\en\*(R" of the end of line and return it.
.SS "copy_array_byte"
.IX Subsection "copy_array_byte"
.Vb 1
\&  static method copy_array_byte : byte[] ($nums : byte[])
.Ve
.PP
Copy a byte array.
.PP
If the array is undef, return undef.
.SS "copy_array_double"
.IX Subsection "copy_array_double"
.Vb 1
\&  static method copy_array_double : double[] ($nums : double[])
.Ve
.PP
Copy a double array.
.PP
If the array is undef, return undef.
.SS "copy_array_float"
.IX Subsection "copy_array_float"
.Vb 1
\&  static method copy_array_float : float[] ($nums : float[])
.Ve
.PP
Copy a float array.
.PP
If the array is undef, return undef.
.SS "copy_array_int"
.IX Subsection "copy_array_int"
.Vb 1
\&  static method copy_array_int : int[] ($nums : int[])
.Ve
.PP
Copy a int array.
.PP
If the array is undef, return undef.
.SS "copy_array_long"
.IX Subsection "copy_array_long"
.Vb 1
\&  static method copy_array_long : long[] ($nums : long[])
.Ve
.PP
Copy a long array.
.PP
If the array is undef, return undef.
.SS "copy_array_object"
.IX Subsection "copy_array_object"
.Vb 1
\&  static method copy_array_object : object[] ($objects : object[], $cloner : Cloner)
.Ve
.PP
Copy a object array with a Cloner callback implemetation.
.PP
If the array is undef, return undef.
.SS "copy_array_range_byte"
.IX Subsection "copy_array_range_byte"
.Vb 1
\&  static method copy_array_range_byte : byte[] ($nums : byte[], $offset : int, $length : int)
.Ve
.PP
Slice elements in the byte array with the start offset and the length.
.PP
Array must be defined, otherwise a exception occurs.
.PP
Offset must be in the array range, otherwise a exception occurs.
.PP
Length must be more than or equals to 0, othrewise a exception occurs.
.PP
Offset + length must not be in the array range, othrewise a exception occurs.
.SS "copy_array_range_double"
.IX Subsection "copy_array_range_double"
.Vb 1
\&  static method copy_array_range_double : double[] ($nums : double[], $offset : int, $length : int)
.Ve
.PP
Slice elements in the double array with the start offset and the length.
.PP
Array must be defined, otherwise a exception occurs.
.PP
Offset must be in the array range, otherwise a exception occurs.
.PP
Length must be more than or equals to 0, othrewise a exception occurs.
.PP
Offset + length must not be in the array range, othrewise a exception occurs.
.SS "copy_array_range_float"
.IX Subsection "copy_array_range_float"
.Vb 1
\&  static method copy_array_range_float : float[] ($nums : float[], $offset : int, $length : int)
.Ve
.PP
Slice elements in the float array with the start offset and the length.
.PP
Array must be defined, otherwise a exception occurs.
.PP
Offset must be in the array range, otherwise a exception occurs.
.PP
Length must be more than or equals to 0, othrewise a exception occurs.
.PP
Offset + length must not be in the array range, othrewise a exception occurs.
.SS "copy_array_range_int"
.IX Subsection "copy_array_range_int"
.Vb 1
\&  static method copy_array_range_int : int[] ($nums : int[], $offset : int, $length : int)
.Ve
.PP
Slice elements in the int array with the start offset and the length.
.PP
Array must be defined, otherwise a exception occurs.
.PP
Offset must be in the array range, otherwise a exception occurs.
.PP
Length must be more than or equals to 0, othrewise a exception occurs.
.PP
Offset + length must not be in the array range, othrewise a exception occurs.
.SS "copy_array_range_long"
.IX Subsection "copy_array_range_long"
.Vb 1
\&  static method copy_array_range_long : long[] ($nums : long[], $offset : int, $length : int)
.Ve
.PP
Slice elements in the long array with the start offset and the length.
.PP
Array must be defined, otherwise a exception occurs.
.PP
Offset must be in the array range, otherwise a exception occurs.
.PP
Length must be more than or equals to 0, othrewise a exception occurs.
.PP
Offset + length must not be in the array range, othrewise a exception occurs.
.SS "copy_array_range_object"
.IX Subsection "copy_array_range_object"
.Vb 1
\&  static method copy_array_range_object : oarray ($elems : oarray, $offset : int, $length : int)
.Ve
.PP
Slice elements in the object array with the start offset and the length.
.PP
Array must be defined, otherwise a exception occurs.
.PP
Offset must be in the array range, otherwise a exception occurs.
.PP
Length must be more than or equals to 0, othrewise a exception occurs.
.PP
Offset + length must not be in the array range, othrewise a exception occurs.
.SS "copy_array_range_short"
.IX Subsection "copy_array_range_short"
.Vb 1
\&  static method copy_array_range_short : short[] ($nums : short[], $offset : int, $length : int)
.Ve
.PP
Slice elements in the short array with the start offset and the length.
.PP
Array must be defined, otherwise a exception occurs.
.PP
Offset must be in the array range, otherwise a exception occurs.
.PP
Length must be more than or equals to 0, othrewise a exception occurs.
.PP
Offset + length must not be in the array range, othrewise a exception occurs.
.SS "copy_array_range_string"
.IX Subsection "copy_array_range_string"
.Vb 1
\&  static method copy_array_range_string : string[] ($strings : string[], $offset : int, $length : int)
.Ve
.PP
Slice elements in the string array with the start offset and the length.
.PP
Array must be defined, otherwise a exception occurs.
.PP
Offset must be in the array range, otherwise a exception occurs.
.PP
Length must be more than or equals to 0, othrewise a exception occurs.
.PP
Offset + length must not be in the array range, othrewise a exception occurs.
.SS "copy_array_short"
.IX Subsection "copy_array_short"
.Vb 1
\&  static method copy_array_short : short[] ($nums : short[])
.Ve
.PP
Copy a short array.
.PP
If the array is undef, return undef.
.SS "copy_array_string"
.IX Subsection "copy_array_string"
.Vb 1
\&  static method copy_array_string : string[] ($strings : string[])
.Ve
.PP
Copy a string array.
.PP
If the array is undef, return undef.
.SS "copy_string"
.IX Subsection "copy_string"
.Vb 1
\&  static method copy_string : string ($string : string)
.Ve
.PP
Copy the value of the string, and return a new string.
.PP
If the argument string is undef, return undef.
.SS "crand"
.IX Subsection "crand"
.Vb 1
\&  static method crand : int ();
.Ve
.PP
Get random number(0 <= rundom_number <= Fn\->\s-1RAND_MAX\s0). This is same as rand function of C language.
.PP
The first seed is initialized by epoch time automatically. If you set a seed manually, you can use <srand> class method.
.PP
This method is not thread safe because internaly this method use rand function of C language.
.SS "dump_array_byte"
.IX Subsection "dump_array_byte"
.Vb 1
\&  static method dump_array_byte : string ($nums : byte[])
.Ve
.PP
Convert the elements in the byte array to string and join them with \*(L",\*(R" and surround it with \*(L"[\*(R" and \*(L"]\*(R", and return it.
.PP
For readability spaces and line breaks are inserted.
.PP
If byte array is undef, return undef.
.SS "dump_array_double"
.IX Subsection "dump_array_double"
.Vb 1
\&  static method dump_array_double : string ($nums : double[])
.Ve
.PP
Convert the elements in the double array to string and join them with \*(L",\*(R" and surround it with \*(L"[\*(R" and \*(L"]\*(R", and return it.
.PP
For readability spaces and line breaks are inserted.
.PP
If byte array is undef, return undef.
.SS "dump_array_float"
.IX Subsection "dump_array_float"
.Vb 1
\&  static method dump_array_float : string ($nums : float[])
.Ve
.PP
Convert the elements in the float array to string and join them with \*(L",\*(R" and surround it with \*(L"[\*(R" and \*(L"]\*(R", and return it.
.PP
For readability spaces and line breaks are inserted.
.PP
If byte array is undef, return undef.
.SS "dump_array_int"
.IX Subsection "dump_array_int"
.Vb 1
\&  static method dump_array_int : string ($nums : int[])
.Ve
.PP
Convert the elements in the int array to string and join them with \*(L",\*(R" and surround it with \*(L"[\*(R" and \*(L"]\*(R", and return it.
.PP
If byte array is undef, return undef.
.SS "dump_array_long"
.IX Subsection "dump_array_long"
.Vb 1
\&  static method dump_array_long : string ($nums : long[])
.Ve
.PP
Convert the elements in the long array to string and join them with \*(L",\*(R" and surround it with \*(L"[\*(R" and \*(L"]\*(R", and return it.
.PP
If byte array is undef, return undef.
.SS "dump_array_object"
.IX Subsection "dump_array_object"
.Vb 1
\&  static method dump_array_object : string ($objects : oarray, $stringer : Stringer)
.Ve
.PP
Convert the elements in the object array to string by a \f(CW\*(C`SPVM::Stringer\*(C'\fR callback implementation and join them with \*(L",\*(R" and surround it with \*(L"[\*(R" and \*(L"]\*(R", and return it.
.PP
For readability spaces and line breaks are inserted.
.PP
If string array is undef, return undef.
.SS "dump_array_short"
.IX Subsection "dump_array_short"
.Vb 1
\&  static method dump_array_short : string ($nums : short[])
.Ve
.PP
Convert the elements in the short array to string and join them with \*(L",\*(R" and surround it with \*(L"[\*(R" and \*(L"]\*(R".
.PP
For readability spaces and line breaks are inserted.
.PP
If byte array is undef, return undef.
.SS "dump_array_string"
.IX Subsection "dump_array_string"
.Vb 1
\&  static method dump_array_string : string ($strings : string[])
.Ve
.PP
Join the strings in the array with \*(L",\*(R" and surround it with \*(L"[\*(R" and \*(L"]\*(R", and return it.
.PP
For readability spaces and line breaks are inserted.
.PP
If string array is undef, return undef.
.SS "dump_array_unsigned_byte"
.IX Subsection "dump_array_unsigned_byte"
.Vb 1
\&  static method dump_array_unsigned_byte : string ($nums : byte[])
.Ve
.PP
Convert the elements in the byte array to string interpreting as an unsigned 8bit integer and join them with \*(L",\*(R" and surround it with \*(L"[\*(R" and \*(L"]\*(R", and return it.
.PP
If byte array is undef, return undef.
.SS "dump_array_unsigned_int"
.IX Subsection "dump_array_unsigned_int"
.Vb 1
\&  static method dump_array_unsigned_int : string ($nums : int[])
.Ve
.PP
Convert the elements in the int array to string interpreting as an unsigned 32bit integer and join them with \*(L",\*(R" and surround it with \*(L"[\*(R" and \*(L"]\*(R", and return it.
.PP
If byte array is undef, return undef.
.SS "dump_array_unsigned_long"
.IX Subsection "dump_array_unsigned_long"
.Vb 1
\&  static method dump_array_unsigned_long : string ($nums : long[])
.Ve
.PP
Convert the elements in the long array to string interpreting as an unsigned 64bit integer and join them with \*(L",\*(R" and surround it with \*(L"[\*(R" and \*(L"]\*(R", and return it.
.PP
For readability spaces and line breaks are inserted.
.PP
If byte array is undef, return undef.
.SS "dump_array_unsigned_short"
.IX Subsection "dump_array_unsigned_short"
.Vb 1
\&  static method dump_array_unsigned_short : string ($nums : short[])
.Ve
.PP
Convert the elements in the short array to string interpreting as an unsigned 16bit integer and join them with \*(L",\*(R" and surround it with \*(L"[\*(R" and \*(L"]\*(R".
.PP
For readability spaces and line breaks are inserted.
.PP
If byte array is undef, return undef.
.SS "equals_array_byte"
.IX Subsection "equals_array_byte"
.Vb 1
\&  static method equals_array_byte : int ($nums1 : byte[], $nums2 : byte[])
.Ve
.PP
Check if two byte arrays equal.
.PP
If at least one of the arrays is undef, a excetpion occurs.
.SS "equals_array_double"
.IX Subsection "equals_array_double"
.Vb 1
\&  static method equals_array_double : int ($nums1 : double[], $nums2 : double[])
.Ve
.PP
Check if two double arrays equal.
.PP
If at least one of the arrays is undef, a excetpion occurs.
.SS "equals_array_float"
.IX Subsection "equals_array_float"
.Vb 1
\&  static method equals_array_float : int ($nums1 : float[], $nums2 : float[])
.Ve
.PP
Check if two float arrays equal.
.PP
If at least one of the arrays is undef, a excetpion occurs.
.SS "equals_array_int"
.IX Subsection "equals_array_int"
.Vb 1
\&  static method equals_array_int : int ($nums1 : int[], $nums2 : int[])
.Ve
.PP
Check if two int arrays equal.
.PP
If at least one of the arrays is undef, a excetpion occurs.
.SS "equals_array_long"
.IX Subsection "equals_array_long"
.Vb 1
\&  static method equals_array_long : int ($nums1 : long[], $nums2 : long[])
.Ve
.PP
Check if two long arrays equal.
.PP
If at least one of the arrays is undef, a excetpion occurs.
.SS "equals_array_object"
.IX Subsection "equals_array_object"
.Vb 1
\&  static method static method equals_array_object : int ($objs1 : oarray, $objs2 : oarray, $equality_checker : EqualityChecker)
.Ve
.PP
Check equality of two objects. You must sepecify a EqualityChecker object to check the equality of each element.
.PP
\&\f(CW$objs1\fR and \f(CW$objs2\fR and \f(CW$equality_checker\fR must be defined, otherwise a exception occur.
.PP
Return 1 if the length of \f(CW$objs1\fR and \f(CW$objs2\fR is same and all element is same, otherwise return 0.
.SS "equals_array_short"
.IX Subsection "equals_array_short"
.Vb 1
\&  static method equals_array_short : int ($nums1 : short[], $nums2 : short[])
.Ve
.PP
Check if two short arrays equal.
.PP
If at least one of the arrays is undef, a excetpion occurs.
.SS "equals_array_string"
.IX Subsection "equals_array_string"
.Vb 1
\&  static method equals_array_string : int ($strs1 : double[], $strs2 : double[])
.Ve
.PP
Check if two string arrays equal.
.PP
If at least one of the arrays is undef, a excetpion occurs.
.SS "hex"
.IX Subsection "hex"
.Vb 1
\&  static method hex : int ($hex_string : string)
.Ve
.PP
Convert hex string to int value.
.PP
the hex string must be defined, otherwise a exception occurs.
.PP
the hex string must be a valid expression which is represented by a regex \*(L"^([0\-9a\-fA\-F]{1,8})$\*(R", otherwise a exception occurs.
.SS "index"
.IX Subsection "index"
.Vb 1
\&  static method index : int ($string : string, $method_string : string, $position : int)
.Ve
.PP
index function searches for one string within another.
It returns the position of the first occurrence of \f(CW$method_string\fR in \f(CW$string\fR at or after \f(CW$position\fR. If \f(CW$position\fR is omitted, starts
searching from the beginning of the string. \f(CW$position\fR before the
beginning of the string or after its end is treated as if it were
the beginning or the end, respectively. \f(CW$position\fR and the return
value are based at zero. If the substring is not found, \*(L"index\*(R"
returns \-1.
.SS "is_alnum"
.IX Subsection "is_alnum"
.Vb 1
\&  static method is_alnum : int ($code_point : int)
.Ve
.PP
If character is alphanumeric('A'\-'Z', 'a'\-'z', '0'\-'9'), return 1. If not, return 0.
.SS "is_alpha"
.IX Subsection "is_alpha"
.Vb 1
\&  static method is_alpha : int ($code_point : int)
.Ve
.PP
If character is alphabetic('A'\-'Z', 'a'\-'z'), return 1. If not, return 0.
.SS "is_blank"
.IX Subsection "is_blank"
.Vb 1
\&  static method is_blank : int ($code_point : int)
.Ve
.PP
If character is blank(' ', '\et'), return 1. If not, return 0.
.SS "is_cntrl"
.IX Subsection "is_cntrl"
.Vb 1
\&  static method is_cntrl : int ($code_point : int)
.Ve
.PP
If character is a control character(0x00\-0x1F, 0x7F), return 1. If not, return 0.
.SS "is_digit"
.IX Subsection "is_digit"
.Vb 1
\&  static method is_digit : int ($code_point : int)
.Ve
.PP
If character is decimal digit ('0'\-'9'), return 1. If not, return 0.
.SS "is_graph"
.IX Subsection "is_graph"
.Vb 1
\&  static method is_graph : int ($code_point : int)
.Ve
.PP
If character has graphical representation(0x21\-0x7E), return 1. If not, return 0.
.SS "is_lower"
.IX Subsection "is_lower"
.Vb 1
\&  static method is_lower : int ($code_point : int)
.Ve
.PP
If character is lowercase letter('a'\-'z'), return 1. If not, return 0.
.SS "is_perl_space"
.IX Subsection "is_perl_space"
.Vb 1
\&  static method is_perl_space : int ($code_point : int)
.Ve
.PP
If character is Perl space character(' ', '\er', '\en', '\et', '\ef'), return 1. If not, return 0.
.SS "is_perl_word"
.IX Subsection "is_perl_word"
.Vb 1
\&  static method is_perl_word : int ($code_point : int)
.Ve
.PP
If character is Perl word character('a'\-'z', 'A'\-'Z', '_', '0'\-'9'), return 1. If not, return 0.
.SS "is_print"
.IX Subsection "is_print"
.Vb 1
\&  static method is_print : int ($code_point : int)
.Ve
.PP
If character is printable(0x20\-0x7E), return 1. If not, return 0.
.SS "is_punct"
.IX Subsection "is_punct"
.Vb 1
\&  static method is_punct : int ($code_point : int)
.Ve
.PP
If character is a punctuation character(0x21\-0x2f, 0x3a\-0x40, 0x5b\-0x60, 0x7b\-0x7e), return 1. If not, return 0.
.SS "is_space"
.IX Subsection "is_space"
.Vb 1
\&  static method is_space : int ($code_point : int)
.Ve
.PP
If character is a white\-space(' ',  '\et', '\en', '\ev', '\ef', '\er'), return 1. If not, return 0.
.SS "is_upper"
.IX Subsection "is_upper"
.Vb 1
\&  static method is_upper : int ($code_point : int)
.Ve
.PP
If character is uppercase letter('A'\-'Z'), return 1. If not, return 0.
.SS "is_xdigit"
.IX Subsection "is_xdigit"
.Vb 1
\&  static method is_xdigit : int ($code_point : int)
.Ve
.PP
If character is hexadecimal digit('0'\-'9', 'A'\-'F', 'a'\-'f'), return 1. If not, return 0.
.SS "join"
.IX Subsection "join"
.Vb 1
\&  static method join : string ($sep : string, $strings : string[])
.Ve
.PP
Join a string array with separater and return it.
.PP
If separater is undef, a exception occurs.
.PP
If string array is undef, a exception occurs.
.SS "labs"
.IX Subsection "labs"
.Vb 1
\&  static method labs : long ($x : long)
.Ve
.PP
Return the absolute value.
.SS "lc"
.IX Subsection "lc"
.Vb 1
\&  static method lc : string ($string : string)
.Ve
.PP
Convert uppercase string to lowercase string.
.SS "lcfirst"
.IX Subsection "lcfirst"
.Vb 1
\&  static method lcfirst : string ($string : string)
.Ve
.PP
Convert first chracter of string from uppercase to lowercase.
.SS "memcpy_byte"
.IX Subsection "memcpy_byte"
.Vb 1
\&  static method memcpy_byte : void ($dest : byte[], $dest_offset : int, $source : byte[], $source_offset : int, $length : int)
.Ve
.PP
Copy source byte array to destination byte array with the each offset and a length.
.PP
If source data range and destination data overlap, the result is not guaranteed.
.PP
Destnation must be defined, otherwise a exception occurs.
.PP
Source must be defined, otherwise a exception occurs.
.PP
Length must be more than or equals to 0, otherwise a exception occurs.
.PP
Destnation offset + length must be within the range of the destnation array, otherwise a exception occurs.
.PP
Source offset + length must be within the range of the source array, otherwise a exception occurs.
.SS "memcpy_double"
.IX Subsection "memcpy_double"
.Vb 1
\&  static method memcpy_double : void ($dest : double[], $dest_offset : int, $source : double[], $source_offset : int, $length : int)
.Ve
.PP
Copy source double array to destination double array with the each offset and a length.
.PP
If source data range and destination data overlap, the result is not guaranteed.
.PP
Destnation must be defined, otherwise a exception occurs.
.PP
Source must be defined, otherwise a exception occurs.
.PP
Length must be more than or equals to 0, otherwise a exception occurs.
.PP
Destnation offset + length must be within the range of the destnation array, otherwise a exception occurs.
.PP
Source offset + length must be within the range of the source array, otherwise a exception occurs.
.SS "memcpy_float"
.IX Subsection "memcpy_float"
.Vb 1
\&  static method memcpy_float : void ($dest : float[], $dest_offset : int, $source : float[], $source_offset : int, $length : int)
.Ve
.PP
Copy source float array to destination float array with the each offset and a length.
.PP
If source data range and destination data overlap, the result is not guaranteed.
.PP
Destnation must be defined, otherwise a exception occurs.
.PP
Source must be defined, otherwise a exception occurs.
.PP
Length must be more than or equals to 0, otherwise a exception occurs.
.PP
Destnation offset + length must be within the range of the destnation array, otherwise a exception occurs.
.PP
Source offset + length must be within the range of the source array, otherwise a exception occurs.
.SS "memcpy_int"
.IX Subsection "memcpy_int"
.Vb 1
\&  static method memcpy_int : void ($dest : int[], $dest_offset : int, $source : int[], $source_offset : int, $length : int)
.Ve
.PP
Copy source int array to destination int array with the each offset and a length.
.PP
Destnation must be defined, otherwise a exception occurs.
.PP
Source must be defined, otherwise a exception occurs.
.PP
Length must be more than or equals to 0, otherwise a exception occurs.
.PP
Destnation offset + length must be within the range of the destnation array, otherwise a exception occurs.
.PP
Source offset + length must be within the range of the source array, otherwise a exception occurs.
.SS "memcpy_long"
.IX Subsection "memcpy_long"
.Vb 1
\&  static method memcpy_long : void ($dest : long[], $dest_offset : int, $source : long[], $source_offset : int, $length : int)
.Ve
.PP
Copy source long array to destination long array with the each offset and a length.
.PP
If source data range and destination data overlap, the result is not guaranteed.
.PP
Destnation must be defined, otherwise a exception occurs.
.PP
Source must be defined, otherwise a exception occurs.
.PP
Length must be more than or equals to 0, otherwise a exception occurs.
.PP
Destnation offset + length must be within the range of the destnation array, otherwise a exception occurs.
.PP
Source offset + length must be within the range of the source array, otherwise a exception occurs.
.SS "memcpy_short"
.IX Subsection "memcpy_short"
.Vb 1
\&  static method memcpy_short : void ($dest : short[], $dest_offset : int, $source : short[], $source_offset : int, $length : int)
.Ve
.PP
Copy source short array to destination short array with the each offset and a length.
.PP
If source data range and destination data overlap, the result is not guaranteed.
.PP
Destnation must be defined, otherwise a exception occurs.
.PP
Source must be defined, otherwise a exception occurs.
.PP
Length must be more than or equals to 0, otherwise a exception occurs.
.PP
Destnation offset + length must be within the range of the destnation array, otherwise a exception occurs.
.PP
Source offset + length must be within the range of the source array, otherwise a exception occurs.
.SS "memmove_byte"
.IX Subsection "memmove_byte"
.Vb 1
\&  static method memmove_byte : void ($dest : byte[], $dest_offset : int, $source : byte[], $source_offset : int, $length : int)
.Ve
.PP
Copy source byte array to destination byte array with the each offset and a length.
.PP
Even if source data range and destination data overlap, the result is guaranteed.
.PP
Destnation must be defined, otherwise a exception occurs.
.PP
Source must be defined, otherwise a exception occurs.
.PP
Length must be more than or equals to 0, otherwise a exception occurs.
.PP
Destnation offset + length must be within the range of the destnation array, otherwise a exception occurs.
.PP
Source offset + length must be within the range of the source array, otherwise a exception occurs.
.SS "memmove_double"
.IX Subsection "memmove_double"
.Vb 1
\&  memmove_double : void ($dest : double[], $dest_offset : int, $source : double[], $source_offset : int, $length : int)
.Ve
.PP
Copy source double array to destination double array with the each offset and a length.
.PP
Even if source data range and destination data overlap, the result is guaranteed.
.PP
Destnation must be defined, otherwise a exception occurs.
.PP
Source must be defined, otherwise a exception occurs.
.PP
Length must be more than or equals to 0, otherwise a exception occurs.
.PP
Destnation offset + length must be within the range of the destnation array, otherwise a exception occurs.
.PP
Source offset + length must be within the range of the source array, otherwise a exception occurs.
.SS "memmove_float"
.IX Subsection "memmove_float"
.Vb 1
\&  static method memmove_float : void ($dest : float[], $dest_offset : int, $source : float[], $source_offset : int, $length : int)
.Ve
.PP
Copy source float array to destination float array with the each offset and a length.
.PP
Even if source data range and destination data overlap, the result is guaranteed.
.PP
Destnation must be defined, otherwise a exception occurs.
.PP
Source must be defined, otherwise a exception occurs.
.PP
Length must be more than or equals to 0, otherwise a exception occurs.
.PP
Destnation offset + length must be within the range of the destnation array, otherwise a exception occurs.
.PP
Source offset + length must be within the range of the source array, otherwise a exception occurs.
.SS "memmove_int"
.IX Subsection "memmove_int"
.Vb 1
\&  memmove_int : void ($dest : int[], $dest_offset : int, $source : int[], $source_offset : int, $length : int)
.Ve
.PP
Copy source int array to destination int array with the each offset and a length.
.PP
Even if source data range and destination data overlap, the result is guaranteed.
.PP
Destnation must be defined, otherwise a exception occurs.
.PP
Source must be defined, otherwise a exception occurs.
.PP
Length must be more than or equals to 0, otherwise a exception occurs.
.PP
Destnation offset + length must be within the range of the destnation array, otherwise a exception occurs.
.PP
Source offset + length must be within the range of the source array, otherwise a exception occurs.
.SS "memmove_long"
.IX Subsection "memmove_long"
.Vb 1
\&  memmove_long : void ($dest : long[], $dest_offset : int, $source : long[], $source_offset : int, $length : int)
.Ve
.PP
Copy source long array to destination long array with the each offset and a length.
.PP
Even if source data range and destination data overlap, the result is guaranteed.
.PP
Destnation must be defined, otherwise a exception occurs.
.PP
Source must be defined, otherwise a exception occurs.
.PP
Length must be more than or equals to 0, otherwise a exception occurs.
.PP
Destnation offset + length must be within the range of the destnation array, otherwise a exception occurs.
.PP
Source offset + length must be within the range of the source array, otherwise a exception occurs.
.SS "memmove_short"
.IX Subsection "memmove_short"
.Vb 1
\&  memmove_short : void ($dest : short[], $dest_offset : int, $source : short[], $source_offset : int, $length : int)
.Ve
.PP
Copy source short array to destination short array with the each offset and a length.
.PP
Even if source data range and destination data overlap, the result is guaranteed.
.PP
Destnation must be defined, otherwise a exception occurs.
.PP
Source must be defined, otherwise a exception occurs.
.PP
Length must be more than or equals to 0, otherwise a exception occurs.
.PP
Destnation offset + length must be within the range of the destnation array, otherwise a exception occurs.
.PP
Source offset + length must be within the range of the source array, otherwise a exception occurs.
.SS "substr"
.IX Subsection "substr"
.Vb 1
\&  static method substr : string ($string : string, $offset : int, $length : int)
.Ve
.PP
Get the substring of the string with the start offset and the length.
.SS "new_array_proto"
.IX Subsection "new_array_proto"
.Vb 1
\&  static method new_array_proto : oarray ($proto_array : oarray, $length : int)
.Ve
.PP
Create a new generic object array as the same type as the given array.
.SS "powi"
.IX Subsection "powi"
.Vb 1
\&  static method powi : int ($x : int, $y : int)
.Ve
.PP
Calculate the exponentiation.
.SS "powl"
.IX Subsection "powl"
.Vb 1
\&  static method powl : long ($x : long, $y : long)
.Ve
.PP
Calculate the exponentiation.
.SS "rand"
.IX Subsection "rand"
.Vb 1
\&  static method rand : double ();
.Ve
.PP
Get random number(0 <= random_number < 1). This is same as rand function of Perl language.
.PP
The first seed is initialized by epoch time automatically. If you set a seed manually, you can use <srand> class method.
.PP
This method is not thread safe because internaly this method use rand function of C language.
.SS "rindex"
.IX Subsection "rindex"
.Vb 1
\&  static method rindex : int ($string : string, $method_string : string, $offset : int)
.Ve
.PP
Same as \*(L"index\*(R" function except that the search is the last of the string.
.SS "sort_byte"
.IX Subsection "sort_byte"
.Vb 1
\&    static method sort_byte : void ($nums : byte[], $offset : int, $length : int, $comparator : Comparator::Byte)
.Ve
.PP
Sort byte array itself with a offset, a length, and a Comparator::Byte comparator.
.PP
Array must be not undef. Otherwise a exception occurs.
.PP
Offset must be more than or equals to 0. Otherwise a exception occurs.
.PP
Length must be more than or equals to 0. Otherwise a exception occurs.
.PP
Offset + Length must be in the array range. Otherwise a exception occurs.
.SS "sort_double"
.IX Subsection "sort_double"
.Vb 1
\&    static method sort_double : void ($nums : double[], $offset : int, $length : int, $comparator : Comparator::Double)
.Ve
.PP
Sort double array itself with a offset, a length, and a Comparator::Double comparator.
.PP
Array must be not undef. Otherwise a exception occurs.
.PP
Offset must be more than or equals to 0. Otherwise a exception occurs.
.PP
Length must be more than or equals to 0. Otherwise a exception occurs.
.PP
Offset + Length must be in the array range. Otherwise a exception occurs.
.SS "sort_float"
.IX Subsection "sort_float"
.Vb 1
\&    static method static method sort_float : void ($nums : float[], $offset : int, $length : int, $comparator : Comparator::Float)
.Ve
.PP
Sort float array itself with a offset, a length, and a Comparator::Float comparator.
.PP
Array must be not undef. Otherwise a exception occurs.
.PP
Offset must be more than or equals to 0. Otherwise a exception occurs.
.PP
Length must be more than or equals to 0. Otherwise a exception occurs.
.PP
Offset + Length must be in the array range. Otherwise a exception occurs.
.SS "sort_int"
.IX Subsection "sort_int"
.Vb 1
\&    static method sort_int : void ($nums : int[], $offset : int, $length : int, $comparator : Comparator::Int)
.Ve
.PP
Sort int array itself with a offset, a length, and a Comparator::Int comparator.
.PP
Array must be not undef. Otherwise a exception occurs.
.PP
Offset must be more than or equals to 0. Otherwise a exception occurs.
.PP
Length must be more than or equals to 0. Otherwise a exception occurs.
.PP
Offset + Length must be in the array range. Otherwise a exception occurs.
.SS "sort_long"
.IX Subsection "sort_long"
.Vb 1
\&    static method sort_long : void ($nums : long[], $offset : int, $length : int, $comparator : Comparator::Long)
.Ve
.PP
Sort long array itself with a offset, a length, and a Comparator::Long comparator.
.PP
Array must be not undef. Otherwise a exception occurs.
.PP
Offset must be more than or equals to 0. Otherwise a exception occurs.
.PP
Length must be more than or equals to 0. Otherwise a exception occurs.
.PP
Offset + Length must be in the array range. Otherwise a exception occurs.
.SS "sort_object"
.IX Subsection "sort_object"
.Vb 1
\&    static method sort_object : void ($objs : oarray, $offset : int, $length : int, $comparator : Comparator::Object)
.Ve
.PP
Sort object array itself with a offset, a length, and a Comparator::Object comparator.
.PP
Array must be not undef. Otherwise a exception occurs.
.PP
Offset must be more than or equals to 0. Otherwise a exception occurs.
.PP
Length must be more than or equals to 0. Otherwise a exception occurs.
.PP
Offset + Length must be in the array range. Otherwise a exception occurs.
.SS "sort_short"
.IX Subsection "sort_short"
.Vb 1
\&    static method sort_short : void ($nums : short[], $offset : int, $length : int, $comparator : Comparator::Short)
.Ve
.PP
Sort short array itself with a offset, a length, and a Comparator::Short comparator.
.PP
Array must be not undef. Otherwise a exception occurs.
.PP
Offset must be more than or equals to 0. Otherwise a exception occurs.
.PP
Length must be more than or equals to 0. Otherwise a exception occurs.
.PP
Offset + Length must be in the array range. Otherwise a exception occurs.
.SS "sort_string"
.IX Subsection "sort_string"
.Vb 1
\&    static method sort_string : void ($nums : string[], $offset : int, $length : int, $comparator : Comparator::Double)
.Ve
.PP
Sort string array itself with a offset, a length, and a Comparator::String comparator.
.PP
Array must be not undef. Otherwise a exception occurs.
.PP
Offset must be more than or equals to 0. Otherwise a exception occurs.
.PP
Length must be more than or equals to 0. Otherwise a exception occurs.
.PP
Offset + Length must be in the array range. Otherwise a exception occurs.
.SS "split"
.IX Subsection "split"
.Vb 1
\&  static method split : string[] ($sep : string, $string : string)
.Ve
.PP
Split a string by the specific separator.
.SS "sprintf"
.IX Subsection "sprintf"
.Vb 1
\&  static method sprintf : string ($format : string, $args : object[]...)
.Ve
.PP
Create a formatted string with the format and the embdded values.
.PP
\fIFormat Options\fR
.IX Subsection "Format Options"
.PP
Zero Padding
.IX Subsection "Zero Padding"
.PP
.Vb 2
\&  # Format
\&  "%05d"
\&  
\&  # Value
\&  123
\&  
\&  # Output
\&  "00123"
.Ve
.PP
Plus
.IX Subsection "Plus"
.PP
.Vb 2
\&  # Format
\&  %+d
\&  
\&  # Value
\&  123
\&  
\&  # Output
\&  "+123"
.Ve
.PP
Left Justified
.IX Subsection "Left Justified"
.PP
.Vb 2
\&  # Format
\&  "%\-5d"
\&  
\&  # Value
\&  123
\&  
\&  # Output
\&  "123  "
.Ve
.PP
Number of Decimal Places Displayed
.IX Subsection "Number of Decimal Places Displayed"
.PP
.Vb 2
\&  # Format
\&  "%.2f"
\&  
\&  # Value
\&  3.1415
\&  
\&  # Output
\&  "3.14"
.Ve
.SS "srand"
.IX Subsection "srand"
.Vb 1
\&  static method srand : void ($seed : long);
.Ve
.PP
Sets random number seed for the \f(CW\*(C`crand\*(C'\fR or \f(CW\*(C`rand\*(C'\fR class method.
.SS "to_double"
.IX Subsection "to_double"
.Vb 1
\&  static method to_double : double ($string : string);
.Ve
.PP
Convert the string to float value.
.PP
Format is [' ' or '\et' or '\en' or '\ev' or '\ef' or '\er'][+ or \-][zero more than 0\-9][.][zero more than 0\-9][e or E[+ or \-]zero more than 0\-9]. Internal of [] is optional.
.PP
If the convertion fails, a exception occuer.
.PP
.Vb 2
\&  my $string = "1.25";
\&  my $num = to_double($string);
.Ve
.SS "to_float"
.IX Subsection "to_float"
.Vb 1
\&  static method to_float : float ($string : string);
.Ve
.PP
Convert the string to float value.
.PP
Format is [' ' or '\et' or '\en' or '\ev' or '\ef' or '\er'][+ or \-][zero more than 0\-9][.][zero more than 0\-9][e or E[+ or \-]zero more than 0\-9]. Internal of [] is optional.
.PP
If the convertion fails, a exception occuer.
.PP
.Vb 2
\&  my $string = "1.25";
\&  my $num = to_float($string);
.Ve
.SS "to_int"
.IX Subsection "to_int"
.Vb 1
\&  static method to_int : int ($string : string, $digit : int);
.Ve
.PP
Convert the string to a int value. This method is same as to_int_with_base($string, 10).
.PP
.Vb 2
\&  my $string = "\-2147483648";
\&  my $num = to_int($string);
.Ve
.SS "to_int_with_base"
.IX Subsection "to_int_with_base"
.Vb 1
\&  static method to_int_with_base : int ($string : string, $digit : int);
.Ve
.PP
Convert the string to a int value with a digit(2, 8, 10, 16).
.PP
Format is [' ' or '\et' or '\en' or '\ev' or '\ef' or '\er'][+ or \-][0][x][one more than 0\-9]. Internal of [] is optional.
.PP
If convertion fails, a exception occuer.
.PP
.Vb 2
\&  my $string = "\-2147483648";
\&  my $num = to_int_with_base($string, 10);
.Ve
.SS "to_long"
.IX Subsection "to_long"
.Vb 1
\&  static method to_long : long ($string : string);
.Ve
.PP
Convert the string to long value. This method is same as to_long($string, 10).
.PP
.Vb 2
\&  my $string = "\-9223372036854775808";
\&  my $num = to_long($string);
.Ve
.SS "to_long_with_base"
.IX Subsection "to_long_with_base"
.Vb 1
\&  static method to_long_with_base : long ($string : string, $digit : int);
.Ve
.PP
Convert the string to long value with digit(2, 8, 10, 16).
.PP
Format is [' ' or '\et' or '\en' or '\ev' or '\ef' or '\er'][+ or \-][0][x][zero more than 0\-9]. Internal of [] is optional.
.PP
If the convertion fails, a exception occuer.
.PP
.Vb 2
\&  my $string = "\-9223372036854775808";
\&  my $num = to_long_with_base($string, 10);
.Ve
.SS "to_lower"
.IX Subsection "to_lower"
.Vb 1
\&  static method to_lower : int ($code_point : int)
.Ve
.PP
Convert uppercase letter('A'\-'Z') to lowercase. If the character is not uppercase letter, return the character.
.SS "to_upper"
.IX Subsection "to_upper"
.Vb 1
\&  static method to_upper : int ($code_point : int)
.Ve
.PP
Convert lowercase letter('a'\-'z') to lowercase. If the character is not uppercase letter, return the character.
.SS "trim_ascii_space"
.IX Subsection "trim_ascii_space"
.Vb 1
\&  static method trim_ascii_space : string ($string : string)
.Ve
.PP
Remove right and left spaces of the string. These spaces is ascii standard spaces which can be checked by \f(CW\*(C`is_space\*(C'\fR method.
.PP
If the argument string is undef, return undef.
.SS "uc"
.IX Subsection "uc"
.Vb 1
\&  static method uc : string ($string : string)
.Ve
.PP
Convert a lowercase string to a uppercase string.
.PP
If the string is undef, a exception occur.
.SS "ucfirst"
.IX Subsection "ucfirst"
.Vb 1
\&  static method ucfirst : string ($string : string)
.Ve
.PP
Convert the first character of a string to a uppercase character.
.PP
If the string is undef, a exception occur.
