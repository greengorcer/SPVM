.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "SPVM::Document::NativeAPI 3"
.TH SPVM::Document::NativeAPI 3 "2022-01-31" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
SPVM::Document::NativeAPI \- SPVM Native APIs
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fB\s-1SPVM\s0 Native APIs\fR are public APIs that are used in native modules. \s-1SPVM\s0 Native APIs are writen in C language.
.PP
This document describes the usage of \s-1SPVM\s0 Native APIs, and also the way to write native methods and native modules.
.PP
Native methods can be written by C language or \*(C+. If the rule of the function call is same as C, you can use any language, for example, CUDA/nvcc.
.SH "Native Methods"
.IX Header "Native Methods"
.SS "Native Method Declarations"
.IX Subsection "Native Method Declarations"
A native method declaration are written using the method descriptor \*(L"native\*(R" in a \s-1SPVM\s0 module file. The method can't have the block. it ends with a semicolon.
.PP
.Vb 4
\&  # SPVM/Foo/Bar.spvm
\&  class Foo::Bar {
\&    native static method sum : int ($num1 : int, $num2 : int);
\&  }
.Ve
.SS "Native Config Files"
.IX Subsection "Native Config Files"
A native config file is needed for the native module. The extension is \f(CW\*(C`config\*(C'\fR. Put the config file in the same directory as the \s-1SPVM\s0 module.
.PP
.Vb 2
\&  # Native configuration file for Foo::Bar module
\&  SPVM/Foo/Bar.config
.Ve
.PP
If the native config file does not exist, an exception occurs.
.PP
Native config files are writen by Perl. It must return Builder::Config object, otherwise an exception occurs.
.PP
I show some examples of native config files.
.PP
\fI\s-1GNU99\s0 Config Files\fR
.IX Subsection "GNU99 Config Files"
.PP
.Vb 3
\&  # GNU99 Config File
\&  use strict;
\&  use warnings;
\&
\&  use SPVM::Builder::Config;
\&  my $config = SPVM::Builder::Config\->new_gnu99;
\&
\&  $config;
.Ve
.PP
\fIC99 Config Files\fR
.IX Subsection "C99 Config Files"
.PP
.Vb 3
\&  # C99 Config File
\&  use strict;
\&  use warnings;
\&
\&  use SPVM::Builder::Config;
\&  my $config = SPVM::Builder::Config\->new_c99;
\&
\&  $config;
.Ve
.PP
\fIC11 Config Files\fR
.IX Subsection "C11 Config Files"
.PP
.Vb 3
\&  # C11 Config File
\&  use strict;
\&  use warnings;
\&
\&  use SPVM::Builder::Config;
\&  my $config = SPVM::Builder::Config\->new_c;
\&
\&  $config\->set_std(\*(Aqc11\*(Aq);
\&
\&  $config;
.Ve
.PP
\fI\*(C+ Config Files\fR
.IX Subsection " Config Files"
.PP
.Vb 3
\&  # C++ Config File
\&  use strict;
\&  use warnings;
\&
\&  use SPVM::Builder::Config;
\&  my $config = SPVM::Builder::Config\->new_cpp;
\&
\&  $config;
.Ve
.PP
\fI\*(C+11 Config Files\fR
.IX Subsection "11 Config Files"
.PP
.Vb 3
\&  # C++11 Config File
\&  use strict;
\&  use warnings;
\&
\&  use SPVM::Builder::Config;
\&  my $config = SPVM::Builder::Config\->new_cpp;
\&
\&  $config\->set_std(\*(Aqc++11\*(Aq);
\&
\&  $config;
.Ve
.PP
\fICUDA/nvcc Config Files\fR
.IX Subsection "CUDA/nvcc Config Files"
.PP
.Vb 2
\&  use strict;
\&  use warnings;
\&
\&  my $config = SPVM::Builder::Config\->new;
\&
\&  # Compiler and Linker common
\&  my @ccldflags = qw(\-\-compiler\-options \*(Aq\-fPIC\*(Aq);
\&
\&  # Compiler
\&  $config\->cc(\*(Aqnvcc\*(Aq);
\&  $config\->add_ccflags(@ccldflags);
\&  $config\->ext(\*(Aqcu\*(Aq);
\&
\&  # Linker
\&  $config\->ld(\*(Aqnvcc\*(Aq);
\&  $config\->add_ldflags(\*(Aq\-shared\*(Aq, @ccldflags);
\&
\&  $config;
.Ve
.PP
\fIThe Options of Config Files\fR
.IX Subsection "The Options of Config Files"
.PP
\&\fBOutput the commands of the compililation and the link:\fR
.PP
.Vb 2
\&  use strict;
\&  use warnings;
\&
\&  use SPVM::Builder::Config;
\&  my $config = SPVM::Builder::Config\->new_gnu99;
\&
\&  # Output the commands of the compililation and link
\&  $config\->quiet(0);
\&
\&  $config;
.Ve
.PP
\&\fBForce the compilation and the link:\fR
.PP
.Vb 2
\&  use strict;
\&  use warnings;
\&
\&  use SPVM::Builder::Config;
\&  my $config = SPVM::Builder::Config\->new_gnu99;
\&
\&  # Force the compilation and the link
\&  $config\->force(1);
\&
\&  $config;
.Ve
.SS "Native Method Definitions"
.IX Subsection "Native Method Definitions"
A native method definition is written in the native module file. Native module files are writen C, \*(C+, or the language that the rule of function call is same as C.
.PP
The extension is defined ext method in the config file.
.PP
.Vb 1
\&  $config\->ext(\*(Aqcpp\*(Aq);
.Ve
.PP
Generally the extension of C is \f(CW\*(C`c\*(C'\fR, \*(C+ is \f(CW\*(C`cpp\*(C'\fR, CUDA/nvcc is \f(CW\*(C`cu\*(C'\fR.
.PP
Put the config file in the same directory as the \s-1SPVM\s0 module.
.PP
.Vb 2
\&  # Native module file for Foo::Bar module
\&  SPVM/Foo/Bar.c
.Ve
.PP
This is an example of \s-1SPVM\s0 natvie module. The config file is \s-1GNU99\s0.
.PP
.Vb 1
\&  #include "spvm_native.h"
\&
\&  int32_t SPVM_\|_Foo_\|_Bar_\|_sum(SPVM_ENV* env, SPVM_VALUE* stack) {
\&
\&    int32_t num1 = stack[0].ival;
\&    int32_t num2 = stakc[1].ival;
\&
\&    int32_t total = num1 + num2;
\&
\&    stack[0].ival = total;
\&
\&    return 0;
\&  }
.Ve
.PP
\fIThe header of Native APIs\fR
.IX Subsection "The header of Native APIs"
.PP
Include \f(CW\*(C`spvm_native.h\*(C'\fR at the beginning of the natvie module. \f(CW\*(C`spvm_native.h\*(C'\fR is the header of Native APIs. It defines the native APIs and the data structures, such as \f(CW\*(C`SPVM_ENV\*(C'\fR, \f(CW\*(C`SPVM_VALUE\*(C'\fR.
.PP
\fINative Function Names\fR
.IX Subsection "Native Function Names"
.PP
A \s-1SPVM\s0 native method have a native function.
.PP
Native funtions have the rule of the names. For example, the name is \f(CW\*(C`SPVM_\|_Foo_\|_Bar_\|_sum\*(C'\fR.
.PP
.Vb 1
\&  SPVM_\|_Foo_\|_Bar_\|_sum
.Ve
.PP
This name is write by the following rules.
.PP
The function name starts with \*(L"SPVM_\|_\*(R".
.PP
Followed by the class name \*(L"Foo_\|_Bar\*(R", that is replaced \*(L"::\*(R" with \*(L"_\|_\*(R".
.PP
Followed by \*(L"_\|_\*(R".
.PP
Followed by the method name \*(L"sum\*(R".
.PP
If the name is invalid, a compilation error occurs.
.PP
\fINative Function Arguments\fR
.IX Subsection "Native Function Arguments"
.PP
A native function has two arguments.
.PP
The first argument is \f(CW\*(C`env\*(C'\fR that type is \f(CW\*(C`SPVM_ENV*\*(C'\fR. This has the information of the runtime environment.
.PP
The second argument is \f(CW\*(C`stack\*(C'\fR that type is \f(CW\*(C`SPVM_VALUE*\*(C'\fR. This is used for getting the values of the arguments and setting the return value.
.PP
.Vb 1
\&  int32_t SPVM_\|_Foo_\|_Bar_\|_sum(SPVM_ENV* env, SPVM_VALUE* stack) {
\&  
\&  }
.Ve
.PP
In the above example, \s-1SPVM\s0 native method takes two arguments that type is \f(CW\*(C`int\*(C'\fR. It calculates the sum of the tow values, and returns the total value.
.PP
.Vb 1
\&  #include "spvm_native.h"
\&
\&  int32_t SPVM_\|_Foo_\|_Bar_\|_sum(SPVM_ENV* env, SPVM_VALUE* stack) {
\&
\&    int32_t num1 = stack[0].ival;
\&    int32_t num2 = stakc[1].ival;
\&
\&    int32_t total = num1 + num2;
\&
\&    stack[0].ival = total;
\&
\&    return 0;
\&  }
.Ve
.PP
\fINative Function Return Value\fR
.IX Subsection "Native Function Return Value"
.PP
The type of return value of native function is \f(CW\*(C`int32_t\*(C'\fR. If the method succeeds, the method must return \f(CW1\fR.  If the method fails, the method must return \f(CW0\fR.
.PP
Note that this is \fBnot\fR the return value of the \s-1SPVM\s0 native method, such as the total value in the above example.
.SS "Compile Native Method"
.IX Subsection "Compile Native Method"
Native methods are compiled into a shared libraries. teay are shared libraries (.so) on Unix/Linux, dynamic link libraries (.dll) on Windows or etc corresponding to your os.
.PP
The compilation is done when \s-1SPVM\s0 is compiled. The build directory must exist, otherwise an exception occures.
.PP
The default build directory is the \*(L"~/.spvm_build\*(R" directory in the directory containing the executed Perl script, and can be changed with the environment variable \*(L"\s-1SPVM_BUILD_DIR\*(R".\s0
.PP
If you want to use \s-1SPVM\s0 Native Method from Perl, create a \*(L"~/.spvm_build\*(R" directory in the directory where the executed Perl script exists.
.PP
.Vb 1
\&  ~/.spvm_build
.Ve
.PP
The generated object files exists under \*(L"work/object\*(R" under the build directory. The object file name is the name which the extension of the \s-1SPVM\s0 module name is changed to \*(L".o\*(R".
.PP
.Vb 1
\&  ~/.spvm_build/work/object/Foo/Bar.o
.Ve
.PP
The generated shared libraries exists under \*(L"work/lib\*(R" under the build directory. The name of shared library is the name which the extension of the \s-1SPVM\s0 module name is changed to \*(L".so\*(R", or etc corresponding to your os.
.PP
.Vb 2
\&  # Unix/Linux
\&  ~/.spvm_build/work/object/Foo/Bar.so
\&
\&  # Windows
\&  ~/.spvm_build/work/object/Foo/Bar.dll
.Ve
.SS "Stack"
.IX Subsection "Stack"
The stack is the second argument of the definition of the Native Method. This is called stack. Stack is used getting arguments and return the value.
.PP
.Vb 1
\&  int32_t SPVM_\|_Foo_\|_Bar_\|_sum(SPVM_ENV* env, SPVM_VALUE* stack) {
\&
\&  }
.Ve
.PP
\&\s-1SPVM_VALUE\s0 is a union type of C language to store \s-1SPVM\s0 values. You can save integral value, floating point value, object value, and reference value to it.
.PP
For example, to get the value of the first \fBargument\fR\|(0th) of int type, write as follows.
.PP
.Vb 1
\&  int32_t args0 = stack[0].ival;
.Ve
.PP
For example, to get the value of the second \fBargument\fR\|(1th) of long type, write as follows.
.PP
.Vb 1
\&  int64_t args1 = stack[1].lval;
.Ve
.PP
For example, to return a value of double type, write as follows.
.PP
.Vb 1
\&  stack[0].dval = 0.5;
.Ve
.SS "Getting Arguments"
.IX Subsection "Getting Arguments"
\fIGet byte type argument\fR
.IX Subsection "Get byte type argument"
.PP
To get the \s-1SPVM\s0 byte argument, access the bval field. Assign to the C language int8_t type.
.PP
.Vb 1
\&  int8_t args0 = stack[0].bval;
.Ve
.PP
\fIGet short type argument\fR
.IX Subsection "Get short type argument"
.PP
To get the short argument of \s-1SPVM,\s0 access the sval field. Assign it to the C language int16_t type.
.PP
.Vb 1
\&  int16_t args0 = stack[0].sval;
.Ve
.PP
\fIGet int type argument\fR
.IX Subsection "Get int type argument"
.PP
To get the \s-1SPVM\s0 int type argument, access the ival field. Assign to the C language int32_t type.
.PP
.Vb 1
\&  int32_t args0 = stack[0].ival;
.Ve
.PP
\fIGet long type argument\fR
.IX Subsection "Get long type argument"
.PP
To get the long argument of \s-1SPVM,\s0 access the lval field. Assign to the C language int64_t type.
.PP
.Vb 1
\&  int64_t args0 = stack[0].lval;
.Ve
.PP
\fIGet float type argument\fR
.IX Subsection "Get float type argument"
.PP
To get the \s-1SPVM\s0 float type argument, access the fval field. Assign to float type of C language.
.PP
.Vb 1
\&  float args0 = stack[0].fval;
.Ve
.PP
\fIGet double type argument\fR
.IX Subsection "Get double type argument"
.PP
To get the \s-1SPVM\s0 double argument, access the dval field. Assign to the C language double type.
.PP
.Vb 1
\&  double args0 = stack[0].dval;
.Ve
.PP
\fIGet object type argument\fR
.IX Subsection "Get object type argument"
.PP
To get the \s-1SPVM\s0 object type argument, access the oval field. Assign it to void* type in C language.
.PP
.Vb 1
\&  void* args0 = stack[0].oval;
.Ve
.PP
\fIGet byte Reference Type Argument\fR
.IX Subsection "Get byte Reference Type Argument"
.PP
If you get \s-1SPVM\s0 byte Reference Type argument, use \*(L"bref\*(R" field. it can be assinged to the value of C language int8_t* type.
.PP
.Vb 1
\&  int8_t* args0 = stack[0].bref;
.Ve
.PP
\fIGet short Reference Type Argument\fR
.IX Subsection "Get short Reference Type Argument"
.PP
If you get \s-1SPVM\s0 short Reference Type argument, use \*(L"sref\*(R" field. it can be assinged to the value of C language int16_t* type.
.PP
.Vb 1
\&  int16_t* args0 = stack[0].sref;
.Ve
.PP
\fIGet int Reference Type Argument\fR
.IX Subsection "Get int Reference Type Argument"
.PP
If you get \s-1SPVM\s0 int Reference Type argument, use \*(L"iref\*(R" field. it can be assinged to the value of C language int32_t* type.
.PP
.Vb 1
\&  int32_t* args0 = stack[0].iref;
.Ve
.PP
\fIGet long Reference Type Argument\fR
.IX Subsection "Get long Reference Type Argument"
.PP
If you get \s-1SPVM\s0 long Reference Type argument, use \*(L"lref\*(R" field. it can be assinged to the value of C language int64_t* type.
.PP
.Vb 1
\&  int64_t* args0 = stack[0].lref;
.Ve
.PP
\fIGet float Reference Type Argument\fR
.IX Subsection "Get float Reference Type Argument"
.PP
If you get \s-1SPVM\s0 float Reference Type argument, use \*(L"fref\*(R" field. it can be assinged to the value of C language float* type.
.PP
.Vb 1
\&  float* args0 = stack[0].fref;
.Ve
.PP
\fIGet double Reference Type Argument\fR
.IX Subsection "Get double Reference Type Argument"
.PP
If you get \s-1SPVM\s0 double Reference Type Argument, use \*(L"dref\*(R" field. it can be assinged to the value of C language double* type.
.PP
.Vb 1
\&  double* args0 = stack[0].dref;
.Ve
.PP
\fIGet multiple numeric type arguments\fR
.IX Subsection "Get multiple numeric type arguments"
.PP
In a Native Method, multiple numeric type arguments are assigned to the coresponding multiple arguments.
.PP
For example, In the case of the argument values of Complex_2d type, you can get them by the following way.
.PP
.Vb 2
\&  double args_re = stack[0].dval;
\&  double args_im = stack[1].dval;
.Ve
.PP
Note that you cannot access the values by the field name of Complex_2d.
.SS "Return Value"
.IX Subsection "Return Value"
\fISet return value of byte type\fR
.IX Subsection "Set return value of byte type"
.PP
Use \f(CW\*(C`bval\*(C'\fR field of \f(CW\*(C`SPVM_VALUE\*(C'\fR to set a return value which type of \s-1SPVM\s0 is \f(CW\*(C`byte\*(C'\fR. This is corresponding to \f(CW\*(C`int8_t\*(C'\fR type of C language.
.PP
.Vb 2
\&  int8_t retval;
\&  stack[0].bval = retval;
.Ve
.PP
\fISet return value of short type\fR
.IX Subsection "Set return value of short type"
.PP
Use \f(CW\*(C`sval\*(C'\fR field of \f(CW\*(C`SPVM_VALUE\*(C'\fR to set a return value which type of \s-1SPVM\s0 is \f(CW\*(C`short\*(C'\fR. This is corresponding to \f(CW\*(C`int16_t\*(C'\fR type of C language.
.PP
.Vb 2
\&  int16_t retval;
\&  stack[0].sval = retval;
.Ve
.PP
\fISet return value of int type\fR
.IX Subsection "Set return value of int type"
.PP
Use \f(CW\*(C`ival\*(C'\fR field of \f(CW\*(C`SPVM_VALUE\*(C'\fR to set a return value which type of \s-1SPVM\s0 is \f(CW\*(C`int\*(C'\fR. This is corresponding to \f(CW\*(C`int32_t\*(C'\fR type of C language.
.PP
.Vb 2
\&  int32_t retval;
\&  stack[0].ival = retval;
.Ve
.PP
\fISet long type return value\fR
.IX Subsection "Set long type return value"
.PP
Use \f(CW\*(C`lval\*(C'\fR field of \f(CW\*(C`SPVM_VALUE\*(C'\fR to set a return value which type of \s-1SPVM\s0 is \f(CW\*(C`long\*(C'\fR. This is corresponding to \f(CW\*(C`int64_t\*(C'\fR type of C language.
.PP
.Vb 2
\&  int64_t retval;
\&  stack[0].lval = retval;
.Ve
.PP
\fISet return value of float type\fR
.IX Subsection "Set return value of float type"
.PP
Use \f(CW\*(C`fval\*(C'\fR field of \f(CW\*(C`SPVM_VALUE\*(C'\fR to set a return value which type of \s-1SPVM\s0 is \f(CW\*(C`float\*(C'\fR. This is corresponding to \f(CW\*(C`float\*(C'\fR type of C language.
.PP
.Vb 2
\&  float retval;
\&  stack[0].fval = retval;
.Ve
.PP
\fISet return value of double type\fR
.IX Subsection "Set return value of double type"
.PP
Use \f(CW\*(C`dval\*(C'\fR field of \f(CW\*(C`SPVM_VALUE\*(C'\fR to set a return value which type of \s-1SPVM\s0 is \f(CW\*(C`double\*(C'\fR. This is corresponding to \f(CW\*(C`double\*(C'\fR type of C language.
.PP
.Vb 2
\&  double retval;
\&  stack[0].dval = retval;
.Ve
.PP
\fISet return value of object type\fR
.IX Subsection "Set return value of object type"
.PP
Use \f(CW\*(C`oval\*(C'\fR field of \f(CW\*(C`SPVM_VALUE\*(C'\fR to set a return value which type of \s-1SPVM\s0 is object. This is corresponding to \f(CW\*(C`void*\*(C'\fR type of C language.
.PP
.Vb 2
\&  void* retval;
\&  stack[0].oval = retval;
.Ve
.PP
\fISet multiple numeric return value\fR
.IX Subsection "Set multiple numeric return value"
.PP
If you set multiple numeric return value in native method, set multiple return values.
.PP
For example, in the case of Complex_2d, do the following.
.PP
.Vb 4
\&  double retval_x;
\&  double retval_y;
\&  stack[0].dval = retval_x;
\&  stack[1].dval = retval_y;
.Ve
.SS "Call \s-1SPVM\s0 Method"
.IX Subsection "Call SPVM Method"
If you want to call a method, you get a method id using get_class_method_id or get_instance_method_id.
.PP
get_class_method_id get a method id of a class method.
.PP
get_instance_method_id get a method id of a instance method.
.PP
.Vb 2
\&  // Get method id of class method
\&  int32_t method_id = env\->get_class_method_id(env, "Foo", "sum", "int(int,int)");
\&
\&  // Get method id of instance method
\&  int32_t method_id = env\->get_instance_method_id(env, object, "sum", "int(int,int)");
.Ve
.PP
If method_id is less than 0, it means that the method was not found. It is safe to handle exceptions as follows.
.PP
.Vb 1
\&  if (method_id < 0) { return env\->die(env, "Can\*(Aqt find method id", "Foo/Bar.c", _\|_LINE_\|_); }
.Ve
.PP
Set the \s-1SPVM\s0 method argument to stack before calling the method.
.PP
.Vb 2
\&  stack[0].ival = 1;
\&  stack[0].ival = 2;
.Ve
.PP
To call a \s-1SPVM\s0 method, use the <a href=\*(L"#native\-api\-native\-sub\-api\-call_spvm_method\*(R">call_spvm_method</a> function.
.PP
.Vb 1
\&  int32_t exception_flag = env\->call_spvm_method(env, method_id, stack);
.Ve
.PP
Nonzero if the method raised an exception, 0 if no exception occurred.
.PP
The return value of the method is stored in the first element of the stack.
.PP
.Vb 1
\&  int32_t total = stack[0].ival;
.Ve
.SS "Native Method Scope"
.IX Subsection "Native Method Scope"
Native method are entirely enclosed in scope.
.PP
Objects added to the mortal stack will automatically have their reference count decremented by 1 when the Native Method ends. When the reference count reaches 0, it is released.
.PP
Use push_mortal to add objects to the mortal stack.
.PP
.Vb 1
\&  env\->push_mortal(env, object);
.Ve
.PP
Native APIs that normally create an object such as \*(L"new_object\*(R" will add the automatically created object to the mortal stack so you don't need to use this.
.PP
Use \*(L"enter_scope\*(R" to create a scope. The return value is the \s-1ID\s0 of that scope.
.PP
.Vb 1
\&  int32_t scope_id = env\->enter_scope (env);
.Ve
.PP
Use \*(L"leave_scope\*(R" to leave the scope. For the argument, it is necessary to specify the scope \s-1ID\s0 obtained in \*(L"enter_scope\*(R".
.PP
.Vb 1
\&  env\->leave_scope(env, scope_id);
.Ve
.PP
Use \*(L"remove_mortal\*(R" to remove the object from the mortal stack. For the argument, specify the scope \s-1ID\s0 obtained by \*(L"enter_scope\*(R" and the object you want to remove. The object is removed from the mortal stack and the reference count is automatically decremented by 1. When the reference count reaches 0, it is released.
.PP
.Vb 1
\&  env\->remove_mortal(env, scope_id, object);
.Ve
.PP
Information about the mortal stack is stored in env.
.SS "Exception in Native Method"
.IX Subsection "Exception in Native Method"
In the Native Method, it is the return value that indicates whether an exception has occurred.
.PP
.Vb 1
\&  return 0;
\&
\&  return 1;
.Ve
.PP
If no exception occurs, \*(L"0\*(R" is returned. This is defined as \*(L"0\*(R".
.PP
If an exception occurs, \*(L"1\*(R" is returned. It is defined as a value other than \*(L"0\*(R".
.PP
If you want to set the exception message yourself, you can create an exception message with \*(L"new_string_nolen\*(R" and set it with \*(L"set_exception\*(R".
.PP
.Vb 2
\&  env\->set_exception(env, env\->new_string_nolen(env, "Exception occur");
\&  return 1;
.Ve
.PP
If no exception message is set, a default exception message will be set.
.PP
Usually, die  is defined to make it easier to use, so it is better to use this.
.PP
.Vb 1
\&  return env\->die("Error. Values must be %d and %d", 3, 5, "Foo/Bar.c", _\|_LINE_\|_);
.Ve
.PP
die can be used in the same way as the C language sprintf function. Be sure to include this file name in the second from the end, and the line number in the last argument. If the message exceeds 255 bytes, the excess is truncated.
.PP
The exception is stored in env.
.SS "Pointer Type"
.IX Subsection "Pointer Type"
There is a type called pointer type in \s-1SPVM,\s0 but I will explain how to use it.
.PP
The pointer type definition specifies the pointer_t descriptor in the \s-1SPVM\s0 class definition. Pointer types cannot have field definitions. This example describes how to use the C standard \*(L"struct tm\*(R" as a pointer type.
.PP
.Vb 2
\&  # SPVM/MyTimeInfo.spvm
\&  class MyTimeInfo : pointer_t {
\&
\&    # Constructor
\&    native static method new : MyTimeInfo ();
\&
\&    # Get second
\&    native method sec : int ();
\&
\&    # Destructor
\&    native method DESTROY : ();
\&  }
.Ve
.PP
It defines a new constructor, a method that takes seconds information called sec, and a destructor called \s-1DESTROY.\s0 These are Native Method.
.PP
Next is the definition on the C language side.
.PP
.Vb 1
\&  # SPVM/MyTimeInfo.c
\&
\&  int32_t SPVM_\|_MyTimeInfo_\|_new(SPVM_ENV* env, SPVM_VALUE* stack) {
\&
\&    // Alloc strcut tm
\&    void* tm_ptr = env\->alloc_memory_block_zero (sizeof (struct tm));
\&
\&    // Create strcut tm instance
\&    void* tm_obj = env\->new_pointer(env, "MyTimeInfo", tm_ptr);
\&
\&    stack[0].oval = tm_obj;
\&
\&    return 0;
\&  }
\&
\&  int32_t SPVM_\|_MyTimeInfo_\|_sec(SPVM_ENV* env, SPVM_VALUE* stack) {
\&    void* tm_obj = stack[0].oval;
\&
\&    strcut tm* tm_ptr = (struct tm*) env\->get_pointer(env, tm_obj);
\&
\&    stack[0].ival = tm_ptr\-> tm_sec;
\&
\&    return 0;
\&  }
\&
\&  int32_t SPVM_\|_MyTimeInfo_\|_DESTROY(SPVM_ENV* env, SPVM_VALUE* stack) {
\&
\&    void* tm_obj = stack[0].oval;
\&    strcut tm* tm_ptr = (struct tm*) env\->get_pointer(env, tm_obj);
\&
\&    env\->free_memory_block (tm_ptr);
\&
\&    return 0;
\&  }
.Ve
.PP
In the constructor new, the memory of \*(L"struct tm\*(R" is first allocated by the alloc_memory_block_zero function. This is a function that reserves one memory block in \s-1SPVM.\s0 Similar to malloc, this function increments the memory block count by one, making it easier to spot memory leaks.
.PP
.Vb 2
\&  // Alloc strcut tm
\&  void* tm_ptr = env\->alloc_memory_block_zero (sizeof (struct tm));
.Ve
.PP
Next, use the new_pointer function to create a new pointer type object with MyTimeInfo associated with it in the allocated memory.
.PP
.Vb 2
\&  // Create strcut tm instance
\&  void* tm_obj = env\->new_pointer(env, "MyTimeInfo", tm_ptr);
.Ve
.PP
If you return this as a return value, the constructor is complete.
.PP
.Vb 1
\&  stack[0].ival = tm_ptr\-> tm_sec;
\&  
\&  return 0;
.Ve
.PP
Next, let's get the value of tm_sec. sec method. The get_pointer function can be used to get a pointer to the memory allocated as a \*(L"struct tm\*(R" from a pointer type object.
.PP
.Vb 1
\&  void* tm_obj = stack[0].oval;
\&
\&  strcut tm* tm_ptr = (struct tm*) env\->get_pointer(env, tm_obj);
\&
\&  stack[0].ival = tm_ptr\-> tm_sec;
.Ve
.PP
The last is the destructor. Be sure to define a destructor, as the allocated memory will not be released automatically.
.PP
.Vb 1
\&  int32_t SPVM_\|_MyTimeInfo_\|_DESTROY(SPVM_ENV* env, SPVM_VALUE* stack) {
\&
\&    void* tm_obj = stack[0].oval;
\&
\&    strcut tm* tm_ptr = (struct tm*) env\->get_pointer(env, tm_obj);
\&
\&    env\->free_memory_block (tm_ptr);
\&
\&    return 0;
\&  }
.Ve
.PP
Execute the free_memory_block function to free the memory. Be sure to free the memory allocated by alloc_memory_block_zero with the free_memory_block function. Releases the memory and decrements the memory block count by one.
.SS "Call Native \s-1API\s0"
.IX Subsection "Call Native API"
Native \s-1API\s0 can be called from \*(L"SPVM_ENV* env\*(R" passed as an argument. Note that you have to pass env as the first argument.
.PP
.Vb 1
\&  int32_t basic_type_id = env\->get_basic_type_id(env, "Int");
.Ve
.SH "IDs of Native API"
.IX Header "IDs of Native API"
Native APIs of \s-1SPVM\s0 have the IDs that is corresponding to the names. These IDs are permanently same for the binary compatibility in the future release. When a new Native \s-1API\s0 is added, it will be added after the end of IDs.
.PP
.Vb 10
\&  0 class_vars_heap
\&  1 object_header_byte_size
\&  2 object_weaken_backref_head_offset
\&  3 object_ref_count_offset
\&  4 object_basic_type_id_offset
\&  5 object_type_dimension_offset
\&  6 object_type_category_offset
\&  7 object_flag_offset
\&  8 object_length_offset
\&  9 byte_object_basic_type_id
\&  10 short_object_basic_type_id
\&  11 int_object_basic_type_id
\&  12 long_object_basic_type_id
\&  13 float_object_basic_type_id
\&  14 double_object_basic_type_id
\&  15 compiler
\&  16 exception_object
\&  17 native_mortal_stack
\&  18 native_mortal_stack_top
\&  19 native_mortal_stack_capacity
\&  20 get_basic_type_id
\&  21 get_field_id
\&  22 get_field_offset
\&  23 get_class_var_id
\&  24 get_class_method_id
\&  25 get_instance_method_id
\&  26 new_object_raw
\&  27 new_object
\&  28 new_byte_array_raw
\&  29 new_byte_array
\&  30 new_short_array_raw
\&  31 new_short_array
\&  32 new_int_array_raw
\&  33 new_int_array
\&  34 new_long_array_raw
\&  35 new_long_array
\&  36 new_float_array_raw
\&  37 new_float_array
\&  38 new_double_array_raw
\&  39 new_double_array
\&  40 new_object_array_raw
\&  41 new_object_array
\&  42 new_muldim_array_raw
\&  43 new_muldim_array
\&  44 new_mulnum_array_raw
\&  45 new_mulnum_array
\&  46 new_string_nolen_raw
\&  47 new_string_nolen
\&  48 new_string_raw
\&  49 new_string
\&  50 new_pointer_raw
\&  51 new_pointer
\&  52 concat_raw
\&  53 concat
\&  54 new_stack_trace_raw
\&  55 new_stack_trace
\&  56 length
\&  57 get_elems_byte
\&  58 get_elems_short
\&  59 get_elems_int
\&  60 get_elems_long
\&  61 get_elems_float
\&  62 get_elems_double
\&  63 get_elem_object
\&  64 set_elem_object
\&  65 get_field_byte
\&  66 get_field_short
\&  67 get_field_int
\&  68 get_field_long
\&  69 get_field_float
\&  70 get_field_double
\&  71 get_field_object
\&  72 set_field_byte
\&  73 set_field_short
\&  74 set_field_int
\&  75 set_field_long
\&  76 set_field_float
\&  77 set_field_double
\&  78 set_field_object
\&  79 get_class_var_byte
\&  80 get_class_var_short
\&  81 get_class_var_int
\&  82 get_class_var_long
\&  83 get_class_var_float
\&  84 get_class_var_double
\&  85 get_class_var_object
\&  86 set_class_var_byte
\&  87 set_class_var_short
\&  88 set_class_var_int
\&  89 set_class_var_long
\&  90 set_class_var_float
\&  91 set_class_var_double
\&  92 set_class_var_object
\&  93 get_pointer
\&  94 set_pointer
\&  95 call_spvm_method
\&  96 get_exception
\&  97 set_exception
\&  98 get_ref_count
\&  99 inc_ref_count
\&  100 dec_ref_count
\&  101 enter_scope
\&  102 push_mortal
\&  103 leave_scope
\&  104 remove_mortal
\&  105 is_type
\&  106 has_callback
\&  107 get_object_basic_type_id
\&  108 get_object_type_dimension
\&  109 weaken
\&  110 isweak
\&  111 unweaken
\&  112 alloc_memory_block_zero
\&  113 free_memory_block
\&  114 get_memory_blocks_count
\&  115 get_type_name_raw
\&  116 get_type_name
\&  117 new_env
\&  118 free_env
\&  119 memory_blocks_count
\&  120 get_chars
\&  121 die
\&  122 new_object_by_name
\&  123 new_pointer_by_name
\&  124 set_field_byte_by_name
\&  125 set_field_short_by_name
\&  126 set_field_int_by_name
\&  127 set_field_long_by_name
\&  128 set_field_float_by_name
\&  129 set_field_double_by_name
\&  130 set_field_object_by_name
\&  131 get_field_byte_by_name
\&  132 get_field_short_by_name
\&  133 get_field_int_by_name
\&  134 get_field_long_by_name
\&  135 get_field_float_by_name
\&  136 get_field_double_by_name
\&  137 get_field_object_by_name
\&  138 set_class_var_byte_by_name
\&  139 set_class_var_short_by_name
\&  140 set_class_var_int_by_name
\&  141 set_class_var_long_by_name
\&  142 set_class_var_float_by_name
\&  143 set_class_var_double_by_name
\&  144 set_class_var_object_by_name
\&  145 get_class_var_byte_by_name
\&  146 get_class_var_short_by_name
\&  147 get_class_var_int_by_name
\&  148 get_class_var_long_by_name
\&  149 get_class_var_float_by_name
\&  150 get_class_var_double_by_name
\&  151 get_class_var_object_by_name
\&  152 call_class_method_by_name
\&  153 call_instance_method_by_name
\&  154 get_field_string_chars_by_name
\&  155 any_object_basic_type_id
\&  156 dump_raw
\&  157 dump
\&  158 call_class_method
\&  159 call_instance_method
\&  160 get_instance_method_id_static
\&  161 get_bool_object_value
.Ve
.SH "List of Native APIs"
.IX Header "List of Native APIs"
List of Native APIs of \s-1SPVM\s0.
.SS "class_vars_heap"
.IX Subsection "class_vars_heap"
.Vb 1
\&  void* class_vars_heap;
.Ve
.PP
the pointer to the storage area of the class variables. This is used internally.
.SS "object_header_byte_size"
.IX Subsection "object_header_byte_size"
.Vb 1
\&  void* object_header_byte_size;
.Ve
.PP
The byte size of the object's header. This is used internally.
.SS "object_weaken_backref_head_offset"
.IX Subsection "object_weaken_backref_head_offset"
.Vb 1
\&  void* object_weaken_backref_head_offset;
.Ve
.PP
Offset to a pointer to the back reference of the weak reference in the object structure. This is used internally.
.SS "object_ref_count_offset"
.IX Subsection "object_ref_count_offset"
.Vb 1
\&  void* object_ref_count_offset;
.Ve
.PP
Reference count offset in the object structure. This is used internally.
.SS "object_basic_type_id_offset"
.IX Subsection "object_basic_type_id_offset"
.Vb 1
\&  void* object_basic_type_id_offset;
.Ve
.PP
Offset of basic type \s-1ID\s0 in object structure. This is used internally.
.SS "object_type_dimension_offset"
.IX Subsection "object_type_dimension_offset"
.Vb 1
\&  void* object_type_dimension_offset;
.Ve
.PP
Offset of type dimension in object structure. This is used internally.
.SS "object_type_category_offset"
.IX Subsection "object_type_category_offset"
.Vb 1
\&  void* object_type_category_offset;
.Ve
.PP
Offset of runtime type category in object structure. This is used internally.
.SS "object_flag_offset"
.IX Subsection "object_flag_offset"
.Vb 1
\&  void* object_flag_offset;
.Ve
.PP
Offset of flag in object structure. This is used internally.
.SS "object_length_offset"
.IX Subsection "object_length_offset"
.Vb 1
\&  void* object_length_offset;
.Ve
.PP
The length offset in the object structure. This is used internally.
.SS "byte_object_basic_type_id"
.IX Subsection "byte_object_basic_type_id"
.Vb 1
\&  void* byte_object_basic_type_id;
.Ve
.PP
Basic type \s-1ID\s0 of Byte type. This is used internally.
.SS "short_object_basic_type_id"
.IX Subsection "short_object_basic_type_id"
.Vb 1
\&  void* short_object_basic_type_id;
.Ve
.PP
\&\s-1ID\s0 of the base type of Short type. This is used internally.
.SS "int_object_basic_type_id"
.IX Subsection "int_object_basic_type_id"
.Vb 1
\&  void* int_object_basic_type_id;
.Ve
.PP
\&\s-1ID\s0 of the base type of Int type. This is used internally.
.SS "long_object_basic_type_id"
.IX Subsection "long_object_basic_type_id"
.Vb 1
\&  void* long_object_basic_type_id;
.Ve
.PP
\&\s-1ID\s0 of the base type of Long type. This is used internally.
.SS "float_object_basic_type_id"
.IX Subsection "float_object_basic_type_id"
.Vb 1
\&  void* float_object_basic_type_id;
.Ve
.PP
\&\s-1ID\s0 of the base type of Float type. This is used internally.
.SS "double_object_basic_type_id"
.IX Subsection "double_object_basic_type_id"
.Vb 1
\&  void* double_object_basic_type_id;
.Ve
.PP
\&\s-1ID\s0 of the base type of Double type. This is used internally.
.SS "compiler"
.IX Subsection "compiler"
.Vb 1
\&  void* compiler;
.Ve
.PP
A pointer to the \s-1SPVM\s0 compiler. This is used internally.
.SS "exception_object"
.IX Subsection "exception_object"
.Vb 1
\&  void* exception_object;
.Ve
.PP
Exception object. This is used internally.
.SS "native_mortal_stack"
.IX Subsection "native_mortal_stack"
.Vb 1
\&  void* native_mortal_stack;
.Ve
.PP
Mortal stack used for native calls. This is used internally.
.SS "native_mortal_stack_top"
.IX Subsection "native_mortal_stack_top"
.Vb 1
\&  void* native_mortal_stack_top;
.Ve
.PP
The top position of the mortal stack used for native calls. This is used internally.
.SS "native_mortal_stack_capacity"
.IX Subsection "native_mortal_stack_capacity"
.Vb 1
\&  void* native_mortal_stack_capacity;
.Ve
.PP
The amount of mortal stack used for native calls. This is used internally.
.SS "get_basic_type_id"
.IX Subsection "get_basic_type_id"
.Vb 1
\&  int32_t (*get_basic_type_id)(SPVM_ENV* env, const char* basic_type_name);
.Ve
.PP
Get the \s-1ID\s0 of the base type given the name of the base type. If it does not exist, a value less than 0 is returned.
.PP
\&\fBExamples:\fR
.PP
.Vb 1
\&  int32_t basic_type_id = env\->get_basic_type_id(env, "Int");
.Ve
.SS "get_field_id"
.IX Subsection "get_field_id"
.Vb 1
\&  int32_t (*get_field_id)(SPVM_ENV* env, const char* class_name, const char* field_name, const char* signature);
.Ve
.PP
Get the \s-1ID\s0 of the field given the class name, field name, and signature. If the field does not exist, a value less than 0 is returned.
.PP
The signature is the same as the field type name.
.PP
\&\fBExamples:\fR
.PP
.Vb 1
\&  int32_t field_id = env\->get_field_id(env, "Foo", "x", "int");
.Ve
.SS "get_field_offset"
.IX Subsection "get_field_offset"
.Vb 1
\&  int32_t (*get_field_offset)(SPVM_ENV* env, int32_t field_id);
.Ve
.PP
Gets the offset of the field given the field \s-1ID.\s0 The field \s-1ID\s0 must be a valid field \s-1ID\s0 obtained with the field_id function.
.SS "get_class_var_id"
.IX Subsection "get_class_var_id"
.Vb 1
\&  int32_t (*get_class_var_id)(SPVM_ENV* env, const char* class_name, const char* class_var_name, const char* signature);
.Ve
.PP
Get the class variable \s-1ID\s0 given the class name, class variable name and signature. If the class variable does not exist, a value less than 0 is returned.
.PP
The signature is the same as the class variable type name.
.PP
\&\fBExamples:\fR
.PP
.Vb 1
\&  int32_t pkgvar_id = env\->get_class_var_id(env, "Foo", "$VAR", "int");
.Ve
.SS "get_class_method_id"
.IX Subsection "get_class_method_id"
.Vb 1
\&  int32_t (*get_class_method_id)(SPVM_ENV* env, const char* class_name, const char* method_name, const char* signature);
.Ve
.PP
Get a class method \s-1ID\s0 by the class name, the method name, and the method signature. If the class method does not exists, a negative value is returned.
.PP
This \s-1ID\s0 is used by \*(L"call_class_method\*(R".
.PP
The method signature has the following format.
.PP
.Vb 1
\&  ReturnValueType(ArgumentType1,ArgumentType2,...)
.Ve
.PP
\&\fBExamples:\fR
.PP
.Vb 1
\&  int32_t method_id = env\->get_class_method_id(env, "Foo", "get", "int(long,string)");
.Ve
.SS "get_instance_method_id"
.IX Subsection "get_instance_method_id"
.Vb 1
\&  int32_t (*get_instance_method_id)(SPVM_ENV* env, void* object, const char* method_name, const char* signature);
.Ve
.PP
Get a instance method \s-1ID\s0 by the object, the method name, and the method signatre. If the instance method does not exist, a negative value is returned.
.PP
This \s-1ID\s0 is used by \*(L"call_instance_method\*(R".
.PP
The method signature has the following format,
.PP
.Vb 1
\&  ReturnValueType(ArgumentType1,ArgumentType2,...)
.Ve
.PP
\&\fBExamples:\fR
.PP
.Vb 1
\&  int32_t method_id = env\->get_instance_method_id(env, object, "get", "int(long,string)");
.Ve
.SS "new_object_raw"
.IX Subsection "new_object_raw"
.Vb 1
\&  void* (*new_object_raw)(SPVM_ENV* env, int32_t basic_type_id);
.Ve
.PP
Create a new object with a basic type \s-1ID.\s0 The basic type \s-1ID\s0 must be the correct base type \s-1ID\s0 return by \f(CW\*(C`get_basic_type_id\*(C'\fR function.
.SS "new_object"
.IX Subsection "new_object"
.Vb 1
\&  void* (*new_object)(SPVM_ENV* env, int32_t basic_type_id);
.Ve
.PP
Do the same as \f(CW\*(C`new_object_raw\*(C'\fR, and add the created object to the mortal stack of the environment. Use this function in normal use instead of \f(CW\*(C`new_object_raw\*(C'\fR.
.PP
\&\fBExamples:\fR
.PP
.Vb 2
\&  int32_t basic_type_id = env\->get_basic_type_id(env, "Int");
\&  void* object = env\->new_object(env, basic_type_id);
.Ve
.SS "new_byte_array_raw"
.IX Subsection "new_byte_array_raw"
.Vb 1
\&  void* (*new_byte_array_raw)(SPVM_ENV* env, int32_t length);
.Ve
.PP
Create a new byte[] type array by specifying the length.
.SS "new_byte_array"
.IX Subsection "new_byte_array"
.Vb 1
\&  void* (*new_byte_array)(SPVM_ENV* env, int32_t length);
.Ve
.PP
Do the same as \f(CW\*(C`new_byte_array_raw\*(C'\fR, and add the created array to the mortal stack of the environment. Use this function in normal use instead of \f(CW\*(C`new_byte_array_raw\*(C'\fR.
.PP
\&\fBExamples:\fR
.PP
.Vb 1
\&  void* byte_array = env\->new_byte_array(env, 100);
.Ve
.SS "new_short_array_raw"
.IX Subsection "new_short_array_raw"
.Vb 1
\&  void* (*new_short_array_raw)(SPVM_ENV* env, int32_t length);
.Ve
.PP
Create a new short[] type array by specifying the length.
.SS "new_short_array"
.IX Subsection "new_short_array"
.Vb 1
\&  void* (*new_short_array)(SPVM_ENV* env, int32_t length);
.Ve
.PP
Do the same as \f(CW\*(C`new_short_array_raw\*(C'\fR, and add the created array to the mortal stack of the environment. Use this function in normal use instead of \f(CW\*(C`new_short_array_raw\*(C'\fR.
.PP
\&\fBExamples:\fR
.PP
.Vb 1
\&  void* short_array = env\->new_short_array(env, 100);
.Ve
.SS "new_int_array_raw"
.IX Subsection "new_int_array_raw"
.Vb 1
\&  void* (*new_int_array_raw)(SPVM_ENV* env, int32_t length);
.Ve
.PP
Create a new int[] type array by specifying the length.
.SS "new_int_array"
.IX Subsection "new_int_array"
.Vb 1
\&  void* (*new_int_array)(SPVM_ENV* env, int32_t length);
.Ve
.PP
Do the same as \f(CW\*(C`new_int_array_raw\*(C'\fR, and add the created array to the mortal stack of the environment. Use this function in normal use instead of \f(CW\*(C`new_int_array_raw\*(C'\fR.
.PP
\&\fBExamples:\fR
.PP
.Vb 1
\&  void* int_array = env\->new_int_array(env, 100);
.Ve
.SS "new_long_array_raw"
.IX Subsection "new_long_array_raw"
.Vb 1
\&  void* (*new_long_array_raw)(SPVM_ENV* env, int32_t length);
.Ve
.PP
Create a new long[] type array by specifying the length.
.SS "new_long_array"
.IX Subsection "new_long_array"
.Vb 1
\&  void* (*new_long_array)(SPVM_ENV* env, int32_t length);
.Ve
.PP
Do the same as \f(CW\*(C`new_long_array_raw\*(C'\fR, and add the created array to the mortal stack of the environment. Use this function in normal use instead of \f(CW\*(C`new_long_array_raw\*(C'\fR.
.PP
\&\fBExamples:\fR
.PP
.Vb 1
\&  void* long_array = env\->new_long_array(env, 100);
.Ve
.SS "new_float_array_raw"
.IX Subsection "new_float_array_raw"
.Vb 1
\&  void* (*new_float_array_raw)(SPVM_ENV* env, int32_t length);
.Ve
.PP
Create a new float[] type array by specifying the length.
.SS "new_float_array"
.IX Subsection "new_float_array"
.Vb 1
\&  void* (*new_float_array)(SPVM_ENV* env, int32_t length);
.Ve
.PP
Do the same as \f(CW\*(C`new_float_array_raw\*(C'\fR, and add the created array to the mortal stack of the environment. Use this function in normal use instead of \f(CW\*(C`new_float_array_raw\*(C'\fR.
.PP
\&\fBExamples:\fR
.PP
.Vb 1
\&  void* float_array = env\->new_float_array(env, 100);
.Ve
.SS "new_double_array_raw"
.IX Subsection "new_double_array_raw"
.Vb 1
\&  void* (*new_double_array_raw)(SPVM_ENV* env, int32_t length);
.Ve
.PP
Create a new double[] type array by specifying the length.
.SS "new_double_array"
.IX Subsection "new_double_array"
.Vb 1
\&  void* (*new_double_array)(SPVM_ENV* env, int32_t length);
.Ve
.PP
Do the same as \f(CW\*(C`new_double_array_raw\*(C'\fR, and add the created array to the mortal stack of the environment. Use this function in normal use instead of \f(CW\*(C`new_double_array_raw\*(C'\fR.
.PP
\&\fBExamples:\fR
.PP
.Vb 1
\&  void* double_array = env\->new_double_array(env, 100);
.Ve
.SS "new_object_array_raw"
.IX Subsection "new_object_array_raw"
.Vb 1
\&  void* (*new_object_array_raw)(SPVM_ENV* env, int32_t basic_type_id, int32_t length);
.Ve
.PP
Create a new object type array by specifying the basic type \s-1ID\s0 and the array length. The basic type \s-1ID\s0 must be the correct basic type \s-1ID\s0 got by \f(CW\*(C`get_basic_type_id\*(C'\fR function.
.SS "new_object_array"
.IX Subsection "new_object_array"
.Vb 1
\&  void* (*new_object_array)(SPVM_ENV* env, int32_t basic_type_id, int32_t length);
.Ve
.PP
Do the same as \f(CW\*(C`new_object_array_raw\*(C'\fR, and add the created array to the mortal stack of the environment. Use this function in normal use instead of \f(CW\*(C`new_object_array_raw\*(C'\fR.
.PP
\&\fBExamples:\fR
.PP
.Vb 2
\&  int32_t basic_type_id = env\->get_basic_type_id(env, "Int");
\&  void* object_array = env\->new_object_array(env, basic_type_id, 100);
.Ve
.SS "new_muldim_array_raw"
.IX Subsection "new_muldim_array_raw"
.Vb 1
\&  void* (*new_muldim_array_raw)(SPVM_ENV* env, int32_t basic_type_id, int32_t element_dimension, int32_t length);
.Ve
.PP
Create a new multi dimension array by specifying the basic type \s-1ID,\s0 the type dimension of the element, and the array length. The basic type \s-1ID\s0 must be the correct basic type \s-1ID\s0 got bu \f(CW\*(C`get_basic_type_id\*(C'\fR function. the type dimension of the element must be less than or equals to 255.
.SS "new_muldim_array"
.IX Subsection "new_muldim_array"
.Vb 1
\&  void* (*new_muldim_array_raw)(SPVM_ENV* env, int32_t basic_type_id, int32_t element_dimension, int32_t length);
.Ve
.PP
Do the same as \f(CW\*(C`new_muldim_array_raw\*(C'\fR, and add the created array to the mortal stack of the environment. Use this function in normal use instead of \f(CW\*(C`new_muldim_array_raw\*(C'\fR.
.PP
\&\fBExamples:\fR
.PP
.Vb 3
\&  // new Int[][][100]
\&  int32_t basic_type_id = env\->get_basic_type_id(env, "Int");
\&  void* multi_array = env\->new_muldim_array(env, basic_type_id, 2, 100);
.Ve
.SS "new_mulnum_array_raw"
.IX Subsection "new_mulnum_array_raw"
.Vb 1
\&  void* (*new_mulnum_array_raw)(SPVM_ENV* env, int32_t basic_type_id, int32_t length);
.Ve
.PP
Create a new multi-numeric array by specifying the basic type \s-1ID\s0 and the array length. The basic type \s-1ID\s0 must be the correct basic type \s-1ID\s0 got by \f(CW\*(C`basic_type_id\*(C'\fR function.
.SS "new_mulnum_array"
.IX Subsection "new_mulnum_array"
.Vb 1
\&  void* (*new_mulnum_array)(SPVM_ENV* env, int32_t basic_type_id, int32_t length);
.Ve
.PP
Do the same as \f(CW\*(C`new_mulnum_array_raw\*(C'\fR, and add the created array to the mortal stack of the environment. Use this function in normal use instead of \f(CW\*(C`new_mulnum_array_raw\*(C'\fR.
.PP
\&\fBExamples:\fR
.PP
.Vb 2
\&  int32_t basic_type_id = env\->get_basic_type_id(env, "Complex_2d");
\&  void* value_array = env\->new_mulnum_array(env, basic_type_id, 100);
.Ve
.SS "new_string_nolen_raw"
.IX Subsection "new_string_nolen_raw"
.Vb 1
\&  void* (*new_string_nolen_raw)(SPVM_ENV* env, const char* bytes);
.Ve
.PP
Create a new string object by specifying C language char* type value. this value must end with \*(L"\e0\*(R".
.SS "new_string_nolen"
.IX Subsection "new_string_nolen"
.Vb 1
\&  void* (*new_string_nolen)(SPVM_ENV* env, const char* bytes);
.Ve
.PP
Do the same as \f(CW\*(C`new_string_nolen_raw\*(C'\fR, and add the created string object to the mortal stack of the environment. Use this function in normal use instead of \f(CW\*(C`new_string_nolen_raw\*(C'\fR.
.PP
\&\fBExamples:\fR
.PP
.Vb 1
\&  void* str_obj = env\->new_string_nolen(env, "Hello World");
.Ve
.SS "new_string_raw"
.IX Subsection "new_string_raw"
.Vb 1
\&  void* (*new_string_raw)(SPVM_ENV* env, const char* bytes, int32_t length);
.Ve
.PP
Create a new string object by specifying C language char* type value and the length.
.SS "new_string"
.IX Subsection "new_string"
.Vb 1
\&  void* (*new_string)(SPVM_ENV* env, const char* bytes, int32_t length);
.Ve
.PP
Do the same as \f(CW\*(C`new_string_raw\*(C'\fR, and add the created string object to the mortal stack of the environment. Use this function in normal use instead of \f(CW\*(C`new_string_raw\*(C'\fR.
.PP
\&\fBExamples:\fR
.PP
.Vb 1
\&  void* str_obj = env\->new_string(env, "Hello \e0World", 11);
.Ve
.SS "new_pointer_raw"
.IX Subsection "new_pointer_raw"
.Vb 1
\&  void* (*new_pointer_raw)(SPVM_ENV* env, int32_t basic_type_id, void* pointer);
.Ve
.PP
Create a pointer type object by specifying a basic type \s-1ID\s0 and a C language pointer. The basic type \s-1ID\s0 must be the correct basic type \s-1ID\s0 got by \f(CW\*(C`get_basic_type_id\*(C'\fR function.
.SS "new_pointer"
.IX Subsection "new_pointer"
.Vb 1
\&  void* (*new_pointer)(SPVM_ENV* env, int32_t basic_type_id, void* pointer);
.Ve
.PP
Do the same as \f(CW\*(C`new_pointer_raw\*(C'\fR, and add the created string object to the mortal stack of the environment. Use this function in normal use instead of \f(CW\*(C`new_pointer_raw\*(C'\fR.
.PP
\&\fBExamples:\fR
.PP
.Vb 3
\&  int32_t basic_type_id = env\->get_basic_type_id(env, "MyTime");
\&  void* pointer = malloc(sizeof (struct tm));
\&  void* pointer_obj = env\->new_pointer(env, basic_type_id, pointer);
.Ve
.SS "concat_raw"
.IX Subsection "concat_raw"
.Vb 1
\&  void* (*concat_raw)(SPVM_ENV* env, void* string1, void* string2);
.Ve
.PP
Concat two strings.
.SS "concat"
.IX Subsection "concat"
.Vb 1
\&  void* (*concat)(SPVM_ENV* env, void* string1, void* string2);
.Ve
.PP
Do the same as \f(CW\*(C`concat_raw\*(C'\fR, and add the created string object to the mortal stack of the environment. Use this function in normal use instead of \f(CW\*(C`concat_raw\*(C'\fR.
.SS "new_stack_trace_raw"
.IX Subsection "new_stack_trace_raw"
.Vb 1
\&  void* (*new_stack_trace_raw)(SPVM_ENV* env, void* exception, const char* class_name, const char* method_name, const char* file, int32_t line);
.Ve
.PP
If you specify a byte[] type exception message and a class name, method name, file name and line number, the character string of the class name, method name, file name and line number is added to the end of the byte[] type exception message. The added character string will be returned.
.PP
This function does not add objects to the mortal stack, use new_stack_trace to avoid memory leaks for normal use.
.SS "new_stack_trace"
.IX Subsection "new_stack_trace"
.Vb 1
\&  void* (*new_stack_trace)(SPVM_ENV* env, void* exception, const char* class_name, const char* method_name, const char* file, int32_t line);
.Ve
.PP
When a byte[] type exception message and a class name, method name, file name and line number are specified, the string of the class name, method name, file name and line number is added to the end of the string type exception message. Returns a new string type object. Add the newly created object to the mortal stack.
.SS "length"
.IX Subsection "length"
.Vb 1
\&  int32_t (*length)(SPVM_ENV*, void* array);
.Ve
.PP
If you specify an array, the length of the array is returned.
.PP
\&\fBExamples:\fR
.PP
.Vb 1
\&  int32_t length = env\->length(env, array);
.Ve
.SS "get_elems_byte"
.IX Subsection "get_elems_byte"
.Vb 1
\&  int8_t* (*get_elems_byte)(SPVM_ENV* env, void* array);
.Ve
.PP
If you specify a byte[] type array, the pointer at the beginning of the internally stored C language int8_t[] type array is returned.
.PP
\&\fBExamples:\fR
.PP
.Vb 2
\&  int8_t* values = env\->get_elems_byte(env, array);
\&  values[3] = 5;
.Ve
.SS "get_elems_short"
.IX Subsection "get_elems_short"
.Vb 1
\&  int16_t* (*get_elems_short)(SPVM_ENV* env, void* array);
.Ve
.PP
If a short[] type array is specified, the pointer at the beginning of the internally stored C language int16_t[] type array is returned.
.PP
\&\fBExamples:\fR
.PP
.Vb 2
\&  int16_t* values = env\->get_elems_short(env, array);
\&  values[3] = 5;
.Ve
.SS "get_elems_int"
.IX Subsection "get_elems_int"
.Vb 1
\&  int32_t* (*get_elems_int)(SPVM_ENV* env, void* array);
.Ve
.PP
When an int[] type array is specified, the pointer at the beginning of the internally stored C language int32_t[] type array is returned.
.PP
\&\fBExamples:\fR
.PP
.Vb 2
\&  int32_t* values = env\->get_elems_int(env, array);
\&  values[3] = 5;
.Ve
.SS "get_elems_long"
.IX Subsection "get_elems_long"
.Vb 1
\&  int64_t* (*get_elems_long)(SPVM_ENV* env, void* array);
.Ve
.PP
When a long[] type array is specified, the pointer at the beginning of the internally stored C language int64_t[] type array is returned.
.PP
\&\fBExamples:\fR
.PP
.Vb 2
\&  int64_t* values = env\->get_elems_long(env, array);
\&  values[3] = 5;
.Ve
.SS "get_elems_float"
.IX Subsection "get_elems_float"
.Vb 1
\&  float* (*get_elems_float)(SPVM_ENV* env, void* array);
.Ve
.PP
When a float[] type array is specified, the pointer at the beginning of the C language float[] type array internally held is returned.
.PP
\&\fBExamples:\fR
.PP
.Vb 2
\&  float* values = env\->get_elems_float(env, array);
\&  values[3] = 1.5f;
.Ve
.SS "get_elems_double"
.IX Subsection "get_elems_double"
.Vb 1
\&  double* (*get_elems_double)(SPVM_ENV* env, void* array);
.Ve
.PP
If a double[] type array is specified, the pointer at the beginning of the internally stored C double[] type array is returned.
.PP
\&\fBExamples:\fR
.PP
.Vb 2
\&  double* values = env\->get_elems_double(env, array);
\&  values[3] = 1.5;
.Ve
.SS "get_elem_object"
.IX Subsection "get_elem_object"
.Vb 1
\&  void* (*get_elem_object)(SPVM_ENV* env, void* array, int32_t index);
.Ve
.PP
Gets an object of an element given an array of object types and a methodscript. If the element is a weak reference, the weak reference is removed.
.PP
\&\fBExamples:\fR
.PP
.Vb 1
\&  void* object = env\->get_elem_object(env, array, 3);
.Ve
.SS "set_elem_object"
.IX Subsection "set_elem_object"
.Vb 1
\&  void (*set_elem_object)(SPVM_ENV* env, void* array, int32_t index, void* value);
.Ve
.PP
If you specify an array of object type and methodscript and element objects, the element object is assigned to the corresponding methodscript position. If the element's object has a weak reference, the weak reference is removed. The reference count of the originally assigned object is decremented by 1.
.PP
\&\fBExamples:\fR
.PP
.Vb 1
\&  env\->get_elem_object(env, array, 3, object);
.Ve
.SS "get_field_byte"
.IX Subsection "get_field_byte"
.Vb 1
\&  int8_t (*get_field_byte)(SPVM_ENV* env, void* object, int32_t field_id);
.Ve
.PP
If an object and field \s-1ID\s0 are specified, the byte field value will be returned as a C language int8_t type value. The field \s-1ID\s0 must be a valid field \s-1ID\s0 obtained with the field_id function.
.PP
\&\fBExamples:\fR
.PP
.Vb 2
\&  int32_t field_id = env\->get_field_id(env, "Foo", "x", "byte");
\&  int8_t field_value = env\->get_field_byte(env, object, field_id);
.Ve
.SS "get_field_short"
.IX Subsection "get_field_short"
.Vb 1
\&  int16_t (*get_field_short)(SPVM_ENV* env, void* object, int32_t field_id);
.Ve
.PP
If you specify the object and field \s-1ID,\s0 the value of the short type field will be returned as the int16_t type value of C language. The field \s-1ID\s0 must be a valid field \s-1ID\s0 obtained with the field_id function.
.PP
\&\fBExamples:\fR
.PP
.Vb 2
\&  int32_t field_id = env\->get_field_id(env, "Foo", "x", "short");
\&  int16_t field_value = env\->get_field_short(env, object, field_id);
.Ve
.SS "get_field_int"
.IX Subsection "get_field_int"
.Vb 1
\&  int32_t (*get_field_int)(SPVM_ENV* env, void* object, int32_t field_id);
.Ve
.PP
If an object and a field \s-1ID\s0 are specified, the value of the int type field will be returned as a C language int32_t type value. The field \s-1ID\s0 must be a valid field \s-1ID\s0 obtained with the field_id function.
.PP
\&\fBExamples:\fR
.PP
.Vb 2
\&  int32_t field_id = env\->get_field_id(env, "Foo", "x", "int");
\&  int32_t field_value = env\->get_field_int(env, object, field_id);
.Ve
.SS "get_field_long"
.IX Subsection "get_field_long"
.Vb 1
\&  int64_t (*get_field_long)(SPVM_ENV* env, void* object, int32_t field_id);
.Ve
.PP
If you specify the object and field \s-1ID,\s0 the value of the long type field will be returned as the value of int64_t type of C language. The field \s-1ID\s0 must be a valid field \s-1ID\s0 obtained with the field_id function.
.PP
\&\fBExamples:\fR
.PP
.Vb 2
\&  int32_t field_id = env\->get_field_id(env, "Foo", "x", "long");
\&  int64_t field_value = env\->get_field_long(env, object, field_id);
.Ve
.SS "get_field_float"
.IX Subsection "get_field_float"
.Vb 1
\&  float (*get_field_float)(SPVM_ENV* env, void* object, int32_t field_id);
.Ve
.PP
If you specify the object and field \s-1ID,\s0 the value of the float type field will be returned as a C language float type value. The field \s-1ID\s0 must be a valid field \s-1ID\s0 obtained with the field_id function.
.PP
\&\fBExamples:\fR
.PP
.Vb 2
\&  int32_t field_id = env\->get_field_id(env, "Foo", "x", "float");
\&  float field_value = env\->get_field_float(env, object, field_id);
.Ve
.SS "get_field_double"
.IX Subsection "get_field_double"
.Vb 1
\&  double (*get_field_double)(SPVM_ENV* env, void* object, int32_t field_id);
.Ve
.PP
If you specify the object and field \s-1ID,\s0 the value of the double type field will be returned as a double type value in C language. The field \s-1ID\s0 must be a valid field \s-1ID\s0 obtained with the field_id function.
.PP
\&\fBExamples:\fR
.PP
.Vb 2
\&  int32_t field_id = env\->get_field_id(env, "Foo", "x", "double");
\&  double field_value = env\->get_field_double(env, object, field_id);
.Ve
.SS "get_field_object"
.IX Subsection "get_field_object"
.Vb 1
\&  void* (*get_field_object)(SPVM_ENV* env, void* object, int32_t field_id);
.Ve
.PP
If you specify the object and field \s-1ID,\s0 the value of the object type field is returned as a void* type value in C language. The field \s-1ID\s0 must be a valid field \s-1ID\s0 obtained with the field_id function. If the field is a weak reference, it will be removed.
.PP
.Vb 2
\&  int32_t field_id = env\->get_field_id(env, "Foo", "x", "Int");
\&  void* field_value = env\->get_field_object(env, object, field_id);
.Ve
.SS "set_field_byte"
.IX Subsection "set_field_byte"
.Vb 1
\&  void (*set_field_byte)(SPVM_ENV* env, void* object, int32_t field_id, int8_t value);
.Ve
.PP
If you specify the object and field \s-1ID\s0 and the value of the field, the value is set to the byte type field. The field \s-1ID\s0 must be a valid field \s-1ID\s0 obtained with the field_id function.
.PP
\&\fBExamples:\fR
.PP
.Vb 3
\&  int32_t field_id = env\->get_field_id(env, "Foo", "x", "byte");
\&  int8_t field_value = 5;
\&  env\->set_field_byte(env, object, field_id, field_value);
.Ve
.SS "set_field_short"
.IX Subsection "set_field_short"
.Vb 1
\&  void (*set_field_short)(SPVM_ENV* env, void* object, int32_t field_id, int16_t value);
.Ve
.PP
If you specify the object and field \s-1ID\s0 and the value of the field, the value is set to the short type field. The field \s-1ID\s0 must be a valid field \s-1ID\s0 obtained with the field_id function.
.PP
\&\fBExamples:\fR
.PP
.Vb 3
\&  int32_t field_id = env\->get_field_id(env, "Foo", "x", "short");
\&  int16_t field_value = 5;
\&  env\->set_field_short(env, object, field_id, field_value);
.Ve
.SS "set_field_int"
.IX Subsection "set_field_int"
.Vb 1
\&  void (*set_field_int)(SPVM_ENV* env, void* object, int32_t field_id, int32_t value);
.Ve
.PP
If you specify the object and field \s-1ID\s0 and the value of the field, the value is set to the int type field. The field \s-1ID\s0 must be a valid field \s-1ID\s0 obtained with the field_id function.
.PP
\&\fBExamples:\fR
.PP
.Vb 3
\&  int32_t field_id = env\->get_field_id(env, "Foo", "x", "int");
\&  int32_t field_value = 5;
\&  env\->set_field_int(env, object, field_id, field_value);
.Ve
.SS "set_field_long"
.IX Subsection "set_field_long"
.Vb 1
\&  void (*set_field_long)(SPVM_ENV* env, void* object, int32_t field_id, int64_t value);
.Ve
.PP
If you specify the object and field \s-1ID\s0 and the value of the field, the value is set to the long type field. The field \s-1ID\s0 must be a valid field \s-1ID\s0 obtained with the field_id function.
.PP
\&\fBExamples:\fR
.PP
.Vb 3
\&  int32_t field_id = env\->get_field_id(env, "Foo", "x", "long");
\&  int64_t field_value = 5;
\&  env\->set_field_long(env, object, field_id, field_value);
.Ve
.SS "set_field_float"
.IX Subsection "set_field_float"
.Vb 1
\&  void (*set_field_float)(SPVM_ENV* env, void* object, int32_t field_id, float value);
.Ve
.PP
If you specify the object and field \s-1ID\s0 and the value of the field, the value is set to the float type field. The field \s-1ID\s0 must be a valid field \s-1ID\s0 obtained with the field_id function.
.PP
\&\fBExamples:\fR
.PP
.Vb 3
\&  int32_t field_id = env\->get_field_id(env, "Foo", "x", "float");
\&  float field_value = 1.5f;
\&  env\->set_field_float(env, object, field_id, field_value);
.Ve
.SS "set_field_double"
.IX Subsection "set_field_double"
.Vb 1
\&  void (*set_field_double)(SPVM_ENV* env, void* object, int32_t field_id, double value);
.Ve
.PP
If you specify the object and field \s-1ID\s0 and the value of the field, the value is set to the double type field. The field \s-1ID\s0 must be a valid field \s-1ID\s0 obtained with the field_id function.
.PP
\&\fBExamples:\fR
.PP
.Vb 3
\&  int32_t field_id = env\->get_field_id(env, "Foo", "x", "double");
\&  double field_value = 1.55;
\&  env\->set_field_double(env, object, field_id, field_value);
.Ve
.SS "set_field_object"
.IX Subsection "set_field_object"
.Vb 1
\&  void (*set_field_object)(SPVM_ENV* env, void* object, int32_t field_id, void* value);
.Ve
.PP
Object and field Specify the \s-1ID\s0 and the value of the field and set the value to the object type field. The field \s-1ID\s0 must be a valid field \s-1ID\s0 obtained with the field_id function. After setting, the reference count is incremented by 1. The original value has the reference count decremented by 1.
.PP
\&\fBExamples:\fR
.PP
.Vb 4
\&  int32_t field_id = env\->get_field_id(env, "Foo", "x", "Int");
\&  int32_t basic_type_id = env\->get_basic_type_id(env, "Int");
\&  void* object = env\->new_object(env, basic_type_id);
\&  env\->set_field_object(env, object, field_id, object);
.Ve
.SS "get_class_var_byte"
.IX Subsection "get_class_var_byte"
.Vb 1
\&  int8_t (*get_class_var_byte)(SPVM_ENV* env, int32_t pkgvar_id);
.Ve
.PP
If an object and a class variable \s-1ID\s0 are specified, the value of the byte type class variable is returned as a C language int8_t type value. The class variable \s-1ID\s0 must be a valid class variable \s-1ID\s0 obtained with the field_id function.
.PP
\&\fBExamples:\fR
.PP
.Vb 2
\&  int32_t pkgvar_id = env\->get_class_var_id(env, "Foo", "$VAR", "byte");
\&  int8_t pkgvar_value = env\->get_class_var_byte(env, object, pkgvar_id);
.Ve
.SS "get_class_var_short"
.IX Subsection "get_class_var_short"
.Vb 1
\&  int16_t (*get_class_var_short)(SPVM_ENV* env, int32_t pkgvar_id);
.Ve
.PP
If an object and a class variable \s-1ID\s0 are specified, the value of the short type class variable will be returned as a C language int16_t type value. The class variable \s-1ID\s0 must be a valid class variable \s-1ID\s0 obtained with the field_id function.
.PP
\&\fBExamples:\fR
.PP
.Vb 2
\&  int32_t pkgvar_id = env\->get_class_var_id(env, "Foo", "$VAR", "short");
\&  int16_t pkgvar_value = env\->get_class_var_short(env, object, pkgvar_id);
.Ve
.SS "get_class_var_int"
.IX Subsection "get_class_var_int"
.Vb 1
\&  int32_t (*get_class_var_int)(SPVM_ENV* env, int32_t pkgvar_id);
.Ve
.PP
If an object and a class variable \s-1ID\s0 are specified, the value of the int type class variable will be returned as a C language int32_t type value. The class variable \s-1ID\s0 must be a valid class variable \s-1ID\s0 obtained with the field_id function.
.PP
\&\fBExamples:\fR
.PP
.Vb 2
\&  int32_t pkgvar_id = env\->get_class_var_id(env, "Foo", "$VAR", "int");
\&  int32_t pkgvar_value = env\->get_class_var_int(env, object, pkgvar_id);
.Ve
.SS "get_class_var_long"
.IX Subsection "get_class_var_long"
.Vb 1
\&  int64_t (*get_class_var_long)(SPVM_ENV* env, int32_t pkgvar_id);
.Ve
.PP
If an object and a class variable \s-1ID\s0 are specified, the value of the long type class variable will be returned as a C language int64_t type value. The class variable \s-1ID\s0 must be a valid class variable \s-1ID\s0 obtained with the field_id function.
.PP
\&\fBExamples:\fR
.PP
.Vb 2
\&  int32_t pkgvar_id = env\->get_class_var_id(env, "Foo", "$VAR", "long");
\&  int64_t pkgvar_value = env\->get_class_var_long(env, object, pkgvar_id);
.Ve
.SS "get_class_var_float"
.IX Subsection "get_class_var_float"
.Vb 1
\&  float (*get_class_var_float)(SPVM_ENV* env, int32_t pkgvar_id);
.Ve
.PP
If an object and a class variable \s-1ID\s0 are specified, the value of the float type class variable will be returned as a C language float type value. The class variable \s-1ID\s0 must be a valid class variable \s-1ID\s0 obtained with the field_id function.
.PP
\&\fBExamples:\fR
.PP
.Vb 2
\&  int32_t pkgvar_id = env\->get_class_var_id(env, "Foo", "$VAR", "float");
\&  float pkgvar_value = env\->get_class_var_float(env, object, pkgvar_id);
.Ve
.SS "get_class_var_double"
.IX Subsection "get_class_var_double"
.Vb 1
\&  double (*get_class_var_double)(SPVM_ENV* env, int32_t pkgvar_id);
.Ve
.PP
If you specify an object and a class variable \s-1ID,\s0 the value of the double type class variable is returned as a C type double type value. The class variable \s-1ID\s0 must be a valid class variable \s-1ID\s0 obtained with the field_id function.
.PP
\&\fBExamples:\fR
.PP
.Vb 2
\&  int32_t pkgvar_id = env\->get_class_var_id(env, "Foo", "$VAR", "double");
\&  double pkgvar_value = env\->get_class_var_double(env, object, pkgvar_id);
.Ve
.SS "get_class_var_object"
.IX Subsection "get_class_var_object"
.Vb 1
\&  void* (*get_class_var_object)(SPVM_ENV* env, int32_t pkgvar_id);
.Ve
.PP
When an object and a class variable \s-1ID\s0 are specified, the value of the object type class variable is returned as a C language void* type value. The class variable \s-1ID\s0 must be a valid class variable \s-1ID\s0 obtained with the field_id function.
.PP
\&\fBExamples:\fR
.PP
.Vb 2
\&  int32_t pkgvar_id = env\->get_class_var_id(env, "Foo", "$VAR", "Int");
\&  void* pkgvar_value = env\->get_class_var_byte(env, object, pkgvar_id);
.Ve
.SS "set_class_var_byte"
.IX Subsection "set_class_var_byte"
.Vb 1
\&  void (*set_class_var_byte)(SPVM_ENV* env, int32_t pkgvar_id, int8_t value);
.Ve
.PP
If you specify the object and field \s-1ID\s0 and the value of the field, the value is set to the byte type field. The field \s-1ID\s0 must be a valid field \s-1ID\s0 obtained with the field_id function.
.PP
\&\fBExamples:\fR
.PP
.Vb 3
\&  int32_t pkgvar_id = env\->get_class_var_id(env, "Foo", "$VAR", "byte");
\&  int8_t pkgvar_value = 5;
\&  env\->set_class_var_byte(env, pkgvar_id, pkgvar_value);
.Ve
.SS "set_class_var_short"
.IX Subsection "set_class_var_short"
.Vb 1
\&  void (*set_class_var_short)(SPVM_ENV* env, int32_t pkgvar_id, int16_t value);
.Ve
.PP
If you specify the object and field \s-1ID\s0 and the value of the field, the value is set to the short type field. The field \s-1ID\s0 must be a valid field \s-1ID\s0 obtained with the field_id function.
.PP
\&\fBExamples:\fR
.PP
.Vb 3
\&  int32_t pkgvar_id = env\->get_class_var_id(env, "Foo", "$VAR", "short");
\&  int16_t pkgvar_value = 5;
\&  env\->set_class_var_short(env, pkgvar_id, pkgvar_value);
.Ve
.SS "set_class_var_int"
.IX Subsection "set_class_var_int"
.Vb 1
\&  void (*set_class_var_int)(SPVM_ENV* env, int32_t pkgvar_id, int32_t value);
.Ve
.PP
If you specify the object and field \s-1ID\s0 and the value of the field, the value is set to the int type field. The field \s-1ID\s0 must be a valid field \s-1ID\s0 obtained with the field_id function.
.PP
\&\fBExamples:\fR
.PP
.Vb 3
\&  int32_t pkgvar_id = env\->get_class_var_id(env, "Foo", "$VAR", "int");
\&  int32_t pkgvar_value = 5;
\&  env\->set_class_var_int(env, pkgvar_id, pkgvar_value);
.Ve
.SS "set_class_var_long"
.IX Subsection "set_class_var_long"
.Vb 1
\&  void (*set_class_var_long)(SPVM_ENV* env, int32_t pkgvar_id, int64_t value);
.Ve
.PP
If you specify the object and field \s-1ID\s0 and the value of the field, the value is set to the long type field. The field \s-1ID\s0 must be a valid field \s-1ID\s0 obtained with the field_id function.
.PP
\&\fBExamples:\fR
.PP
.Vb 3
\&  int32_t pkgvar_id = env\->get_class_var_id(env, "Foo", "$VAR", "long");
\&  int64_t pkgvar_value = 5;
\&  env\->set_class_var_long(env, pkgvar_id, pkgvar_value);
.Ve
.SS "set_class_var_float"
.IX Subsection "set_class_var_float"
.Vb 1
\&  void (*set_class_var_float)(SPVM_ENV* env, int32_t pkgvar_id, float value);
.Ve
.PP
If you specify the object and field \s-1ID\s0 and the value of the field, the value is set to the float type field. The field \s-1ID\s0 must be a valid field \s-1ID\s0 obtained with the field_id function.
.PP
\&\fBExamples:\fR
.PP
.Vb 3
\&  int32_t pkgvar_id = env\->get_class_var_id(env, "Foo", "$VAR", "float");
\&  float pkgvar_value = 5;
\&  env\->set_class_var_float(env, pkgvar_id, pkgvar_value);
.Ve
.SS "set_class_var_double"
.IX Subsection "set_class_var_double"
.Vb 1
\&  void (*set_class_var_double)(SPVM_ENV* env, int32_t pkgvar_id, double value);
.Ve
.PP
If you specify the object and field \s-1ID\s0 and the value of the field, the value is set to the double type field. The field \s-1ID\s0 must be a valid field \s-1ID\s0 obtained with the field_id function.
.PP
\&\fBExamples:\fR
.PP
.Vb 3
\&  int32_t pkgvar_id = env\->get_class_var_id(env, "Foo", "$VAR", "double");
\&  double pkgvar_value = 5;
\&  env\->set_class_var_double(env, pkgvar_id, pkgvar_value);
.Ve
.SS "set_class_var_object"
.IX Subsection "set_class_var_object"
.Vb 1
\&  void (*set_class_var_object)(SPVM_ENV* env, int32_t pkgvar_id, void* value);
.Ve
.PP
Object and field Specify the \s-1ID\s0 and the value of the field and set the value to the object type field. The field \s-1ID\s0 must be a valid field \s-1ID\s0 obtained with the field_id function. After setting, the reference count is incremented by 1. The original value has the reference count decremented by 1.
.PP
\&\fBExamples:\fR
.PP
.Vb 4
\&  int32_t pkgvar_id = env\->get_class_var_id(env, "Foo", "$VAR", "Int");
\&  int32_t basic_type_id = env\->get_basic_type_id(env, "Int");
\&  void* object = env\->new_object(env, basic_type_id);
\&  env\->set_class_var_object(env, pkgvar_id, pkgvar_value);
.Ve
.SS "get_pointer"
.IX Subsection "get_pointer"
.Vb 1
\&  void* (*get_pointer)(SPVM_ENV* env, void* pointer_object);
.Ve
.PP
Specify a pointer type object and return the C language pointer stored inside the object.
.PP
\&\fBExamples:\fR
.PP
.Vb 1
\&  strcut tm* tm_ptr = (struct tm*) env\->get_pointer(env, tm_obj);
.Ve
.SS "set_pointer"
.IX Subsection "set_pointer"
.Vb 1
\&  void (*set_pointer)(SPVM_ENV* env, void* pointer_object, void* pointer);
.Ve
.PP
If you specify a pointer type object and a C language pointer, the C language pointer is saved in the internal data of the pointer type object.
.SS "call_spvm_method"
.IX Subsection "call_spvm_method"
.Vb 1
\&  int32_t (*call_spvm_method)(SPVM_ENV* env, int32_t method_id, SPVM_VALUE* args);
.Ve
.PP
Call a method by specifying the method \s-1ID\s0 and argument. If an exception occurs in the method, The return value is 1. If not, return 0.
.PP
The return value of the method is set to args[0].
.SS "get_exception"
.IX Subsection "get_exception"
.Vb 1
\&  void* (*get_exception)(SPVM_ENV* env);
.Ve
.PP
Get a exception message which type is byte[].
.SS "set_exception"
.IX Subsection "set_exception"
.Vb 1
\&  void (*set_exception)(SPVM_ENV* env, void* exception);
.Ve
.PP
Set a exception message which type is byte[].
.SS "get_ref_count"
.IX Subsection "get_ref_count"
.Vb 1
\&  int32_t (*get_ref_count)(SPVM_ENV* env, void* object);
.Ve
.PP
Get the refernce count of the object.
.SS "inc_ref_count"
.IX Subsection "inc_ref_count"
.Vb 1
\&  void (*inc_ref_count)(SPVM_ENV* env, void* object);
.Ve
.PP
Specifying an object increments the reference count of the object.
.PP
Use this method only if you have a specific reason to use it. Normally, the reference count is managed automatically.
.SS "dec_ref_count"
.IX Subsection "dec_ref_count"
.Vb 1
\&  void (*dec_ref_count)(SPVM_ENV* env, void* object);
.Ve
.PP
Specifying an object decrements the object's reference count by 1. When the reference count reaches 0, the object is released.
.PP
Use this method only if you have a specific reason to use it. Normally, the reference count is managed automatically.
.SS "enter_scope"
.IX Subsection "enter_scope"
.Vb 1
\&  int32_t (*enter_scope)(SPVM_ENV* env);
.Ve
.PP
Create a new scope and return the scope \s-1ID.\s0
.SS "push_mortal"
.IX Subsection "push_mortal"
.Vb 1
\&  int32_t (*push_mortal)(SPVM_ENV* env, void* object);
.Ve
.PP
Add an object to the mortal stack.
.PP
If this method succeed, return 0.
.PP
If this method don't alloc memory for new mortal information, return 1.
.SS "leave_scope"
.IX Subsection "leave_scope"
.Vb 1
\&  void (*leave_scope)(SPVM_ENV* env, int32_t scope_id);
.Ve
.PP
Specify a scope \s-1ID\s0 to exit that scope and decrement the object's reference count stored in the mortal stack. Objects with a reference count of 0 are released. The scope \s-1ID\s0 must be the \s-1ID\s0 obtained by the enter_scope function.
.SS "remove_mortal"
.IX Subsection "remove_mortal"
.Vb 1
\&  int32_t (*remove_mortal)(SPVM_ENV* env, int32_t scope_id, void* remove_object);
.Ve
.PP
Given a scope \s-1ID\s0 and an object, delete the specified object from the mortal stack.
.SS "is_type"
.IX Subsection "is_type"
.Vb 1
\&  int32_t (*is_type)(SPVM_ENV* env, void* object, int32_t basic_type_id, int32_t type_dimension);
.Ve
.PP
Given an object and a base type \s-1ID\s0 and a type dimension, returns a nonzero value if the object matches both the base type \s-1ID\s0 and the type dimension, and 0 otherwise.
.SS "has_callback"
.IX Subsection "has_callback"
.Vb 1
\&  int32_t (*has_callback)(SPVM_ENV* env, void* object, int32_t callback_basic_type_id);
.Ve
.PP
Given a base type id for the object and the callback type, returns a non-zero value if the object conforms to the callback type, and zero otherwise.
.SS "get_object_basic_type_id"
.IX Subsection "get_object_basic_type_id"
.Vb 1
\&  int32_t (*get_object_basic_type_id)(SPVM_ENV* env, void* object);
.Ve
.PP
Gets the base type \s-1ID\s0 of the object.
.SS "get_object_type_dimension"
.IX Subsection "get_object_type_dimension"
.Vb 1
\&  int32_t (*get_object_type_dimension)(SPVM_ENV* env, void* object);
.Ve
.PP
Gets the dimension of the type of object.
.SS "weaken"
.IX Subsection "weaken"
.Vb 1
\&  int32_t (*weaken)(SPVM_ENV* env, void** object_address);
.Ve
.PP
Create weak reference to the object which is specified by object address.
.PP
The reference count of the object is decrimented by 1 and weaken flag is added to the object address.
.PP
If the reference count is 1, \*(L"dec_ref_count\*(R" is called to the object.
.PP
If object_address is \s-1NULL,\s0 this method do nothing.
.PP
If the object is already weaken, this method do nothing.
.PP
This method allocate memory internally to add the back reference from the object to the object address.
.PP
This method success return 0.
.PP
If failing memory allocation of back reference, return 1.
.SS "isweak"
.IX Subsection "isweak"
.Vb 1
\&  int32_t (*isweak()SPVM_ENV* env, void** object);
.Ve
.PP
Given the address of an object, returns non-zero if the object is a weak reference, 0 otherwise.
.SS "unweaken"
.IX Subsection "unweaken"
.Vb 1
\&  void (*unweaken)(SPVM_ENV* env, void** object_address);
.Ve
.PP
Specifying the address of the object releases the weak reference to the object.
.SS "alloc_memory_block_zero"
.IX Subsection "alloc_memory_block_zero"
.Vb 1
\&  void* (*alloc_memory_block_zero)(SPVM_ENV* env, int64_t byte_size);
.Ve
.PP
If you specify the size in bytes, the memory block is allocated and the pointer of the allocated memory block is returned. If fail to alloc memory, return \s-1NULL.\s0 If success, all bits in the memory block are initialized with 0 and the memory block count (memory_blocks_count)is incremented by 1.
.SS "free_memory_block"
.IX Subsection "free_memory_block"
.Vb 1
\&  void (*free_memory_block)(SPVM_ENV* env, void* block);
.Ve
.PP
If block is not \s-1NULL,\s0 free the memory and memory blocks count(memory_blocks_count) is decremented by 1.
.SS "get_memory_blocks_count"
.IX Subsection "get_memory_blocks_count"
.Vb 1
\&  int32_t (*get_memory_blocks_count)(SPVM_ENV* env);
.Ve
.PP
Returns the current number of memory blocks.
.PP
The memory block is increased by 1 when an object is created, when the alloc_memory_block_zero function is called, and when a back reference is added by the weaken function.
.SS "get_type_name_raw"
.IX Subsection "get_type_name_raw"
.Vb 1
\&  void* (*get_type_name_raw)(SPVM_ENV* env, void* object);
.Ve
.PP
If you specify an object, a new byte[] type object that stores the type name is returned.
.PP
This function does not add objects to the mortal stack, so use type_name for normal use to avoid memory leaks.
.SS "get_type_name"
.IX Subsection "get_type_name"
.Vb 1
\&  void* (*get_type_name)(SPVM_ENV* env, void* object);
.Ve
.PP
If you specify an object, a new byte[] type object that stores the type name is returned. Add the newly created object to the mortal stack.
.SS "new_env"
.IX Subsection "new_env"
.Vb 1
\&  SPVM_ENV* (*new_env)(SPVM_ENV* env);
.Ve
.PP
Create a new execution environment based on the current execution environment.
.PP
Create a new \s-1SPVM\s0 runtime environment.
.PP
The exception object and mortal stack information will be initialized.
.PP
Share the class variables with the original execution environment.
.PP
The number of memory blocks is shared with the original execution environment.
.PP
If thie method can't allocate memory for \s-1SPVM\s0 runtime environment, return \s-1NULL.\s0
.SS "free_env"
.IX Subsection "free_env"
.Vb 1
\&  void (*free_env)(SPVM_ENV* env);
.Ve
.PP
Release the execution environment.
.SS "memory_blocks_count"
.IX Subsection "memory_blocks_count"
.Vb 1
\&  void* memory_blocks_count;
.Ve
.PP
Memory blocks count. This is used internally.
.SS "get_chars"
.IX Subsection "get_chars"
.Vb 1
\&  const char* (*get_chars)(SPVM_ENV* env, void* string_object);
.Ve
.PP
Get characters pointer in the string object.
.PP
\&\fBExamples:\fR
.PP
.Vb 1
\&  const char* bytes = env\->get_chars(env, string_object);
.Ve
.SS "die"
.IX Subsection "die"
.Vb 1
\&  int32_t (*die)(SPVM_ENV* env, const char* message, ...);
.Ve
.PP
Create a \f(CW\*(C`sprintf\*(C'\fR formatted message with file name and line number and set it to the exception.
.PP
Last two arguments are file name and line number.
.PP
Return value is always 1;
.PP
\&\fBExamples:\fR
.PP
.Vb 1
\&  return env\->die(env, "Value must be %d", 3, _\|_FILE_\|_, _\|_LINE_\|_);
.Ve
.SS "new_object_by_name"
.IX Subsection "new_object_by_name"
.Vb 1
\&  void* (*new_object_by_name)(SPVM_ENV* env, const char* class_name, int32_t* exception_flag, const char* file, int32_t line);
.Ve
.PP
This is same as \f(CW\*(C`new_object\*(C'\fR function, but you can specify class name directry.
.PP
If function is succeeded, \f(CW\*(C`exception_flag\*(C'\fR is set to 0. If a exception occurs, \f(CW\*(C`exception_flag\*(C'\fR is set to 1.
.PP
\&\fBExamples:\fR
.PP
.Vb 3
\&  int32_t e;
\&  void* minimal = env\->new_object_by_name(env, "TestCase::Minimal", &e, _\|_FILE_\|_, _\|_LINE_\|_);
\&  if (e) { return e; }
.Ve
.SS "new_pointer_by_name"
.IX Subsection "new_pointer_by_name"
.Vb 1
\&  void* (*new_pointer_by_name)(SPVM_ENV* env, const char* class_name, void* pointer, int32_t* exception_flag, const char* file, int32_t line);
.Ve
.PP
This is same as \f(CW\*(C`new_pointer\*(C'\fR function, but you can specify class name directry.
.PP
If function is succeeded, \f(CW\*(C`exception_flag\*(C'\fR is set to 0. If a exception occurs, \f(CW\*(C`exception_flag\*(C'\fR is set to 1.
.PP
.Vb 3
\&  int32_t e;
\&  void* minimal = env\->new_pointer_by_name(env, "TestCase::Pointer", pointer, &e, _\|_FILE_\|_, _\|_LINE_\|_);
\&  if (e) { return e; }
.Ve
.SS "set_field_byte_by_name"
.IX Subsection "set_field_byte_by_name"
.Vb 3
\&  void (*set_field_byte_by_name)(SPVM_ENV* env, void* object,
\&    const char* class_name, const char* field_name, int8_t value,
\&    int32_t* exception_flag, const char* file, int32_t line);
.Ve
.PP
This is same as \f(CW\*(C`set_field_byte\*(C'\fR function, but you can specify class name and field name directry.
.PP
If function is succeeded, \f(CW\*(C`exception_flag\*(C'\fR is set to 0. If a exception occurs, \f(CW\*(C`exception_flag\*(C'\fR is set to 1.
.PP
\&\fBExamples:\fR
.PP
.Vb 3
\&  int32_t e;
\&  env\->set_field_byte_by_name(env, object, "TestCase::Simple", "byte_value", 13, &e, _\|_FILE_\|_, _\|_LINE_\|_);
\&  if (e) { return e; }
.Ve
.SS "set_field_short_by_name"
.IX Subsection "set_field_short_by_name"
.Vb 3
\&  void (*set_field_short_by_name)(SPVM_ENV* env, void* object,
\&    const char* class_name, const char* field_name, int16_t value,
\&    int32_t* exception_flag, const char* file, int32_t line);
.Ve
.PP
This is same as \f(CW\*(C`set_field_short\*(C'\fR function, but you can specify class name and field name directry.
.PP
If function is succeeded, \f(CW\*(C`exception_flag\*(C'\fR is set to 0. If a exception occurs, \f(CW\*(C`exception_flag\*(C'\fR is set to 1.
.PP
\&\fBExamples:\fR
.PP
.Vb 3
\&  int32_t e;
\&  env\->set_field_short_by_name(env, object, "TestCase::Simple", "short_value", 13, &e, _\|_FILE_\|_, _\|_LINE_\|_);
\&  if (e) { return e; }
.Ve
.SS "set_field_int_by_name"
.IX Subsection "set_field_int_by_name"
.Vb 3
\&  void (*set_field_int_by_name)(SPVM_ENV* env, void* object,
\&    const char* class_name, const char* field_name, int32_t value,
\&    int32_t* exception_flag, const char* file, int32_t line);
.Ve
.PP
This is same as \f(CW\*(C`set_field_int\*(C'\fR function, but you can specify class name and field name directry.
.PP
If function is succeeded, \f(CW\*(C`exception_flag\*(C'\fR is set to 0. If a exception occurs, \f(CW\*(C`exception_flag\*(C'\fR is set to 1.
.PP
\&\fBExamples:\fR
.PP
.Vb 3
\&  int32_t e;
\&  env\->set_field_int_by_name(env, object, "TestCase::Simple", "int_value", 13, &e, _\|_FILE_\|_, _\|_LINE_\|_);
\&  if (e) { return e; }
.Ve
.SS "set_field_long_by_name"
.IX Subsection "set_field_long_by_name"
.Vb 3
\&  void (*set_field_long_by_name)(SPVM_ENV* env, void* object,
\&    const char* class_name, const char* field_name, int64_t value,
\&    int32_t* exception_flag, const char* file, int32_t line);
.Ve
.PP
This is same as \f(CW\*(C`set_field_long\*(C'\fR function, but you can specify class name and field name directry.
.PP
If function is succeeded, \f(CW\*(C`exception_flag\*(C'\fR is set to 0. If a exception occurs, \f(CW\*(C`exception_flag\*(C'\fR is set to 1.
.PP
\&\fBExamples:\fR
.PP
.Vb 3
\&  int32_t e;
\&  env\->set_field_long_by_name(env, object, "TestCase::Simple", "long_value", 13, &e, _\|_FILE_\|_, _\|_LINE_\|_);
\&  if (e) { return e; }
.Ve
.SS "set_field_float_by_name"
.IX Subsection "set_field_float_by_name"
.Vb 3
\&  void (*set_field_float_by_name)(SPVM_ENV* env, void* object,
\&    const char* class_name, const char* field_name, float value,
\&    int32_t* exception_flag, const char* file, int32_t line);
.Ve
.PP
This is same as \f(CW\*(C`set_field_float\*(C'\fR function, but you can specify class name and field name directry.
.PP
If function is succeeded, \f(CW\*(C`exception_flag\*(C'\fR is set to 0. If a exception occurs, \f(CW\*(C`exception_flag\*(C'\fR is set to 1.
.PP
\&\fBExamples:\fR
.PP
.Vb 3
\&  int32_t e;
\&  env\->set_field_float_by_name(env, object, "TestCase::Simple", "float_value", 13, &e, _\|_FILE_\|_, _\|_LINE_\|_);
\&  if (e) { return e; }
.Ve
.SS "set_field_double_by_name"
.IX Subsection "set_field_double_by_name"
.Vb 3
\&  void (*set_field_double_by_name)(SPVM_ENV* env, void* object,
\&    const char* class_name, const char* field_name, double value,
\&    int32_t* exception_flag, const char* file, int32_t line);
.Ve
.PP
This is same as \f(CW\*(C`set_field_double\*(C'\fR function, but you can specify class name and field name directry.
.PP
If function is succeeded, \f(CW\*(C`exception_flag\*(C'\fR is set to 0. If a exception occurs, \f(CW\*(C`exception_flag\*(C'\fR is set to 1.
.PP
\&\fBExamples:\fR
.PP
.Vb 3
\&  int32_t e;
\&  env\->set_field_double_by_name(env, object, "TestCase::Simple", "double_value", 13, &e, _\|_FILE_\|_, _\|_LINE_\|_);
\&  if (e) { return e; }
.Ve
.SS "set_field_object_by_name"
.IX Subsection "set_field_object_by_name"
.Vb 3
\&  void (*set_field_object_by_name)(SPVM_ENV* env, void* object,
\&    const char* class_name, const char* field_name, const char* signature, void* value,
\&    int32_t* exception_flag, const char* file, int32_t line);
.Ve
.PP
This is same as \f(CW\*(C`set_field_object\*(C'\fR function, but you can specify class name and field name directry.
.PP
If function is succeeded, \f(CW\*(C`exception_flag\*(C'\fR is set to 0. If a exception occurs, \f(CW\*(C`exception_flag\*(C'\fR is set to 1.
.PP
\&\fBExamples:\fR
.PP
.Vb 3
\&  int32_t e;
\&  env\->set_field_object_by_name(env, object_simple, "TestCase::Simple", "object_value", "TestCase::Minimal", object_minimal, &e, _\|_FILE_\|_, _\|_LINE_\|_);
\&  if (e) { return e; }
.Ve
.SS "get_field_byte_by_name"
.IX Subsection "get_field_byte_by_name"
.Vb 3
\&  int8_t (*get_field_byte_by_name)(SPVM_ENV* env, void* object,
\&    const char* class_name, const char* field_name,
\&    int32_t* exception_flag, const char* file, int32_t line);
.Ve
.PP
This is same as \f(CW\*(C`get_field_byte\*(C'\fR function, but you can specify class name and field name directry.
.PP
If function is succeeded, \f(CW\*(C`exception_flag\*(C'\fR is get to 0. If a exception occurs, \f(CW\*(C`exception_flag\*(C'\fR is get to 1.
.PP
\&\fBExamples:\fR
.PP
.Vb 3
\&  int32_t e;
\&  int8_t byte_value = env\->get_field_byte_by_name(env, object, "TestCase::Simple", "byte_value", &e, _\|_FILE_\|_, _\|_LINE_\|_);
\&  if (e) { return e; }
.Ve
.SS "get_field_short_by_name"
.IX Subsection "get_field_short_by_name"
.Vb 3
\&  int16_t (*get_field_short_by_name)(SPVM_ENV* env, void* object,
\&    const char* class_name, const char* field_name,
\&    int32_t* exception_flag, const char* file, int32_t line);
.Ve
.PP
This is same as \f(CW\*(C`get_field_short\*(C'\fR function, but you can specify class name and field name directry.
.PP
If function is succeeded, \f(CW\*(C`exception_flag\*(C'\fR is get to 0. If a exception occurs, \f(CW\*(C`exception_flag\*(C'\fR is get to 1.
.PP
\&\fBExamples:\fR
.PP
.Vb 3
\&  int32_t e;
\&  int8_t short_value = env\->get_field_short_by_name(env, object, "TestCase::Simple", "short_value", &e, _\|_FILE_\|_, _\|_LINE_\|_);
\&  if (e) { return e; }
.Ve
.SS "get_field_int_by_name"
.IX Subsection "get_field_int_by_name"
.Vb 3
\&  int32_t (*get_field_int_by_name)(SPVM_ENV* env, void* object,
\&    const char* class_name, const char* field_name,
\&    int32_t* exception_flag, const char* file, int32_t line);
.Ve
.PP
This is same as \f(CW\*(C`get_field_int\*(C'\fR function, but you can specify class name and field name directry.
.PP
If function is succeeded, \f(CW\*(C`exception_flag\*(C'\fR is get to 0. If a exception occurs, \f(CW\*(C`exception_flag\*(C'\fR is get to 1.
.PP
\&\fBExamples:\fR
.PP
.Vb 3
\&  int32_t e;
\&  int8_t int_value = env\->get_field_int_by_name(env, object, "TestCase::Simple", "int_value", &e, _\|_FILE_\|_, _\|_LINE_\|_);
\&  if (e) { return e; }
.Ve
.SS "get_field_long_by_name"
.IX Subsection "get_field_long_by_name"
.Vb 3
\&  int64_t (*get_field_long_by_name)(SPVM_ENV* env, void* object,
\&    const char* class_name, const char* field_name,
\&    int32_t* exception_flag, const char* file, int32_t line);
.Ve
.PP
This is same as \f(CW\*(C`get_field_long\*(C'\fR function, but you can specify class name and field name directry.
.PP
If function is succeeded, \f(CW\*(C`exception_flag\*(C'\fR is get to 0. If a exception occurs, \f(CW\*(C`exception_flag\*(C'\fR is get to 1.
.PP
\&\fBExamples:\fR
.PP
.Vb 3
\&  int32_t e;
\&  int8_t long_value = env\->get_field_long_by_name(env, object, "TestCase::Simple", "long_value", &e, _\|_FILE_\|_, _\|_LINE_\|_);
\&  if (e) { return e; }
.Ve
.SS "get_field_float_by_name"
.IX Subsection "get_field_float_by_name"
.Vb 3
\&  float (*get_field_float_by_name)(SPVM_ENV* env, void* object,
\&    const char* class_name, const char* field_name,
\&    int32_t* exception_flag, const char* file, int32_t line);
.Ve
.PP
This is same as \f(CW\*(C`get_field_float\*(C'\fR function, but you can specify class name and field name directry.
.PP
If function is succeeded, \f(CW\*(C`exception_flag\*(C'\fR is get to 0. If a exception occurs, \f(CW\*(C`exception_flag\*(C'\fR is get to 1.
.PP
\&\fBExamples:\fR
.PP
.Vb 3
\&  int32_t e;
\&  int8_t float_value = env\->get_field_float_by_name(env, object, "TestCase::Simple", "float_value", &e, _\|_FILE_\|_, _\|_LINE_\|_);
\&  if (e) { return e; }
.Ve
.SS "get_field_double_by_name"
.IX Subsection "get_field_double_by_name"
.Vb 3
\&  double (*get_field_double_by_name)(SPVM_ENV* env, void* object,
\&    const char* class_name, const char* field_name,
\&    int32_t* exception_flag, const char* file, int32_t line);
.Ve
.PP
This is same as \f(CW\*(C`get_field_double\*(C'\fR function, but you can specify class name and field name directry.
.PP
If function is succeeded, \f(CW\*(C`exception_flag\*(C'\fR is get to 0. If a exception occurs, \f(CW\*(C`exception_flag\*(C'\fR is get to 1.
.PP
\&\fBExamples:\fR
.PP
.Vb 3
\&  int32_t e;
\&  int8_t double_value = env\->get_field_double_by_name(env, object, "TestCase::Simple", "double_value", &e, _\|_FILE_\|_, _\|_LINE_\|_);
\&  if (e) { return e; }
.Ve
.SS "get_field_object_by_name"
.IX Subsection "get_field_object_by_name"
.Vb 3
\&  void* (*get_field_object_by_name)(SPVM_ENV* env, void* object,
\&    const char* class_name, const char* field_name, const char* signature,
\&    int32_t* exception_flag, const char* file, int32_t line);
.Ve
.PP
This is same as \f(CW\*(C`get_field_object\*(C'\fR function, but you can specify class name and field name directry.
.PP
If function is succeeded, \f(CW\*(C`exception_flag\*(C'\fR is get to 0. If a exception occurs, \f(CW\*(C`exception_flag\*(C'\fR is get to 1.
.PP
\&\fBExamples:\fR
.PP
.Vb 3
\&  int32_t e;
\&  void* object_minimal = env\->get_field_object_by_name(env, object_simple, "TestCase::Simple", "object_value", "TestCase::Minimal", &e, _\|_FILE_\|_, _\|_LINE_\|_);
\&  if (e) { return e; }
.Ve
.SS "set_class_var_byte_by_name"
.IX Subsection "set_class_var_byte_by_name"
.Vb 3
\&  void (*set_class_var_byte_by_name)(SPVM_ENV* env,
\&    const char* class_name, const char* class_var_name, int8_t value,
\&    int32_t* exception_flag, const char* file, int32_t line);
.Ve
.PP
This is same as \f(CW\*(C`set_class_var_byte\*(C'\fR function, but you can specify the class name directry.
.PP
If function is succeeded, \f(CW\*(C`exception_flag\*(C'\fR is get to 0. If a exception occurs, \f(CW\*(C`exception_flag\*(C'\fR is get to 1.
.PP
\&\fBExamples:\fR
.PP
.Vb 3
\&  int32_t e;
\&  env\->set_class_var_byte_by_name(env, "TestCase::NativeAPI", "$BYTE_VALUE", 15, &e, _\|_FILE_\|_, _\|_LINE_\|_);
\&  if (e) { return e; }
.Ve
.SS "set_class_var_short_by_name"
.IX Subsection "set_class_var_short_by_name"
.Vb 3
\&  void (*set_class_var_short_by_name)(SPVM_ENV* env,
\&    const char* class_name, const char* class_var_name, int16_t value,
\&    int32_t* exception_flag, const char* file, int32_t line);
.Ve
.PP
This is same as \f(CW\*(C`set_class_var_short\*(C'\fR function, but you can specify the class name directry.
.PP
If function is succeeded, \f(CW\*(C`exception_flag\*(C'\fR is get to 0. If a exception occurs, \f(CW\*(C`exception_flag\*(C'\fR is get to 1.
.PP
\&\fBExamples:\fR
.PP
.Vb 3
\&  int32_t e;
\&  env\->set_class_var_short_by_name(env, "TestCase::NativeAPI", "$SHORT_VALUE", 15, &e, _\|_FILE_\|_, _\|_LINE_\|_);
\&  if (e) { return e; }
.Ve
.SS "set_class_var_int_by_name"
.IX Subsection "set_class_var_int_by_name"
.Vb 3
\&  void (*set_class_var_int_by_name)(SPVM_ENV* env,
\&    const char* class_name, const char* class_var_name, int32_t value,
\&    int32_t* exception_flag, const char* file, int32_t line);
.Ve
.PP
This is same as \f(CW\*(C`set_class_var_int\*(C'\fR function, but you can specify the class name directry.
.PP
If function is succeeded, \f(CW\*(C`exception_flag\*(C'\fR is get to 0. If a exception occurs, \f(CW\*(C`exception_flag\*(C'\fR is get to 1.
.PP
\&\fBExamples:\fR
.PP
.Vb 3
\&  int32_t e;
\&  env\->set_class_var_int_by_name(env, "TestCase::NativeAPI", "$INT_VALUE", 15, &e, _\|_FILE_\|_, _\|_LINE_\|_);
\&  if (e) { return e; }
.Ve
.SS "set_class_var_long_by_name"
.IX Subsection "set_class_var_long_by_name"
.Vb 3
\&  void (*set_class_var_long_by_name)(SPVM_ENV* env
\&    const char* class_name, const char* class_var_name, int64_t value,
\&    int32_t* exception_flag, const char* file, int32_t line);
.Ve
.PP
This is same as \f(CW\*(C`set_class_var_long\*(C'\fR function, but you can specify the class name directry.
.PP
If function is succeeded, \f(CW\*(C`exception_flag\*(C'\fR is get to 0. If a exception occurs, \f(CW\*(C`exception_flag\*(C'\fR is get to 1.
.PP
\&\fBExamples:\fR
.PP
.Vb 3
\&  int32_t e;
\&  env\->set_class_var_long_by_name(env, "TestCase::NativeAPI", "$LONG_VALUE", 15, &e, _\|_FILE_\|_, _\|_LINE_\|_);
\&  if (e) { return e; }
.Ve
.SS "set_class_var_float_by_name"
.IX Subsection "set_class_var_float_by_name"
.Vb 3
\&  void (*set_class_var_float_by_name)(SPVM_ENV* env,
\&    const char* class_name, const char* class_var_name, float value,
\&    int32_t* exception_flag, const char* file, int32_t line);
.Ve
.PP
This is same as \f(CW\*(C`set_class_var_float\*(C'\fR function, but you can specify the class name directry.
.PP
If function is succeeded, \f(CW\*(C`exception_flag\*(C'\fR is get to 0. If a exception occurs, \f(CW\*(C`exception_flag\*(C'\fR is get to 1.
.PP
\&\fBExamples:\fR
.PP
.Vb 3
\&  int32_t e;
\&  env\->set_class_var_float_by_name(env, "TestCase::NativeAPI", "$FLOAT_VALUE", 15, &e, _\|_FILE_\|_, _\|_LINE_\|_);
\&  if (e) { return e; }
.Ve
.SS "set_class_var_double_by_name"
.IX Subsection "set_class_var_double_by_name"
.Vb 3
\&  void (*set_class_var_double_by_name)(SPVM_ENV* env,
\&    const char* class_name, const char* class_var_name, double value,
\&    int32_t* exception_flag, const char* file, int32_t line);
.Ve
.PP
This is same as \f(CW\*(C`set_class_var_double\*(C'\fR function, but you can specify the class name directry.
.PP
If function is succeeded, \f(CW\*(C`exception_flag\*(C'\fR is get to 0. If a exception occurs, \f(CW\*(C`exception_flag\*(C'\fR is get to 1.
.PP
\&\fBExamples:\fR
.PP
.Vb 3
\&  int32_t e;
\&  env\->set_class_var_double_by_name(env, "TestCase::NativeAPI", "$DOUBLE_VALUE", 15, &e, _\|_FILE_\|_, _\|_LINE_\|_);
\&  if (e) { return e; }
.Ve
.SS "set_class_var_object_by_name"
.IX Subsection "set_class_var_object_by_name"
.Vb 3
\&  void (*set_class_var_object_by_name)(SPVM_ENV* env,
\&    const char* class_name, const char* class_var_name, const char* signature, void* value,
\&    int32_t* exception_flag, const char* file, int32_t line);
.Ve
.PP
This is same as \f(CW\*(C`set_class_var_object\*(C'\fR function, but you can specify the class name directry.
.PP
If function is succeeded, \f(CW\*(C`exception_flag\*(C'\fR is get to 0. If a exception occurs, \f(CW\*(C`exception_flag\*(C'\fR is get to 1.
.PP
\&\fBExamples:\fR
.PP
.Vb 3
\&  int32_t e;
\&  env\->set_class_var_object_by_name(env, "TestCase::NativeAPI", "$MINIMAL_VALUE", "TestCase::Minimal", minimal, &e, _\|_FILE_\|_, _\|_LINE_\|_);
\&  if (e) { return e; }
.Ve
.SS "get_class_var_byte_by_name"
.IX Subsection "get_class_var_byte_by_name"
.Vb 3
\&  int8_t (*get_class_var_byte_by_name)(SPVM_ENV* env,
\&    const char* class_name, const char* class_var_name,
\&    int32_t* exception_flag, const char* file, int32_t line);
.Ve
.PP
This is same as \f(CW\*(C`get_class_var_byte\*(C'\fR function, but you can specify the class name directry.
.PP
If function is succeeded, \f(CW\*(C`exception_flag\*(C'\fR is get to 0. If a exception occurs, \f(CW\*(C`exception_flag\*(C'\fR is get to 1.
.PP
\&\fBExamples:\fR
.PP
.Vb 3
\&  int32_t e;
\&  int8_t value = env\->get_class_var_byte_by_name(env, "TestCase::NativeAPI", "$BYTE_VALUE", &e, _\|_FILE_\|_, _\|_LINE_\|_);
\&  if (e) { return e; }
.Ve
.SS "get_class_var_short_by_name"
.IX Subsection "get_class_var_short_by_name"
.Vb 3
\&  int16_t (*get_class_var_short_by_name)(SPVM_ENV* env,
\&    const char* class_name, const char* class_var_name,
\&    int32_t* exception_flag, const char* file, int32_t line);
.Ve
.PP
This is same as \f(CW\*(C`get_class_var_short\*(C'\fR function, but you can specify the class name directry.
.PP
If function is succeeded, \f(CW\*(C`exception_flag\*(C'\fR is get to 0. If a exception occurs, \f(CW\*(C`exception_flag\*(C'\fR is get to 1.
.PP
\&\fBExamples:\fR
.PP
.Vb 3
\&  int32_t e;
\&  int16_t value = env\->get_class_var_short_by_name(env, "TestCase::NativeAPI", "$SHORT_VALUE", &e, _\|_FILE_\|_, _\|_LINE_\|_);
\&  if (e) { return e; }
.Ve
.SS "get_class_var_int_by_name"
.IX Subsection "get_class_var_int_by_name"
.Vb 3
\&  int32_t (*get_class_var_int_by_name)(SPVM_ENV* env,
\&    const char* class_name, const char* class_var_name,
\&    int32_t* exception_flag, const char* file, int32_t line);
.Ve
.PP
This is same as \f(CW\*(C`get_class_var_int\*(C'\fR function, but you can specify the class name directry.
.PP
If function is succeeded, \f(CW\*(C`exception_flag\*(C'\fR is get to 0. If a exception occurs, \f(CW\*(C`exception_flag\*(C'\fR is get to 1.
.PP
\&\fBExamples:\fR
.PP
.Vb 3
\&  int32_t e;
\&  int8_t value = env\->get_class_var_byte_by_name(env, "TestCase::NativeAPI", "$BYTE_VALUE", &e, _\|_FILE_\|_, _\|_LINE_\|_);
\&  if (e) { return e; }
.Ve
.SS "get_class_var_long_by_name"
.IX Subsection "get_class_var_long_by_name"
.Vb 3
\&  int64_t (*get_class_var_long_by_name)(SPVM_ENV* env,
\&    const char* class_name, const char* class_var_name,
\&    int32_t* exception_flag, const char* file, int32_t line);
.Ve
.PP
This is same as \f(CW\*(C`get_class_var_long\*(C'\fR function, but you can specify the class name directry.
.PP
If function is succeeded, \f(CW\*(C`exception_flag\*(C'\fR is get to 0. If a exception occurs, \f(CW\*(C`exception_flag\*(C'\fR is get to 1.
.PP
\&\fBExamples:\fR
.PP
.Vb 3
\&  int32_t e;
\&  int64_t value = env\->get_class_var_long_by_name(env, "TestCase::NativeAPI", "$LONG_VALUE", &e, _\|_FILE_\|_, _\|_LINE_\|_);
\&  if (e) { return e; }
.Ve
.SS "get_class_var_float_by_name"
.IX Subsection "get_class_var_float_by_name"
.Vb 3
\&  float (*get_class_var_float_by_name)(SPVM_ENV* env,
\&    const char* class_name, const char* class_var_name,
\&    int32_t* exception_flag, const char* file, int32_t line);
.Ve
.PP
This is same as \f(CW\*(C`get_class_var_float\*(C'\fR function, but you can specify the class name directry.
.PP
If function is succeeded, \f(CW\*(C`exception_flag\*(C'\fR is get to 0. If a exception occurs, \f(CW\*(C`exception_flag\*(C'\fR is get to 1.
.PP
\&\fBExamples:\fR
.PP
.Vb 3
\&  int32_t e;
\&  float value = env\->get_class_var_float_by_name(env, "TestCase::NativeAPI", "$FLOAT_VALUE", &e, _\|_FILE_\|_, _\|_LINE_\|_);
\&  if (e) { return e; }
.Ve
.SS "get_class_var_double_by_name"
.IX Subsection "get_class_var_double_by_name"
.Vb 3
\&  double (*get_class_var_double_by_name)(SPVM_ENV* env,
\&    const char* class_name, const char* class_var_name,
\&    int32_t* exception_flag, const char* file, int32_t line);
.Ve
.PP
This is same as \f(CW\*(C`get_class_var_double\*(C'\fR function, but you can specify the class name directry.
.PP
If function is succeeded, \f(CW\*(C`exception_flag\*(C'\fR is get to 0. If a exception occurs, \f(CW\*(C`exception_flag\*(C'\fR is get to 1.
.PP
\&\fBExamples:\fR
.PP
.Vb 3
\&  int32_t e;
\&  double value = env\->get_class_var_double_by_name(env, "TestCase::NativeAPI", "$DOUBLE_VALUE", &e, _\|_FILE_\|_, _\|_LINE_\|_);
\&  if (e) { return e; }
.Ve
.SS "get_class_var_object_by_name"
.IX Subsection "get_class_var_object_by_name"
.Vb 3
\&  void* (*get_class_var_object_by_name)(SPVM_ENV* env,
\&    const char* class_name, const char* class_var_name, const char* signature,
\&    int32_t* exception_flag, const char* file, int32_t line);
.Ve
.PP
This is same as \f(CW\*(C`get_class_var_object\*(C'\fR function, but you can specify the class name directry.
.PP
If function is succeeded, \f(CW\*(C`exception_flag\*(C'\fR is get to 0. If a exception occurs, \f(CW\*(C`exception_flag\*(C'\fR is get to 1.
.PP
\&\fBExamples:\fR
.PP
.Vb 3
\&  int32_t e;
\&  void* value = env\->get_class_var_object_by_name(env, "TestCase::NativeAPI", "$MINIMAL_VALUE", "TestCase::Minimal", &e, _\|_FILE_\|_, _\|_LINE_\|_);
\&  if (e) { return e; }
.Ve
.SS "call_class_method_by_name"
.IX Subsection "call_class_method_by_name"
.Vb 3
\&  int32_t (*call_class_method_by_name)(SPVM_ENV* env,
\&    const char* class_name, const char* method_name, const char* signature, SPVM_VALUE* stack,
\&    const char* file, int32_t line);
.Ve
.PP
This is same as \f(CW\*(C`call_spvm_method\*(C'\fR function, but you can specify the class name and sub name directry.
.PP
\&\fBExamples:\fR
.PP
.Vb 9
\&  int32_t output;
\&  {
\&    stack[0].ival = 5;
\&    int32_t exception_flag = env\->call_class_method_by_name(env, "TestCase::NativeAPI", "my_value", "int(int)", stack, _\|_FILE_\|_, _\|_LINE_\|_);
\&    if (exception_flag) {
\&      return exception_flag;
\&    }
\&    output = stack[0].ival;
\&  }
.Ve
.SS "call_instance_method_by_name"
.IX Subsection "call_instance_method_by_name"
.Vb 3
\&  int32_t (*call_instance_method_by_name)(SPVM_ENV* env, void* object,
\&    const char* method_name, const char* signature, SPVM_VALUE* stack,
\&    const char* file, int32_t line);
.Ve
.PP
\&\fBExamples:\fR
.SS "get_field_string_chars_by_name"
.IX Subsection "get_field_string_chars_by_name"
.Vb 3
\&  const char* (*get_field_string_chars_by_name)(SPVM_ENV* env, void* object,
\&    const char* class_name, const char* field_name,
\&    int32_t* exception_flag, const char* file, int32_t line);
.Ve
.PP
\&\fBExamples:\fR
.SS "any_object_basic_type_id"
.IX Subsection "any_object_basic_type_id"
.Vb 1
\&  void* any_object_basic_type_id;
.Ve
.PP
Basic type \s-1ID\s0 of any object type. This is used internally.
.SS "dump_raw"
.IX Subsection "dump_raw"
.Vb 1
\&  void* (*dump_raw)(SPVM_ENV* env, void* object);
.Ve
.PP
Get the string which dump the object. The string is the same as the return value of \f(CW\*(C`dump\*(C'\fR operator.
.SS "dump"
.IX Subsection "dump"
.Vb 1
\&  void* (*dump)(SPVM_ENV* env, void* object);
.Ve
.PP
Do the same as \f(CW\*(C`dump_raw\*(C'\fR, and add the created string object to the mortal stack of the environment. Use this function in normal use instead of \f(CW\*(C`dump_raw\*(C'\fR.
.SS "call_class_method"
.IX Subsection "call_class_method"
Alias for \*(L"call_spvm_method\*(R"
.SS "call_instance_method"
.IX Subsection "call_instance_method"
Alias for \*(L"call_spvm_method\*(R"
.SS "get_instance_method_id_static"
.IX Subsection "get_instance_method_id_static"
.Vb 1
\&  int32_t (*get_instance_method_id_static)(SPVM_ENV* env, const char* class_name, const char* method_name, const char* signature);
.Ve
.PP
Get a instance method \s-1ID\s0 by the class name, the method name, and the method signature. If the instance method does not exists, a negative value is returned.
.PP
This \s-1ID\s0 is used by \*(L"call_instance_method\*(R".
.PP
The method signature has the following format.
.PP
.Vb 1
\&  ReturnValueType(ArgumentType1,ArgumentType2,...)
.Ve
.PP
\&\fBExamples:\fR
.PP
.Vb 1
\&  int32_t method_id = env\->get_instance_method_id_static(env, "Foo", "get", "int(long,string)");
.Ve
.SS "get_bool_object_value"
.IX Subsection "get_bool_object_value"
.Vb 1
\&  int32_t (*get_bool_object_value)(SPVM_ENV* env, void* bool_object);
.Ve
.PP
Get the value of a Bool object. If the Bool object is true, return 1, otherwise return 0.
.PP
\&\fBExamples:\fR
.PP
.Vb 1
\&  int32_t bool_value = env\->get_bool_object_value(env, bool_object);
.Ve
.SH "Utilities"
.IX Header "Utilities"
Utilities.
.SS "spvmgenlib"
.IX Subsection "spvmgenlib"
If you want to create \s-1SPVM\s0 module that have the native module, spvmgenlib is useful.
.IP "\(bu" 2
spvmgenlib
.SH "Examples"
.IX Header "Examples"
.IP "\(bu" 2
Examples using \s-1SPVM\s0 Native APIs <https://github.com/yuki-kimoto/SPVM/tree/master/examples/native>
