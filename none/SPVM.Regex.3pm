.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "SPVM::Regex 3"
.TH SPVM::Regex 3 "2022-01-28" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
SPVM::Regex \- Regex in SPVM | Regular expression
.SH "SYNOPSYS"
.IX Header "SYNOPSYS"
.Vb 1
\&  use Regex;
\&  
\&  # Pattern match
\&  {
\&    my $re = Regex\->new("ab*c");
\&    my $target = "zabcz";
\&    my $match = $re\->match($target, 0);
\&  }
\&
\&  # Pattern match \- UTF\-8
\&  {
\&    my $re = Regex\->new("あ+");
\&    my $target = "いあああい";
\&    my $match = $re\->match($target, 0);
\&  }
\&
\&  # Pattern match \- Character class and the nagation
\&  {
\&    my $re = Regex\->new("[A\-Z]+[^A\-Z]+");
\&    my $target = "ABCzab";
\&    my $match = $re\->match($target, 0);
\&  }
\&
\&  # Pattern match with captures
\&  {
\&    my $re = Regex\->new("^(\ew+) (\ew+) (\ew+)$");
\&    my $target = "abc1 abc2 abc3";
\&    my $match = $re\->match($target, 0);
\&    
\&    if ($match) {
\&      my $cap1 = $re\->captures\->[0];
\&      my $cap2 = $re\->captures\->[1];
\&      my $cpa3 = $re\->captures\->[2];
\&    }
\&  }
\&  
\&  # Replace
\&  {
\&    my $re = Regex\->new("abc");
\&    my $target = "ppzabcz";
\&    
\&    # "ppzABCz"
\&    my $result = $re\->replace($target, 0, "ABC");
\&    
\&    my $replace_count = $re\->replace_count;
\&  }
\&
\&  # Replace with a callback and capture
\&  {
\&    my $re = Regex\->new("a(bc)");
\&    my $target = "ppzabcz";
\&    
\&    # "ppzABbcCz"
\&    my $result = $re\->replace_cb($target, 0, method : string ($re : Regex) {
\&      return "AB" . $re\->captures\->[0] . "C";
\&    });
\&  }
\&
\&  # Replace all
\&  {
\&    my $re = Regex\->new("abc");
\&    my $target = "ppzabczabcz";
\&    
\&    # "ppzABCzABCz"
\&    my $result = $re\->replace_all($target, 0, "ABC");
\&  }
\&
\&  # Replace all with a callback and capture
\&  {
\&    my $re = Regex\->new("a(bc)");
\&    my $target = "ppzabczabcz";
\&    
\&    # "ppzABCbcPQRSzABCbcPQRSz"
\&    my $result = $re\->replace_all_cb($target, 0, method : string ($re : Regex) {
\&      return "ABC" . $re\->captures\->[0] . "PQRS";
\&    });
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Regex provides regular expression functions.
.SH "REGULAR EXPRESSION SYNTAX"
.IX Header "REGULAR EXPRESSION SYNTAX"
Regex provides the methodset of Perl regular expression. The target string and regex string is interpretted as \s-1UTF\-8\s0 string.
.PP
.Vb 5
\&  # Quantifier
\&  +     more than or equals to 1 repeats
\&  *     more than or equals to 0 repeats
\&  ?     0 or 1 repeats
\&  {m,n} repeats between m and n
\&  
\&  # Regular expression character
\&  ^    first of string
\&  $    last of string
\&  .    all character except "\en"
\&  
\&  #    Default mode     ASCII mode
\&  \ed   Not supported    [0\-9]
\&  \eD   Not supported    not \ed
\&  \es   Not supported    " ", "\et", "\ef", "\er", "\en"
\&  \eS   Not supported    not \es
\&  \ew   Not supported    [a\-zA\-Z0\-9_]
\&  \eW   Not supported    not \ew
\&  
\&  # Character class and the negatiton
\&  [a\-z0\-9]
\&  [^a\-z0\-9]
\&  
\&  # Capture
\&  (foo)
.Ve
.PP
\&\fBRegex Options:\fR
.PP
.Vb 2
\&  s    single line mode
\&  a    ascii mode
.Ve
.PP
Regex options is used by \f(CW\*(C`new_with_options\*(C'\fR method.
.PP
.Vb 1
\&  my $re = Regex\->new("^ab+c", "sa");
.Ve
.PP
\&\fBLimitations:\fR
.PP
Regex do not support the same set of characters after a quantifier.
.PP
.Vb 5
\&  # A exception occurs
\&  Regex\->new("a*a");
\&  Regex\->new("a?a");
\&  Regex\->new("a+a");
\&  Regex\->new("a{1,3}a")
.Ve
.PP
If 0 width quantifir is between two same set of characters after a quantifier, it is invalid.
.PP
.Vb 3
\&  # A exception occurs
\&  Regex\->new("\ed+\eD*\ed+");
\&  Regex\->new("\ed+\eD?\ed+");
.Ve
.SH "CLASS METHODS"
.IX Header "CLASS METHODS"
.SS "new"
.IX Subsection "new"
.Vb 1
\&  my $re = Regex\->new("^ab+c");
.Ve
.PP
Create a new Regex object and compile the regex.
.SS "new_with_options"
.IX Subsection "new_with_options"
.Vb 1
\&  my $re = Regex\->new("^ab+c", "s");
.Ve
.PP
Create a new Regex object and compile the regex with the options.
.SH "INSTANCE METHODS"
.IX Header "INSTANCE METHODS"
.SS "captures"
.IX Subsection "captures"
.Vb 1
\&  static method captures : string[] ()
.Ve
.PP
Get the strings captured by \*(L"match\*(R" method.
.SS "match_start"
.IX Subsection "match_start"
.Vb 1
\&  static method match_start : int ()
.Ve
.PP
Get the start byte offset of the string matched by \*(L"match\*(R" method method.
.SS "match_length"
.IX Subsection "match_length"
.Vb 1
\&  static method match_length : int ()
.Ve
.PP
Get the byte length of the string matched by \*(L"match\*(R" method method.
.SS "replace_count"
.IX Subsection "replace_count"
.Vb 1
\&  static method replace_count : int ();
.Ve
.PP
Get the replace count of the strings replaced by \*(L"replace\*(R" or \*(L"replace_all\*(R" method.
.SS "match"
.IX Subsection "match"
.Vb 1
\&  method match : int ($target : string, $target_offset : int)
.Ve
.PP
Execute pattern matching to the specific string and the start byte offset of the string.
.PP
If the pattern match succeeds, 1 is returned, otherwise 0 is returned.
.PP
You can get captured strings using \*(L"captures\*(R" method,
and get the byte offset of the matched whole string using \*(L"match_start\*(R" method,
and get the length of the matched whole string using \*(L"match_length\*(R" method.
.SS "replace"
.IX Subsection "replace"
.Vb 1
\&  method replace  : string ($target : string, $target_offset : int, $replace : string)
.Ve
.PP
Replace the target string specified with the start byte offset with replace string.
.SS "replace_cb"
.IX Subsection "replace_cb"
.Vb 1
\&  method replace_cb  : string ($target : string, $target_offset : int, $replace_cb : Regex::Replacer)
.Ve
.PP
Replace the target string specified with the start byte offset with replace callback. The callback must have \*(L"replace_to\*(R" method defined in Regex::Replacer.
.SS "replace_all"
.IX Subsection "replace_all"
.Vb 1
\&  method replace_all  : string ($target : string, $target_offset : int, $replace : string)
.Ve
.PP
Replace all of the target strings specified with the start byte offset with replace string.
.SS "replace_all_cb"
.IX Subsection "replace_all_cb"
.Vb 1
\&  method replace_all_cb  : string ($target : string, $target_offset : int, $replace_cb : Regex::Replacer)
.Ve
.PP
Replace all of the target strings specified with the start byte offset with replace callback. The callback must have \*(L"replace_to\*(R" method defined in Regex::Replacer.
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 22:" 4
.IX Item "Around line 22:"
Non-ASCII character seen before =encoding in 'Regex\->new(\*(L"あ+\*(R");'. Assuming \s-1UTF\-8\s0
