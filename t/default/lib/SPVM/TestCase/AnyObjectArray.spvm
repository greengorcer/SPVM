class TestCase::AnyObjectArray {
  use Point;
  
  static method basic : int () {
    
    # object[] - assign numeric object
    {
      # object[] can be assigned Int[] object
      my $obj_nums : object[] = [Int->new(1), Int->new(2), Int->new(3)];
      
      # Can get element
      my $obj_num0 = (Int)$obj_nums->[0];
      my $obj_num1 = (Int)$obj_nums->[1];
      my $obj_num2 = (Int)$obj_nums->[2];
      unless ((int)$obj_num0 == 1) {
        return 0;
      }
      unless ((int)$obj_num1 == 2) {
        return 0;
      }
      unless ((int)$obj_num2 == 3) {
        return 0;
      }
      
      # Array invalid range access
      eval {
        $obj_nums->[3];
      };
      unless ($@) {
        return 0;
      }
      
      # isa return real type
      unless ($obj_nums isa Int[]) {
        return 0;
      }
      
      # Int type can be assigned
      $obj_nums->[2] = Int->new(4);
      
      # If other type is assinged, runtime exception occur
      eval {
        $obj_nums->[0] = Long->new(2);
      };
      unless ($@) {
        return 0;
      }
      
      # Cast to Int[];
      my $obj_ints = (Int[])$obj_nums;
      unless ($obj_ints isa Int[]) {
        return 0;
      }
      
      # Cast to Invalid array type, runtime exception occur
      eval {
        (Long[])$obj_nums;
      };
      unless ($@) {
        return 0;
      }
      
      # Can assign undef
      {
        my $obj_elems : object[] = undef;
        unless ($obj_elems == undef) {
          return 0;
        }
      }
    }
    
    # Multi-Dimensional Array
    {
      my $objects : object[] = new Point[][3];
      $objects->(Point[][])->[0] = new Point[3];
      my $point : Point = $objects->(Point[][])->[0][0];
    }
    
    $@ = undef;
    return 1;
  }
  
}
