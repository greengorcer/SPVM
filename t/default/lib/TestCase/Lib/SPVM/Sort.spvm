package TestCase::Lib::SPVM::Sort {
  use SPVM::Sort;
  use SPVM::Util;
  use TestCase::Minimal;
  
  sub sortb : int () {
    # Sort array by asc order
    {
      my $nums = [(byte)2, 3, 1];
      
      SPVM::Sort->sortb($nums, 0, scalar @$nums, sub : int ($self : self, $a : byte, $b : byte) {
        return $a <=> $b;
      });
      
      unless (SPVM::Util->equals_byte_array($nums, [(byte)1, 2, 3])) {
        return 0;
      }
    }

    # Sort array by asc order more long
    {
      my $nums = [(byte)5, 7, 9, 2, 4, 8, 1, 3, 6, 0];
      
      SPVM::Sort->sortb($nums, 0, scalar @$nums, sub : int ($self : self, $a : byte, $b : byte) {
        return $a <=> $b;
      });
      
      unless (SPVM::Util->equals_byte_array($nums, [(byte)0, 1, 2, 3, 4, 5, 6, 7, 8, 9])) {
        return 0;
      }
    }

    # Sort array by asc order more long with same values
    {
      my $nums = [(byte)5, 7, 9, 2, 5, 4, 8, 1, 3, 6, 3, 0];
      
      SPVM::Sort->sortb($nums, 0, scalar @$nums, sub : int ($self : self, $a : byte, $b : byte) {
        return $a <=> $b;
      });
      
      unless (SPVM::Util->equals_byte_array($nums, [(byte)0, 1, 2, 3, 3, 4, 5, 5, 6, 7, 8, 9])) {
        return 0;
      }
    }

    # Sort byte array by desc order
    {
      my $nums = [(byte)2, 3, 1];
      
      SPVM::Sort->sortb($nums, 0, scalar @$nums, sub : int ($self : self, $a : byte, $b : byte) {
        return $b <=> $a;
      });
      
      unless (SPVM::Util->equals_byte_array($nums, [(byte)3, 2, 1])) {
        return 0;
      }
    }

    # If length is 0, There is nothing to do
    {
      my $nums = [(byte)2, 3, 1];
      
      SPVM::Sort->sortb($nums, 0, 0, sub : int ($self : self, $a : byte, $b : byte) {
        return $a <=> $b;
      });
      
      unless (SPVM::Util->equals_byte_array($nums, [(byte)2, 3, 1])) {
        return 0;
      }
    }
    
    # Sort partially
    {
      my $nums = [(byte)5, 2, 3, 1, -10];
      
      SPVM::Sort->sortb($nums, 1, 3, sub : int ($self : self, $a : byte, $b : byte) {
        return $a <=> $b;
      });
      
      unless (SPVM::Util->equals_byte_array($nums, [(byte)5, 1, 2, 3, -10])) {
        return 0;
      }
    }

    # Exception - Array must be not undef
    {
      my $nums = [(byte)2, 3, 1];
      
      eval {
        SPVM::Sort->sortb(undef, 0, scalar @$nums, sub : int ($self : self, $a : byte, $b : byte) {
          return $a <=> $b;
        });
      };
      unless ($@) {
        return 0;
      }
    }
    
    # Exception - Offset must be more than or equals to 0
    {
      my $nums = [(byte)5, 2, 3, 1, -10];
      
      eval {
        SPVM::Sort->sortb($nums, -1, 3, sub : int ($self : self, $a : byte, $b : byte) {
          return $a <=> $b;
        });
      };
      unless ($@) {
        return 0;
      }
    }

    # Exception - Length must be more than or equals to 0
    {
      my $nums = [(byte)5, 2, 3, 1, -10];
      
      eval {
        SPVM::Sort->sortb($nums, 1, -1, sub : int ($self : self, $a : byte, $b : byte) {
          return $a <=> $b;
        });
      };
      unless ($@) {
        return 0;
      }
    }

    # Exception - Offset + Length must be in the array range
    {
      my $nums = [(byte)5, 2, 3, 1, -10];
      
      eval {
        SPVM::Sort->sortb($nums, 3, 3, sub : int ($self : self, $a : byte, $b : byte) {
          return $a <=> $b;
        });
      };
      unless ($@) {
        return 0;
      }
    }
    
    $@ = undef;
    
    return 1;
  }

  sub sorts : int () {
    # Sort array by asc order
    {
      my $nums = [(short)2, 3, 1];
      
      SPVM::Sort->sorts($nums, 0, scalar @$nums, sub : int ($self : self, $a : short, $b : short) {
        return $a <=> $b;
      });
      
      unless (SPVM::Util->equals_short_array($nums, [(short)1, 2, 3])) {
        return 0;
      }
    }

    # Sort array by asc order more long
    {
      my $nums = [(short)5, 7, 9, 2, 4, 8, 1, 3, 6, 0];
      
      SPVM::Sort->sorts($nums, 0, scalar @$nums, sub : int ($self : self, $a : short, $b : short) {
        return $a <=> $b;
      });
      
      unless (SPVM::Util->equals_short_array($nums, [(short)0, 1, 2, 3, 4, 5, 6, 7, 8, 9])) {
        return 0;
      }
    }

    # Sort array by asc order more long with same values
    {
      my $nums = [(short)5, 7, 9, 2, 5, 4, 8, 1, 3, 6, 3, 0];
      
      SPVM::Sort->sorts($nums, 0, scalar @$nums, sub : int ($self : self, $a : short, $b : short) {
        return $a <=> $b;
      });
      
      unless (SPVM::Util->equals_short_array($nums, [(short)0, 1, 2, 3, 3, 4, 5, 5, 6, 7, 8, 9])) {
        return 0;
      }
    }

    # Sort short array by desc order
    {
      my $nums = [(short)2, 3, 1];
      
      SPVM::Sort->sorts($nums, 0, scalar @$nums, sub : int ($self : self, $a : short, $b : short) {
        return $b <=> $a;
      });
      
      unless (SPVM::Util->equals_short_array($nums, [(short)3, 2, 1])) {
        return 0;
      }
    }

    # If length is 0, There is nothing to do
    {
      my $nums = [(short)2, 3, 1];
      
      SPVM::Sort->sorts($nums, 0, 0, sub : int ($self : self, $a : short, $b : short) {
        return $a <=> $b;
      });
      
      unless (SPVM::Util->equals_short_array($nums, [(short)2, 3, 1])) {
        return 0;
      }
    }
    
    # Sort partially
    {
      my $nums = [(short)5, 2, 3, 1, -10];
      
      SPVM::Sort->sorts($nums, 1, 3, sub : int ($self : self, $a : short, $b : short) {
        return $a <=> $b;
      });
      
      unless (SPVM::Util->equals_short_array($nums, [(short)5, 1, 2, 3, -10])) {
        return 0;
      }
    }

    # Exception - Array must be not undef
    {
      my $nums = [(short)2, 3, 1];
      
      eval {
        SPVM::Sort->sorts(undef, 0, scalar @$nums, sub : int ($self : self, $a : short, $b : short) {
          return $a <=> $b;
        });
      };
      unless ($@) {
        return 0;
      }
    }
    
    # Exception - Offset must be more than or equals to 0
    {
      my $nums = [(short)5, 2, 3, 1, -10];
      
      eval {
        SPVM::Sort->sorts($nums, -1, 3, sub : int ($self : self, $a : short, $b : short) {
          return $a <=> $b;
        });
      };
      unless ($@) {
        return 0;
      }
    }

    # Exception - Length must be more than or equals to 0
    {
      my $nums = [(short)5, 2, 3, 1, -10];
      
      eval {
        SPVM::Sort->sorts($nums, 1, -1, sub : int ($self : self, $a : short, $b : short) {
          return $a <=> $b;
        });
      };
      unless ($@) {
        return 0;
      }
    }

    # Exception - Offset + Length must be in the array range
    {
      my $nums = [(short)5, 2, 3, 1, -10];
      
      eval {
        SPVM::Sort->sorts($nums, 3, 3, sub : int ($self : self, $a : short, $b : short) {
          return $a <=> $b;
        });
      };
      unless ($@) {
        return 0;
      }
    }
    
    $@ = undef;
    
    return 1;
  }

  sub sorti : int () {
    # Sort array by asc order
    {
      my $nums = [(int)2, 3, 1];
      
      SPVM::Sort->sorti($nums, 0, scalar @$nums, sub : int ($self : self, $a : int, $b : int) {
        return $a <=> $b;
      });
      
      unless (SPVM::Util->equals_int_array($nums, [(int)1, 2, 3])) {
        return 0;
      }
    }

    # Sort array by asc order more long
    {
      my $nums = [(int)5, 7, 9, 2, 4, 8, 1, 3, 6, 0];
      
      SPVM::Sort->sorti($nums, 0, scalar @$nums, sub : int ($self : self, $a : int, $b : int) {
        return $a <=> $b;
      });
      
      unless (SPVM::Util->equals_int_array($nums, [(int)0, 1, 2, 3, 4, 5, 6, 7, 8, 9])) {
        return 0;
      }
    }

    # Sort array by asc order more long with same values
    {
      my $nums = [(int)5, 7, 9, 2, 5, 4, 8, 1, 3, 6, 3, 0];
      
      SPVM::Sort->sorti($nums, 0, scalar @$nums, sub : int ($self : self, $a : int, $b : int) {
        return $a <=> $b;
      });
      
      unless (SPVM::Util->equals_int_array($nums, [(int)0, 1, 2, 3, 3, 4, 5, 5, 6, 7, 8, 9])) {
        return 0;
      }
    }

    # Sort int array by desc order
    {
      my $nums = [(int)2, 3, 1];
      
      SPVM::Sort->sorti($nums, 0, scalar @$nums, sub : int ($self : self, $a : int, $b : int) {
        return $b <=> $a;
      });
      
      unless (SPVM::Util->equals_int_array($nums, [(int)3, 2, 1])) {
        return 0;
      }
    }

    # If length is 0, There is nothing to do
    {
      my $nums = [(int)2, 3, 1];
      
      SPVM::Sort->sorti($nums, 0, 0, sub : int ($self : self, $a : int, $b : int) {
        return $a <=> $b;
      });
      
      unless (SPVM::Util->equals_int_array($nums, [(int)2, 3, 1])) {
        return 0;
      }
    }
    
    # Sort partially
    {
      my $nums = [(int)5, 2, 3, 1, -10];
      
      SPVM::Sort->sorti($nums, 1, 3, sub : int ($self : self, $a : int, $b : int) {
        return $a <=> $b;
      });
      
      unless (SPVM::Util->equals_int_array($nums, [(int)5, 1, 2, 3, -10])) {
        return 0;
      }
    }

    # Exception - Array must be not undef
    {
      my $nums = [(int)2, 3, 1];
      
      eval {
        SPVM::Sort->sorti(undef, 0, scalar @$nums, sub : int ($self : self, $a : int, $b : int) {
          return $a <=> $b;
        });
      };
      unless ($@) {
        return 0;
      }
    }
    
    # Exception - Offset must be more than or equals to 0
    {
      my $nums = [(int)5, 2, 3, 1, -10];
      
      eval {
        SPVM::Sort->sorti($nums, -1, 3, sub : int ($self : self, $a : int, $b : int) {
          return $a <=> $b;
        });
      };
      unless ($@) {
        return 0;
      }
    }

    # Exception - Length must be more than or equals to 0
    {
      my $nums = [(int)5, 2, 3, 1, -10];
      
      eval {
        SPVM::Sort->sorti($nums, 1, -1, sub : int ($self : self, $a : int, $b : int) {
          return $a <=> $b;
        });
      };
      unless ($@) {
        return 0;
      }
    }

    # Exception - Offset + Length must be in the array range
    {
      my $nums = [(int)5, 2, 3, 1, -10];
      
      eval {
        SPVM::Sort->sorti($nums, 3, 3, sub : int ($self : self, $a : int, $b : int) {
          return $a <=> $b;
        });
      };
      unless ($@) {
        return 0;
      }
    }
    
    $@ = undef;
    
    return 1;
  }

  sub sortl : int () {
    # Sort array by asc order
    {
      my $nums = [(long)2, 3, 1];
      
      SPVM::Sort->sortl($nums, 0, scalar @$nums, sub : int ($self : self, $a : long, $b : long) {
        return $a <=> $b;
      });
      
      unless (SPVM::Util->equals_long_array($nums, [(long)1, 2, 3])) {
        return 0;
      }
    }

    # Sort array by asc order more long
    {
      my $nums = [(long)5, 7, 9, 2, 4, 8, 1, 3, 6, 0];
      
      SPVM::Sort->sortl($nums, 0, scalar @$nums, sub : int ($self : self, $a : long, $b : long) {
        return $a <=> $b;
      });
      
      unless (SPVM::Util->equals_long_array($nums, [(long)0, 1, 2, 3, 4, 5, 6, 7, 8, 9])) {
        return 0;
      }
    }

    # Sort array by asc order more long with same values
    {
      my $nums = [(long)5, 7, 9, 2, 5, 4, 8, 1, 3, 6, 3, 0];
      
      SPVM::Sort->sortl($nums, 0, scalar @$nums, sub : int ($self : self, $a : long, $b : long) {
        return $a <=> $b;
      });
      
      unless (SPVM::Util->equals_long_array($nums, [(long)0, 1, 2, 3, 3, 4, 5, 5, 6, 7, 8, 9])) {
        return 0;
      }
    }

    # Sort long array by desc order
    {
      my $nums = [(long)2, 3, 1];
      
      SPVM::Sort->sortl($nums, 0, scalar @$nums, sub : int ($self : self, $a : long, $b : long) {
        return $b <=> $a;
      });
      
      unless (SPVM::Util->equals_long_array($nums, [(long)3, 2, 1])) {
        return 0;
      }
    }

    # If length is 0, There is nothing to do
    {
      my $nums = [(long)2, 3, 1];
      
      SPVM::Sort->sortl($nums, 0, 0, sub : int ($self : self, $a : long, $b : long) {
        return $a <=> $b;
      });
      
      unless (SPVM::Util->equals_long_array($nums, [(long)2, 3, 1])) {
        return 0;
      }
    }
    
    # Sort partially
    {
      my $nums = [(long)5, 2, 3, 1, -10];
      
      SPVM::Sort->sortl($nums, 1, 3, sub : int ($self : self, $a : long, $b : long) {
        return $a <=> $b;
      });
      
      unless (SPVM::Util->equals_long_array($nums, [(long)5, 1, 2, 3, -10])) {
        return 0;
      }
    }

    # Exception - Array must be not undef
    {
      my $nums = [(long)2, 3, 1];
      
      eval {
        SPVM::Sort->sortl(undef, 0, scalar @$nums, sub : int ($self : self, $a : long, $b : long) {
          return $a <=> $b;
        });
      };
      unless ($@) {
        return 0;
      }
    }
    
    # Exception - Offset must be more than or equals to 0
    {
      my $nums = [(long)5, 2, 3, 1, -10];
      
      eval {
        SPVM::Sort->sortl($nums, -1, 3, sub : int ($self : self, $a : long, $b : long) {
          return $a <=> $b;
        });
      };
      unless ($@) {
        return 0;
      }
    }

    # Exception - Length must be more than or equals to 0
    {
      my $nums = [(long)5, 2, 3, 1, -10];
      
      eval {
        SPVM::Sort->sortl($nums, 1, -1, sub : int ($self : self, $a : long, $b : long) {
          return $a <=> $b;
        });
      };
      unless ($@) {
        return 0;
      }
    }

    # Exception - Offset + Length must be in the array range
    {
      my $nums = [(long)5, 2, 3, 1, -10];
      
      eval {
        SPVM::Sort->sortl($nums, 3, 3, sub : int ($self : self, $a : long, $b : long) {
          return $a <=> $b;
        });
      };
      unless ($@) {
        return 0;
      }
    }
    
    $@ = undef;
    
    return 1;
  }

  sub sortf : int () {
    # Sort array by asc order
    {
      my $nums = [(float)2, 3, 1];
      
      SPVM::Sort->sortf($nums, 0, scalar @$nums, sub : int ($self : self, $a : float, $b : float) {
        return $a <=> $b;
      });
      
      unless (SPVM::Util->equals_float_array($nums, [(float)1, 2, 3])) {
        return 0;
      }
    }

    # Sort array by asc order more long
    {
      my $nums = [(float)5, 7, 9, 2, 4, 8, 1, 3, 6, 0];
      
      SPVM::Sort->sortf($nums, 0, scalar @$nums, sub : int ($self : self, $a : float, $b : float) {
        return $a <=> $b;
      });
      
      unless (SPVM::Util->equals_float_array($nums, [(float)0, 1, 2, 3, 4, 5, 6, 7, 8, 9])) {
        return 0;
      }
    }

    # Sort array by asc order more long with same values
    {
      my $nums = [(float)5, 7, 9, 2, 5, 4, 8, 1, 3, 6, 3, 0];
      
      SPVM::Sort->sortf($nums, 0, scalar @$nums, sub : int ($self : self, $a : float, $b : float) {
        return $a <=> $b;
      });
      
      unless (SPVM::Util->equals_float_array($nums, [(float)0, 1, 2, 3, 3, 4, 5, 5, 6, 7, 8, 9])) {
        return 0;
      }
    }

    # Sort float array by desc order
    {
      my $nums = [(float)2, 3, 1];
      
      SPVM::Sort->sortf($nums, 0, scalar @$nums, sub : int ($self : self, $a : float, $b : float) {
        return $b <=> $a;
      });
      
      unless (SPVM::Util->equals_float_array($nums, [(float)3, 2, 1])) {
        return 0;
      }
    }

    # If length is 0, There is nothing to do
    {
      my $nums = [(float)2, 3, 1];
      
      SPVM::Sort->sortf($nums, 0, 0, sub : int ($self : self, $a : float, $b : float) {
        return $a <=> $b;
      });
      
      unless (SPVM::Util->equals_float_array($nums, [(float)2, 3, 1])) {
        return 0;
      }
    }
    
    # Sort partially
    {
      my $nums = [(float)5, 2, 3, 1, -10];
      
      SPVM::Sort->sortf($nums, 1, 3, sub : int ($self : self, $a : float, $b : float) {
        return $a <=> $b;
      });
      
      unless (SPVM::Util->equals_float_array($nums, [(float)5, 1, 2, 3, -10])) {
        return 0;
      }
    }

    # Exception - Array must be not undef
    {
      my $nums = [(float)2, 3, 1];
      
      eval {
        SPVM::Sort->sortf(undef, 0, scalar @$nums, sub : int ($self : self, $a : float, $b : float) {
          return $a <=> $b;
        });
      };
      unless ($@) {
        return 0;
      }
    }
    
    # Exception - Offset must be more than or equals to 0
    {
      my $nums = [(float)5, 2, 3, 1, -10];
      
      eval {
        SPVM::Sort->sortf($nums, -1, 3, sub : int ($self : self, $a : float, $b : float) {
          return $a <=> $b;
        });
      };
      unless ($@) {
        return 0;
      }
    }

    # Exception - Length must be more than or equals to 0
    {
      my $nums = [(float)5, 2, 3, 1, -10];
      
      eval {
        SPVM::Sort->sortf($nums, 1, -1, sub : int ($self : self, $a : float, $b : float) {
          return $a <=> $b;
        });
      };
      unless ($@) {
        return 0;
      }
    }

    # Exception - Offset + Length must be in the array range
    {
      my $nums = [(float)5, 2, 3, 1, -10];
      
      eval {
        SPVM::Sort->sortf($nums, 3, 3, sub : int ($self : self, $a : float, $b : float) {
          return $a <=> $b;
        });
      };
      unless ($@) {
        return 0;
      }
    }
    
    $@ = undef;
    
    return 1;
  }

  sub sortd : int () {
    # Sort array by asc order
    {
      my $nums = [(double)2, 3, 1];
      
      SPVM::Sort->sortd($nums, 0, scalar @$nums, sub : int ($self : self, $a : double, $b : double) {
        return $a <=> $b;
      });
      
      unless (SPVM::Util->equals_double_array($nums, [(double)1, 2, 3])) {
        return 0;
      }
    }

    # Sort array by asc order more long
    {
      my $nums = [(double)5, 7, 9, 2, 4, 8, 1, 3, 6, 0];
      
      SPVM::Sort->sortd($nums, 0, scalar @$nums, sub : int ($self : self, $a : double, $b : double) {
        return $a <=> $b;
      });
      
      unless (SPVM::Util->equals_double_array($nums, [(double)0, 1, 2, 3, 4, 5, 6, 7, 8, 9])) {
        return 0;
      }
    }

    # Sort array by asc order more long with same values
    {
      my $nums = [(double)5, 7, 9, 2, 5, 4, 8, 1, 3, 6, 3, 0];
      
      SPVM::Sort->sortd($nums, 0, scalar @$nums, sub : int ($self : self, $a : double, $b : double) {
        return $a <=> $b;
      });
      
      unless (SPVM::Util->equals_double_array($nums, [(double)0, 1, 2, 3, 3, 4, 5, 5, 6, 7, 8, 9])) {
        return 0;
      }
    }

    # Sort double array by desc order
    {
      my $nums = [(double)2, 3, 1];
      
      SPVM::Sort->sortd($nums, 0, scalar @$nums, sub : int ($self : self, $a : double, $b : double) {
        return $b <=> $a;
      });
      
      unless (SPVM::Util->equals_double_array($nums, [(double)3, 2, 1])) {
        return 0;
      }
    }

    # If length is 0, There is nothing to do
    {
      my $nums = [(double)2, 3, 1];
      
      SPVM::Sort->sortd($nums, 0, 0, sub : int ($self : self, $a : double, $b : double) {
        return $a <=> $b;
      });
      
      unless (SPVM::Util->equals_double_array($nums, [(double)2, 3, 1])) {
        return 0;
      }
    }
    
    # Sort partially
    {
      my $nums = [(double)5, 2, 3, 1, -10];
      
      SPVM::Sort->sortd($nums, 1, 3, sub : int ($self : self, $a : double, $b : double) {
        return $a <=> $b;
      });
      
      unless (SPVM::Util->equals_double_array($nums, [(double)5, 1, 2, 3, -10])) {
        return 0;
      }
    }

    # Exception - Array must be not undef
    {
      my $nums = [(double)2, 3, 1];
      
      eval {
        SPVM::Sort->sortd(undef, 0, scalar @$nums, sub : int ($self : self, $a : double, $b : double) {
          return $a <=> $b;
        });
      };
      unless ($@) {
        return 0;
      }
    }
    
    # Exception - Offset must be more than or equals to 0
    {
      my $nums = [(double)5, 2, 3, 1, -10];
      
      eval {
        SPVM::Sort->sortd($nums, -1, 3, sub : int ($self : self, $a : double, $b : double) {
          return $a <=> $b;
        });
      };
      unless ($@) {
        return 0;
      }
    }

    # Exception - Length must be more than or equals to 0
    {
      my $nums = [(double)5, 2, 3, 1, -10];
      
      eval {
        SPVM::Sort->sortd($nums, 1, -1, sub : int ($self : self, $a : double, $b : double) {
          return $a <=> $b;
        });
      };
      unless ($@) {
        return 0;
      }
    }

    # Exception - Offset + Length must be in the array range
    {
      my $nums = [(double)5, 2, 3, 1, -10];
      
      eval {
        SPVM::Sort->sortd($nums, 3, 3, sub : int ($self : self, $a : double, $b : double) {
          return $a <=> $b;
        });
      };
      unless ($@) {
        return 0;
      }
    }
    
    $@ = undef;
    
    return 1;
  }
  
  sub new_minimal : TestCase::Minimal ($x : int, $y : int) {
    my $minimal = TestCase::Minimal->new;
    $minimal->set_x($x);
    $minimal->set_y($y);
    
    return $minimal;
  }
  
  sub sorto : int () {
    
    # Sort array by asc order
    {
      my $objs = [new_minimal(2, 0), new_minimal(3, 0), new_minimal(1, 0)];
      
      SPVM::Sort->sorto($objs, 0, scalar @$objs, sub : int ($self : self, $a : object, $b : object) {
        return ((TestCase::Minimal)$a)->x <=> ((TestCase::Minimal)$b)->x;
      });
      
      my $is_equals = SPVM::Util->equals_object_array($objs, [new_minimal(1, 0), new_minimal(2, 0), new_minimal(3, 0)], sub : int ($self : self, $a : object, $b : object) {
        return ((TestCase::Minimal)$a)->x == ((TestCase::Minimal)$b)->x;
      });
      
      unless ($is_equals) {
        return 0;
      }
    }

    # Sort array by multiple conditions
    {
      my $objs = [new_minimal(2, 1), new_minimal(2, 2), new_minimal(1, 3)];

      SPVM::Sort->sorto($objs, 0, scalar @$objs, sub : int ($self : self, $a : object, $b : object) {
        my $a_x = ((TestCase::Minimal)$a)->x;
        my $a_y = ((TestCase::Minimal)$a)->y;
        my $b_x = ((TestCase::Minimal)$b)->x;
        my $b_y = ((TestCase::Minimal)$b)->y;
        
        my $cmp = ((TestCase::Minimal)$a)->x <=> ((TestCase::Minimal)$b)->x;
        if ($cmp != 0) {
          return $cmp;
        }
        else {
          $cmp = ((TestCase::Minimal)$a)->y <=> ((TestCase::Minimal)$b)->y;
        }
        
        return $cmp;
      });

      my $is_equals = SPVM::Util->equals_object_array($objs, [new_minimal(1, 3), new_minimal(2, 1), new_minimal(2, 2)], sub : int ($self : self, $a : object, $b : object) {
        if (((TestCase::Minimal)$a)->x == ((TestCase::Minimal)$b)->x && ((TestCase::Minimal)$a)->y == ((TestCase::Minimal)$b)->y) {
          return 1;
        }
        else {
          return 0;
        }
      });
      
      unless ($is_equals) {
        return 0;
      }
    }

    # Sort array by desc order
    {
      my $objs = [new_minimal(2, 0), new_minimal(3, 0), new_minimal(1, 0)];
      
      SPVM::Sort->sorto($objs, 0, scalar @$objs, sub : int ($self : self, $a : object, $b : object) {
        return ((TestCase::Minimal)$b)->x <=> ((TestCase::Minimal)$a)->x;
      });
      
      my $is_equals = SPVM::Util->equals_object_array($objs, [new_minimal(3, 0), new_minimal(2, 0), new_minimal(1, 0)], sub : int ($self : self, $a : object, $b : object) {
        return ((TestCase::Minimal)$a)->x == ((TestCase::Minimal)$b)->x;
      });
      
      unless ($is_equals) {
        return 0;
      }
    }

    # If length is 0, There is nothing to do
    {
      my $objs = [new_minimal(2, 0), new_minimal(3, 0), new_minimal(1, 0)];
      
      SPVM::Sort->sorto($objs, 0, 0, sub : int ($self : self, $a : object, $b : object) {
        return ((TestCase::Minimal)$a)->x <=> ((TestCase::Minimal)$b)->x;
      });
      
      my $is_equals = SPVM::Util->equals_object_array($objs, [new_minimal(2, 0), new_minimal(3, 0), new_minimal(1, 0)], sub : int ($self : self, $a : object, $b : object) {
        return ((TestCase::Minimal)$a)->x == ((TestCase::Minimal)$b)->x;
      });
      unless ($is_equals) {
        return 0;
      }
    }
    
    # Sort partially
    {
      my $objs = [new_minimal(5, 0), new_minimal(2, 0), new_minimal(3, 0), new_minimal(1, 0), new_minimal(-10, 0)];
      
      SPVM::Sort->sorto($objs, 1, 3, sub : int ($self : self, $a : object, $b : object) {
        return ((TestCase::Minimal)$a)->x <=> ((TestCase::Minimal)$b)->x;
      });
      
      my $is_equals = SPVM::Util->equals_object_array(
        $objs,
        [new_minimal(5, 0), new_minimal(1, 0), new_minimal(2, 0), new_minimal(3, 0), new_minimal(-10, 0)],
        sub : int ($self : self, $a : object, $b : object) {
          return ((TestCase::Minimal)$a)->x == ((TestCase::Minimal)$b)->x;
        }
      );
      unless ($is_equals) {
        return 0;
      }
    }

    # Exception - Array must be not undef
    {
      my $objs = [new_minimal(2, 0), new_minimal(3, 0), new_minimal(1, 0)];
      
      eval {
        SPVM::Sort->sorto(undef, 0, scalar @$objs, sub : int ($self : self, $a : object, $b : object) {
          return ((TestCase::Minimal)$a)->x <=> ((TestCase::Minimal)$b)->x;
        });
      };
      unless ($@) {
        return 0;
      }
    }
    
    # Exception - Offset must be more than or equals to 0
    {
      my $objs = [new_minimal(2, 0), new_minimal(3, 0), new_minimal(1, 0)];
      
      eval {
        SPVM::Sort->sorto($objs, -1, 3, sub : int ($self : self, $a : object, $b : object) {
          return ((TestCase::Minimal)$a)->x <=> ((TestCase::Minimal)$b)->x;
        });
      };
      unless ($@) {
        return 0;
      }
    }

    # Exception - Length must be more than or equals to 0
    {
      my $objs = [new_minimal(5, 0), new_minimal(2, 0), new_minimal(3, 0), new_minimal(1, 0), new_minimal(-10, 0)];
      
      eval {
        SPVM::Sort->sorto($objs, 1, -1, sub : int ($self : self, $a : object, $b : object) {
          return ((TestCase::Minimal)$a)->x <=> ((TestCase::Minimal)$b)->x;
        });
      };
      unless ($@) {
        return 0;
      }
    }

    # Exception - Offset + Length must be in the array range
    {
      my $objs = [new_minimal(5, 0), new_minimal(2, 0), new_minimal(3, 0), new_minimal(1, 0), new_minimal(-10, 0)];
      
      eval {
        SPVM::Sort->sorto($objs, 3, 3, sub : int ($self : self, $a : object, $b : object) {
          return ((TestCase::Minimal)$a)->x <=> ((TestCase::Minimal)$b)->x;
        });
      };
      unless ($@) {
        return 0;
      }
    }
    
    $@ = undef;

    return 1;
  }

}
